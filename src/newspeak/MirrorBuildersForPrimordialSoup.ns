Newspeak3
'NS2PrimordialSoup'
class MirrorBuildersForPrimordialSoup usingPlatform: p compiler: c internalKernel: k = (|
(* TODO: This need to be real identity collections for schema changes. *)
private IdentityMap = p collections IdentityDictionary.
private IdentitySet = p collections IdentitySet.

private InstanceMixin = k InstanceMixin.
private ClassMixin = k ClassMixin.
private ClassDeclarationMirror = p mirrors XXClassDeclarationMirror.
private ClassMirror = p mirrors ClassMirror.
private compiler = c.
|) (
class AtomicInstaller = (|
private updateMixinsAndClasses <IdentityMap[OldObject,NewObject]>
private updateInstances <IdentityMap[OldObject,NewObject]>
private existingClasses <IdentityMap[HierarchyDepth,Set[Class]]>
|) (
'as yet unclassified'
private elementsOf: old forwardIdentityToElementsOf: new = (
	(* :todo: *)
)
private flushCache = (
	(* :todo: *)
)
'private'
private augmentExistingMixinMap: map withNestedClasses: nestedClasses inExistingMixin: mixin  = (
	nestedClasses do:
		[:nestedClass <IntermediateClassDeclaration> |
		| name existingNestedMixin |
		name:: nestedClass simpleName.
		existingNestedMixin:: mixin nestedMixins at: name ifAbsent: [nil].
		nil = existingNestedMixin ifFalse:
			[map at: nestedClass put: existingNestedMixin.
			augmentExistingMixinMap: map
				withNestedClasses: nestedClass instanceSide nestedClasses
				inExistingMixin: existingNestedMixin]]
)
private cleanup = (
	updateMixinsAndClasses: nil.
	updateInstances: nil.
	existingClasses: nil.
)
private installAll = (
	| updateCount oldObjects newObjects index |
	updateCount:: updateMixinsAndClasses size + updateInstances size.
	oldObjects:: Array new: updateCount.
	newObjects:: Array new: updateCount.
	index: 1.
	updateInstances keysAndValuesDo: 
		[:old :new | 
		oldObjects at: index put: old.
		newObjects at: index put: new.
		index: index + 1].
	(* Put updated mixins and classes last, so A -> C follows B -> C (see class comment). *)
	updateMixinsAndClasses keysAndValuesDo: 
		[:old :new | 
		oldObjects at: index put: old.
		newObjects at: index put: (updateInstances at: old ifAbsent: [new]). (* Follow B to avoid B -> C, A -> B. *)
		index: index + 1].
	
	elementsOf: oldObjects forwardIdentityToElementsOf: newObjects.
	
	(* As of 2673, the VM ensures objects whose references are deleted in a one-way become cannot be resurrected by allInstances/allObjects.
	hadLayoutChange ifTrue: [vmmirror fullGC]. (* Ensure that objects newly made unreachable by the one-way become will not be enumerated by future uses of someInstance/nextInstance. See discussion of issue #82 and comments in ClassBuilder update:to:. *) *)
)
private setup = (
	updateMixinsAndClasses: IdentityMap new.
	updateInstances: IdentityMap new.
	existingClasses: IdentityMap new.
)
'private-classes'
private depthFor: klassArg <Class> ^<Integer> = (
	| klass d |
	d: 0.
	klass: klassArg.
	[klass isNil] whileFalse: [klass: klass superclass. d: d+1].
	^d
)
private layoutHasChangedBetween: oldClass <Behavior> and: newClass <Behavior> ^<Boolean> = (
	^oldClass allInstVarNames ~= newClass allInstVarNames
)
private newClassFor: oldClass <Class> ^<Class> = (
	
	| newSuperclass newMixin newClass |

	newSuperclass:: updateMixinsAndClasses at: oldClass superclass ifAbsent: [oldClass superclass].
	newMixin:: updateMixinsAndClasses at: oldClass mixin ifAbsent: [oldClass mixin].

#BOGUS yourself. (* Name not quite right.  Should reflect new name, but should keep the same form as the old name if it's like This`9087#450 *)
	newClass:: newMixin apply: newSuperclass withName: newMixin simpleName.
	newClass setEnclosingObjectSlot: oldClass enclosingObjectSlot.
	(* organization and category: they live in the mixin *)

	^newClass
)
private processExistingClass: oldClass <Class> = (
	| newClass <Class> |
	newClass:: newClassFor: oldClass.
	
	updateMixinsAndClasses at: oldClass put: newClass.
	updateMixinsAndClasses at: (vmmirror classOf: oldClass) put: (vmmirror classOf: newClass).
)
private processExistingClasses = (
	(* Process superclasses before subclasses. Create all new classes before remapping any instances. *)
	(* :todo: 
	existingClasses keys asSortedCollection do:
		[:inheritanceDepth <Integer> |
		(existingClasses at: inheritanceDepth) do:
			[:oldClass <Class> | processExistingClass: oldClass]].

	existingClasses valuesDo:
		[:depthSet <Set[Class]> |
		depthSet do:
			[:oldClass <Class> | processInstancesOf: oldClass]]. *)
)
private sortClass: app <Class> = (
	| classes depth |
	depth:: depthFor: app.
	classes:: existingClasses at: depth ifAbsentPut: [IdentitySet new].
	classes add: app.
	app subclassesDo: [:sc | sortClass: sc].
)
'private-instances'
private processInstancesOf: oldClass <Class> = (
	| 
	newClass <Class> = updateMixinsAndClasses at: oldClass.
	oldSlotNames <Array[Symbol]>
	newSlotCount <Integer>
	remapIndices <Array[Integer]>
	|
	(layoutHasChangedBetween: oldClass and: newClass) ifFalse: [^self].
	
	(* Heuristic: choose the latter slot if a slot name is duplicated to favor overriding slots. *)
	oldSlotNames:: oldClass allInstVarNames.
	remapIndices:: newClass allInstVarNames collect:
		[:newSlotName | oldSlotNames lastIndexOf: newSlotName ifAbsent: 0].
	newSlotCount:: remapIndices size.

	(vmmirror allInstancesOf: oldClass) do: 
		[:oldInstance |
		(* Avoid A -> D (see class comment). *)
		(updateMixinsAndClasses includesKey: oldInstance) ifFalse:
			[ | newInstance = vmmirror instantiateFixedClass: newClass. |
			(* Copy state from oldInstance to newInstance. *)
			1 to: newSlotCount do: [:newIndex |
				| oldIndex value |
				oldIndex:: remapIndices at: newIndex.
				0 == oldIndex ifFalse: [
					value:: vmmirror ifFail: [halt] namedSlotOf: oldInstance at: oldIndex.
					vmmirror ifFail: [halt] namedSlotOf: newInstance at: newIndex put: value]]. 

			updateInstances at: oldInstance put: newInstance]].
)
'private-mixins'
private methodDictionaryFor: mixin <AbstractMixin> from: imixin <IntermediateMixin> ^<MethodDictionary> = (
	| cmethods |
	cmethods:: imixin methods collect:
		[:imethod <IntermediateMethod> | 
		imethod methodMixin: mixin.
		imethod compiledMethod].
	^cmethods asArray
)
private noteUpdateOf: existingMixin <InstanceMixin | nil> to: newMixin <InstanceMixin> = (
	existingMixin isNil ifTrue: [^self].
	
	updateMixinsAndClasses at: existingMixin put: newMixin.
	updateMixinsAndClasses at: existingMixin classMixin put: newMixin classMixin.
	
	existingMixin applications do: [:app | sortClass: app].
)
private processClassDeclaration: classDecl <IntermediateClassDeclaration>
 in: existingMixinMap <IdentityMap[IntermediateClassDeclaration, InstanceMixin]>
 ^<InstanceMixin> = (
	
	|
	mixin <Mixin>
	classMixin <ClassMixin>
	existingMixin <Mixin>
	nested
	|

	mixin:: InstanceMixin new.
	classMixin:: ClassMixin new.
	
	mixin _headerSource: classDecl headerSource.
	mixin _primaryFactorySelector: classDecl factoryName.
	assert: [classDecl factoryName isNil not] message: 'Missing factory name'.
	mixin _name: classDecl simpleName.
	mixin _classMixin: classMixin.
	mixin _methods: (methodDictionaryFor: mixin from: classDecl instanceSide).
	mixin _slots: (classDecl instanceSide slots collect:
		[:s <IntermediateSlotDeclaration> | {s simpleName. s isMutable. s accessModifier}]) asArray.
	
	classMixin _instanceMixin: mixin.
	classMixin _methods: (methodDictionaryFor: classMixin from: classDecl classSide).
	
	existingMixin:: existingMixinMap at: classDecl ifAbsent: [nil].
	noteUpdateOf: existingMixin to: mixin.
	
	nil = existingMixin ifFalse: [
		(* If this is the top-most thing changed in this installation and not a top level class, the enclosingMixin won't otherwise be set and would incorrectly end up nil. *)
		mixin enclosingMixin: existingMixin enclosingMixin.
		suspicious.
		mixin classMixin enclosingMixin: existingMixin enclosingMixin].
	
	nested:: classDecl instanceSide nestedClasses collect:
		[:nestedClassDecl <IntermediateClassDeclaration> |
		| nestedMixin <InstanceMixin> |
		nestedMixin:: processClassDeclaration: nestedClassDecl in: existingMixinMap.
		nestedMixin _enclosingMixin: mixin.
		nestedMixin _classMixin _enclosingMixin: mixin.
		nestedMixin].
	mixin _nestedMixins: nested asArray.
	^mixin
)
'public access'
public install: intermediates <List[IntermediateClassDeclaration]>
 withExistingMixins: existingMixinMap <Map[IntermediateClassDeclaration, InstanceMixin]> = (
	
	| results |
	setup.
	results:: intermediates collect: 
		[:classDecl <IntermediateClassDeclaration> |
		(existingMixinMap includesKey: classDecl) ifTrue:
			[augmentExistingMixinMap: existingMixinMap
				withNestedClasses: classDecl instanceSide nestedClasses
				inExistingMixin: (existingMixinMap at: classDecl)].
		processClassDeclaration: classDecl in: existingMixinMap].
	processExistingClasses.
	installAll.
	flushCache. (* Clear all lookup caches *)
	cleanup.

	^results (* <List[InstanceMixin]> *)
)
) : (
)
public class ClassDeclarationBuilder fromIntermediate: ir forExistingMixin: mixin = (|
protected intermediate <IntermediateClassDeclaration> = ir.
protected existingMixin <InstanceMixin> = mixin.
|) (
'as yet unclassified'
public install = (
	| installer newMixin |
	installer:: AtomicInstaller new.
	nil = existingMixin ifFalse: [unimplemented].
	newMixin:: (installer install: {intermediate} withExistingMixins: IdentityMap new) first.
	^ClassDeclarationMirror reflecting: newMixin
)
) : (
'as yet unclassified'
public fromUnitSource: source <String> ^<ClassDeclarationBuilder> = (
	| ir <IntermediateClassDeclaration> |
	ir:: compiler compileClassSource: source within: nil.
	^self fromIntermediate: ir forExistingMixin: nil
)
)
public class ObjectMirror reflecting: object = (|
public reflectee = object.
|) (
'as yet unclassified'
public evaluate: expression <String>
ifCompilerError: compilationErrorHandler <[:Error]> 
ifError: evalErrorHandler <[:Error]> ^<ObjectMirror> = (
	
	(* Evaluate [expression] with the reflectee as the receiver. If [expression] cannot be compiled, activate [compilationErrorHandler] with the exception. If the evaluation of [expression] raises an error, activate [evalErrorHandler] with the error. Otherwise return an ObjectMirror on the result of [expression]. *)
	
	| cls mxn mtdMirror result |
	[cls:: classOf: reflectee.
	mxn:: (ClassMirror reflecting: cls) mixin.
	mtdMirror:: compiler
		compileExpressionSource: expression
		inContext: nil
		inMixin: mxn. 
		
	mtdMirror category: #DoIts.
	mtdMirror methodMixin: (mixinOf: cls).
	mtdMirror compiledMethod source: expression.
	(* :todo: at: #debugInfo put: mtdMirror debugInfo *)]
			on: Error
			do: [:e | ^compilationErrorHandler cull: e ].
	
	[result:: 
		object: reflectee 
		executeMethod: mtdMirror compiledMethod
		with: {}]
			on: Error
			do: [:e | ^evalErrorHandler cull: e].

	^ObjectMirror reflecting: result
)
) : (
)
'as yet unclassified'
private classOf: object = (
	(* :literalmessage: primitive: 85 *)
	primitiveFailed: 'Mirror classOf:'.
)
private mixinOf: behavior = (
	^self slotOf: behavior at: 4
)
private object: object executeMethod: method with: arguments = (
	(* :literalmessage: primitive: 95 *)
	primitiveFailed: 'executeMethod'.
)
private slotOf: object at: index = (
	(* :literalmessage: primitive: 35 *)
	primitiveFailed: 'Mirror slotOf:at:'.
)
) : (
)

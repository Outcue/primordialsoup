Newspeak3
'Mirrors'
class ActivationMirrorTesting usingPlatform: p minitest: m = (|
private ClassDeclarationBuilder = p mirrors ClassDeclarationBuilder.
private ObjectMirror = p mirrors ObjectMirror.
private ActivationMirror = p mirrors ActivationMirror.
private Message = p kernel Message.
private TestContext = m TestContext.
|) (
public class ClosureActivationTests = TestBase () (
public _testClosureActivation = (
	| closure activation |
	closure:: [3 + 4].
	activation:: ActivationMirror evaluating: closure.
	assert: activation closure equals: (ObjectMirror reflecting: closure).
)
) : (
TEST_CONTEXT = ()
)
public class SimulationTests = SuperSimulationTests (
(* Test that the Newspeak bytecodes run under image-side simulation and return the same results as the VM. *)) (
assertSimulation: block answers: expectedResult = (
	| simulatedResult |
	simulatedResult:: ActivationMirror
		simulate: block
		ifException: [:e | failWithMessage: 'Simulation signaled unhandled exception: ', e printString].
	assert: simulatedResult equals: expectedResult.
)
assertSimulation: block signals: exceptionTestBlock = (
	| simulatedResult |
	simulatedResult:: ActivationMirror
		simulate: block
		ifException: [:e | exceptionTestBlock value: e. ^self].
	failWithMessage: 'Simulation returned with: ', simulatedResult printString.
)
public bar = (
	^'bar'
)
public barWithArg: n = (
	^n + 20
)
cannotReturn = (
	^[^42]
)
ensure1 = (
	[^'try-block'] ensure: [^'ensure-block'].
	^'afterward'
)
ensure2 = (
	^['try-block'] ensure: ['ensure-block'].
)
ensure3 = (
	[^'try-block'] ensure: ['ensure-block'].
	^'afterward'
)
foo = (
	^'sub'
)
fooWithArg: n = (
	^'sub'
)
public testSimulationCannotReturn = (
	assertSimulation: [cannotReturn value] signals:
		[:simulatedException |
		 assert: (simulatedException printString startsWith: 'CannotReturn').
		 assert: simulatedException result equals: 42].
)
public testSimulationCannotReturnAcrossBoundry = (
	assertSimulation: [^'escaping simulation!'] signals:
		[:simulatedException |
		 assert: (simulatedException printString startsWith: 'CannotReturn').
		 assert: simulatedException result equals: 'escaping simulation!'].
)
public testSimulationEnclosingObject = (
	assertSimulation: [outer SimulationTests] answers: outer SimulationTests.
	assertSimulation: [outer ActivationMirrorTesting] answers: outer ActivationMirrorTesting.
)
public testSimulationExecuteMethod = (
	| mirror = ObjectMirror reflecting: self. |
	
	"a" isString ifFalse: [^self]. (* This fails badly enough on Squeak to lock up the UI. *)
	
	assertSimulation: [mirror evaluate: 'foo' ifCompilerError: [:e | fail] ifError: [:e | fail]] 
	answers: (mirror evaluate: 'foo' ifCompilerError: [:e | fail] ifError: [:e | fail]).	
)
public testSimulationImplicitReceiverSend = (
	assertSimulation: [foo] answers: 'sub'.
	assertSimulation: [fooWithArg: 1] answers: 'sub'.
	assertSimulation: [baz] answers: 'enclosing'.
)
public testSimulationNonBooleanReceiver = (
	assertSimulation: [0 ifTrue: [1]]
	signals: [:simulatedException | assert: (simulatedException printString startsWith: 'NonBooleanReceiver')].
	
	assertSimulation: [0 ifFalse: [1]]
	signals: [:simulatedException | assert: (simulatedException printString startsWith: 'NonBooleanReceiver')].
)
public testSimulationOuterSend = (
	assertSimulation: [outer SimulationTests foo] answers: 'sub'.
	assertSimulation: [outer SimulationTests fooWithArg: 1] answers: 'sub'.
	assertSimulation: [outer ActivationMirrorTesting foo] answers: 'enclosing'.
	assertSimulation: [outer ActivationMirrorTesting fooWithArg: 1] answers: 'enclosing'.
)
public testSimulationPerform0 = (
	| message = Message selector: #bar arguments: {}. |
	assertSimulation: [message sendTo: self] answers: (message sendTo: self).
)
public testSimulationPerform1 = (
	| message = Message selector: #barWithArg: arguments: {7}. |
	assertSimulation: [message sendTo: self] answers: (message sendTo: self).
)
public testSimulationSelfSend = (
	assertSimulation: [self foo] answers: 'sub'.
	assertSimulation: [self fooWithArg: 1] answers: 'sub'.
)
public testSimulationSuperSend = (
	assertSimulation: [super foo] answers: 'super'.
	assertSimulation: [super fooWithArg: 1] answers: 'super'.
)
public testSimulationUnhandledException = (
	| exception = Exception new. |
	assertSimulation: [exception signal]
	signals: [:simulatedException | assert: simulatedException equals: exception].
)
public testSimulationUnwindProtect = (
	assertSimulation: [ensure1] answers: 'ensure-block'.
	assertSimulation: [ensure2] answers: 'try-block'.
	assertSimulation: [ensure3] answers: 'try-block'.
)
public testSimulationValue0 = (
	| copied indirect closure |
	copied:: 1.
	indirect:: 2.
	closure:: [copied + indirect].
	assertSimulation: [closure value] answers: closure value.
	indirect:: 4. (* write after capture forces use of indirection vector *)
)
public testSimulationValue1 = (
	| copied indirect closure |
	copied:: 1.
	indirect:: 2.
	closure:: [:x | copied + indirect + x].
	assertSimulation: [closure value: 4] answers: (closure value: 4).
	indirect:: 4. (* write after capture forces use of indirection vector *)
)
public testSimulationValue2 = (
	| copied indirect closure |
	copied:: 1.
	indirect:: 2.
	closure:: [:x :y | copied + indirect + x - y].
	assertSimulation: [closure value: 4 value: 8] answers: (closure value: 4 value: 8).
	indirect:: 4. (* write after capture forces use of indirection vector *)
)
public testSimulationValue3 = (
	| copied indirect closure |
	copied:: 1.
	indirect:: 2.
	closure:: [:x :y :z | copied + indirect + x - y * z].
	assertSimulation: [closure value: 4 value: 8 value: 16] answers: (closure value: 4 value: 8 value: 16).
	indirect:: 4. (* write after capture forces use of indirection vector *)
)
public testSimulationValueArray = (
	| copied indirect closure |
	copied:: 1.
	indirect:: 2.
	closure:: [:x :y :z | copied + indirect + x - y * z].
	assertSimulation: [closure valueWithArguments: {4. 8. 16}] answers: (closure valueWithArguments: {4. 8. 16}).
	indirect:: 4. (* write after capture forces use of indirection vector *)
)
) : (
TEST_CONTEXT = ()
)
public class SuperSimulationTests = TestContext () (
foo = (
	^'super'
)
fooWithArg: n = (
	^'super'
)
) : (
)
class TestBase = TestContext () (
assertList: actual equals: expected = (
	1 to: actual size do: 
		[:index | assert: (actual at: index) equals: (expected at: index)].
)
assertSet: actual equals: expected = (
	| missing extra missingString extraString |
	missing:: Set new.
	missing addAll: expected.
	actual do: [:element | missing remove: element ifAbsent: []].
	extra:: Set new.
	extra addAll: actual.
	expected do: [:element | extra remove: element ifAbsent: []].
	(missing isEmpty and: [extra isEmpty]) ifTrue: [^self].	
	
	missingString: ''.
	missing do: [:element | missingString: missingString, ' ', element printString].
	extraString: ''.
	extra do: [:element | extraString: extraString, ' ', element printString].
	
	failWithMessage: 'Missing:', missingString, ' Extra:', extraString.
)
in: collection findMirrorNamed: name = (
	collection do: [:mirror | mirror name = name ifTrue: [^mirror]].
	^nil
)
) : (
)
baz = (
	^'enclosing'
)
foo = (
	^'enclosing'
)
fooWithArg: n = (
	^'enclosing'
)
) : (
)

Newspeak3
'Newspeak'
class NewspeakCompilation usingPlatform: p asts: asts = ((* Facilities common to each of the Newspeak compilers, such as scopes and the scope builder. A common Rewriter should eventually be located here as well.

It is intended that module definitions for each compilation target will be mixed-in to this module definition, and so inherit the facilities provided here. Until general mixin application is supported, the target-specific modules must use the same cheat used by BlocklessCombinatorialParsing of declaring a superclass clause matching the factory of the class it will be later mixed-in to.


This module is derived from Newspeak2SqueakCompilation, which is why the pre-2013 copyrights apply.

Copyright 2008 Cadence Design Systems, Inc.
Copyright 2010 Gilad Bracha, Felix Geller and Ryan Macnak
Copyright 2011 Matthias Kleine, Ryan Macnak and Cadence Design Systems
Copyright 2013 Ryan Macnak

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 *)|
	protected Map = p collections Map.
	protected List = p collections List.

	protected AST = asts AST.
	protected ASTTool = asts ASTTool.
	protected BlockAST = asts BlockAST.
	protected CascadedSendAST = asts CascadedSendAST.
	protected CodeBodyAST = asts CodeBodyAST.
	protected MessageAST = asts MessageAST.
	protected MessagePatternAST = asts MessagePatternAST.
	protected MethodAST = asts MethodAST.
	protected NormalSendAST = asts NormalSendAST.
	protected NumberAST = asts NumberAST.
	protected ReturnStatAST = asts ReturnStatAST.
	protected TupleAST = asts TupleAST.
	protected VariableAST = asts VariableAST.
	
	public namer = Namer new.
|) (
class ClassEntry forDeclaration: cd atDepth: d = SymbolTableEntry forAST: cd atDepth: d (|
public enclosingClass <ClassEntry>
|) (
'as yet unclassified'
public isClassBinding ^<Boolean> = (
	^true
)
public name = (
	^ast selector
)
) : (
)
class Compiler = (| protected scopeMap <Map[AST, Scope]> ::= Map new. |) (
class Rewriter = ASTTool ((* This class is intended to become a common rewriter for the Squeak, Dart and JavaScript compilers. It should handle

*self/super/outer/implicitReceiver/ordinary send or local read/write.
*local/non-local return.
*implicit return self
*[] is [nil]
*slot initializers
*simultaneous slots
*setter temp
*inlined messages
*large tuples?

The common rewriter should be sufficient for Dart and JavaScript. Squeak will require a second rewrite phase for closure analysis, which should be simpler than the current implementation because determining which locals need to be indirected or copied down will be easier when the tree already has distinguished sends that are reads/writes to locals.
*)|
	scopeStack <List[Scope]> = List new.
	valueExpected <Boolean> ::= true.
	inClosure <Boolean> ::= false.
|) (
public class BlockLocalReturnAST expression: e = ReturnAST expression: e () (
'as yet unclassified'
public apply: visitor = (
	^visitor blockLocalReturnNode: self
)
) : (
)
public class BooleanAST withValue: b = AST (|
	public value = b.
|) (
'as yet unclassified'
public apply: aTool <ASTTool > ^ <Self> = (
	^aTool boolNode: self
)
public isBoolNode = (
	^true
)
name = (
	^value printString asSymbol
)
public printOn: stream = (
	stream nextPutAll: 'BooleanAST: '.
	value printOn: stream.
)
) : (
)
public class ConditionalAST if: cond is: ifTrue_ then: t else: e = AST (|
	public condition <ExpressionAST> = cond.
	public ifTrue = ifTrue_.
	public then <CodeBodyAST> = t.
	public else <CodeBodyAST> = e.
	public forValue <Boolean>
|assert: [then isCodeBodyNode] message: ''.
	assert: [else isCodeBodyNode] message: ''.
	assert: [then parameters size = 0] message: ''.
	assert: [else parameters size = 0] message: '') (
'testing'
public isExpressionNode ^<Boolean> = (
	^forValue
)
'visiting'
public apply: tool <ASTTool> = (
	^tool conditionalNode: self
)
) : (
'as yet unclassified'
public if: cond <ExpressionAST> is: val <Boolean> then: t <BlockAST> ^<Instance> = (
	^self if: cond is: val then: t else: emptyBody
)
)
class EnclosingObjectAST = AST ((* See mailing list for debate over 'outer Foo' as an expression. *)| 
	public depth <Integer>
|) (
'as yet unclassified'
public isExplicitRcvrNode = (
	^true
)
'testing'
public isExpressionNode ^<Boolean> = (
	^true
)
'visiting'
public apply: tool <ASTTool> = (
	^tool enclosingObjectNode: self
)
) : (
)
public class ImplicitReceiverSendAST = SendAST (|
public depth <Integer> (* Used on targets that don't have implicit receiver lookup at runtime. *)
public binding <ClassEntry | SlotEntry | MethodEntry>
|) (
'as yet unclassified'
public isImplicitReceiverSendNode ^<Boolean> = (
	^true
)
'visiting'
public apply: tool <ASTTool> = (
	^tool implicitReceiverSendNode: self
)
) : (
)
public class LocalReadAST of: var = AST (|
	public variable = var.
|) (
'as yet unclassified'
public apply: visitor = (
	^visitor localReadNode: self
)
public isExpressionNode ^<Boolean> = (
	^true
)
public name = (
	^variable ast name
)
) : (
)
public class LocalWriteAST to: var assign: val = AST (|
	public variable = var.
	public value = val.
|) (
'as yet unclassified'
public apply: visitor = (
	^visitor localWriteNode: self
)
public isExpressionNode ^<Boolean> = (
	^true
)
public name = (
	^variable ast name
)
) : (
)
public class LoopAST = AST ((* This node represents a while loop. The general form of the loop is:

prologue; while (cond = whileTrue) { body}

*)|
	public prologue <CodeBodyAST> ::= emptyBody.
	public condition <CodeBodyAST>
	public isWhileTrue <Boolean>
	public body <CodeBodyAST>
	public forValue <Boolean>
|) (
'as yet unclassified'
public do: n <Integer> timesRepeat: b <BlockAST> = (
	|
	skope <Scope>
	loopVarName <Symbol>
	var <ParameterAST>
	|
	skope:: scopeMap at: b.

	(* introduce counter variable *)
	loopVarName:: '.i' asSymbol.
	var:: (ParameterAST name: loopVarName type: nil)
		start: b start; end: b end.	
	skope
		at: loopVarName
		put: (LocalEntry forDeclaration: var atDepth: 0)
		ifThere: [ halt ].
	assert: [b parameters isEmpty].
	b parameters add: var.

	(* translate n timesRepeat: [blockBody]
	into 1 to: n do: [ :.i | blockBody] *)
	from: (NumberAST new value: 1; start: b start; end: b end) to: n do: b
)
public from: first <AST> to: last <AST> by: step <AST> do: block <BlockAST> = (
	|
	blockScope		<Scope>	
	counterVar		<TemporaryAST>
	counterEntry	
	counter		<TemporaryVariableAST>
	limitNeeded		<Boolean>
	limitName		<Symbol>
	limitVar		<TemporaryAST>
	limitEntry
	limit			<LiteralAST | VariableAST>
	condSel			<Symbol>
	condArg		<MutableList[ExpressionAST]>
	condExpr		<ExpressionAST>
	condBody		<CodeBodyAST>
	condStats		<MutableList[StatementAST]>
	incArg			<MutableList[ExpressionAST]>
	incExpr			<ExpressionAST>
	incStat			<StatementAST>
	|
	(* preliminaries *)
	assert: [ step isNumberNode and: [step value isInteger] ].
	assert: [ block isBlockNode ].
	blockScope:: scopeMap at: block body.

	(* loop counter (= block parameter) *)
	counterVar:: TemporaryAST name: block parameters removeFirst name type: nil.
	counterEntry:: LocalEntry forDeclaration: counterVar atDepth: nil.
	counter:: (LocalReadAST of: counterEntry) start: block start; end: block end.
	
	(* introduce counter limit variable if needed *)
	(limitNeeded:: last isLiteralNode not)
		ifFalse:
			[(* no limit variable needed - use last directly since there's no computation involved *)
			limit:: last]
		ifTrue:
			[limitName:: '.limit' asSymbol.
			 limitVar:: TemporaryAST name: limitName type: nil.
			 limitVar start: block start; end: block end.
			 limitEntry:: LocalEntry forDeclaration: limitVar atDepth: nil.
			 prologue temporaries add: limitVar.
			 blockScope at: limitName put: limitEntry ifThere: [ assert: [false] ].
			 limit:: (LocalReadAST of: limitEntry) start: block start; end: block end].
	
	(* setup loop condition => introduce condition block for whileTrue: loop *)
	condSel:: step value < 0 ifTrue: [ #<= ] ifFalse: [ #>= ].
	condArg:: List new add: counter; yourself.
	condExpr:: OrdinarySendAST to: limit send: (MessageAST new send: condSel with: condArg).
	(* limit <= counter OR limit >= counter *)
	condStats:: List new add: condExpr ; yourself.
	condBody::
		CodeBodyAST new
			parameters: List new;
			temporaries: List new;
			statements: condStats;
			start: block start; end: block end.
	scopeMap at: condBody put: nil.

	(* add counter increment to loop body *)
	incArg:: List new add: counter ; yourself.
	incExpr:: OrdinarySendAST to: step send: (MessageAST new send: #+ with: incArg).
	incExpr start: block start; end: block end.
	(* step + counter *)
	incStat:: LocalWriteAST to: counterEntry assign: incExpr. 
	incStat start: block start; end: block end.
	(* counter := step + counter *)
	block body statements add: incStat.

	(* setup prologue *)
	prologue temporaries add: counterVar.
	prologue statements add: (LocalWriteAST to: counterEntry assign: first).
	(* counter := first *)
	limitNeeded ifTrue: [
		(* initialize limit variable - note that this must be done *after* setting up the counter because of possible side effects *)
		prologue statements add: (LocalWriteAST to: limitEntry assign: last). (* .limit := last *)
	].
	
	(* initialize loop instance variables *)
	condition:: condBody.
	isWhileTrue:: true.
	body:: block body
)
public from: first <AST> to: last <AST> do: block <BlockAST> = (
	from: first to: last by: (NumberAST new value: 1) do: block
)
public repeat: b = (
    assert: [b isCodeBodyNode].
    condition:: b.
    condition statements add: ((BooleanAST withValue: true) start: condition end; end: condition end).
    isWhileTrue:: true.
    body:: emptyBody.
)
public while: v <Boolean> do: b <BlockAST> = (
    assert: [b isCodeBodyNode].
    condition:: b.
    isWhileTrue:: v.
    body:: emptyBody
)
public while: b1  is: v <Boolean> do: b2 = (
    assert: [b1 isCodeBodyNode].
    assert: [b2 isCodeBodyNode].
    condition:: b1.
    isWhileTrue:: v.
    body:: b2.
)
'testing'
public isExpressionNode ^<Boolean> = (
	^forValue
)
'visiting'
public apply: aTool <ASTTool> = (
	^aTool loopNode: self
)
) : (
)
public class MethodLocalReturnAST expression: e = ReturnAST expression: e () (
'as yet unclassified'
public apply: visitor = (
	^visitor methodLocalReturnNode: self
)
) : (
)
public class NilAST = AST () (
'as yet unclassified'
public apply: tool <ASTTool > = (
	^tool nilNode: self
)
public isNilNode = (
	^true
)
public name = (
	^#nil
)
) : (
)
public class NonlocalReturnAST expression: e = ReturnAST expression: e () (
'as yet unclassified'
public apply: visitor = (
	^visitor nonLocalReturnNode: self
)
) : (
)
public class OrdinarySendAST to: rcvr send: msg = SendAST (|
	public receiver = rcvr.
	public message = msg.
|) (
'as yet unclassified'
public apply: aTool <ASTTool> = (
	^aTool ordinarySendNode: self
)
public isNormalSendNode = (
	^true
)
) : (
)
public class OuterSendAST = SendAST (|
public depth <Integer>
public binding <ClassEntry | SlotEntry | MethodEntry>
|) (
'as yet unclassified'
public isOuterSendNode ^<Boolean> = (
	^true
)
'visiting'
public apply: tool <ASTTool> = (
	^tool outerSendNode: self
)
) : (
)
public class ParameterAST name: n type: t = AST (|
	public name = n.
	public type = t.
|) (
'as yet unclassified'
public apply: visitor = (
	^visitor parameterDeclNode: self
)
public isVarDeclNode ^<Boolean> = (
	^true
)
public printOn: stream = (
	stream nextPutAll: 'ParameterAST('; nextPutAll: name; nextPutAll: ')'.
)
) : (
)
class ReceiverAST = AST () (
'as yet unclassified'
public apply: tool = (
	^tool receiverNode: self
)
public isExpressionNode = (
	^true
)
public isReceiverNode ^<Boolean> = (
	^true
)
) : (
)
class ReturnAST expression: e = AST (|
	public expression <AST> = e.
|) (
'as yet unclassified'
public isExpressionNode = (
	^false
)
public isReturnStatNode = (
	^true
)
) : (
)
public class SelfSendAST = SendAST (|
public binding <ClassEntry | SlotEntry | MethodEntry>
|) (
'as yet unclassified'
public isSelfSendNode ^<Boolean> = (
	^true
)
public receiver = (
	^ReceiverAST new
)
'visiting'
public apply: tool <ASTTool> = (
	^tool selfSendNode: self
)
) : (
)
class SendAST = AST (|
	public message <MessageAST>
|) (
'as yet unclassified'
public isExpressionNode = (
	^true
)
public isSendNode = (^true)
) : (
)
public class SuperSendAST = SendAST () (
'as yet unclassified'
public isSuperSendNode = (
	^true
)
'visiting'
public apply: tool <ASTTool> = (
	^tool superSendNode: self
)
) : (
)
public class TemporaryAST name: n type: t = AST (|
	public name = n.
	public type = t.
|) (
'as yet unclassified'
public apply: visitor = (
	^visitor temporaryDeclNode: self
)
public isTemporaryAST = (
	#BOGUS.
	^true
)
public isVarDeclNode ^<Boolean> = (
	^true
)
public printOn: stream = (
	stream nextPutAll: 'TemporaryAST('; nextPutAll: name; nextPutAll: ')'.
)
) : (
)
'as yet unclassified'
applyForEffectTo: node <Node> = (
	| original result |
	original:: valueExpected.
	valueExpected:: false.
	result:: node apply: self.
	valueExpected:: original.
	^result
)
applyForValueTo: node <Node> = (
	| original result |
	original:: valueExpected.
	valueExpected:: true.
	result:: node apply: self.
	valueExpected:: original.
	^result
)
canInlineSeqexps ^<Boolean> = (
	^true (* No on JS and Dart *)
)
depthOfEnclosingClass: name <Symbol> ^<Integer> = (
	| entry <ClassEntry> |
	entry:: currentScope at: #'@currentClass'.
	[entry isNil] whileFalse:
		[entry name = name ifTrue: [
			^entry depth].
		entry:: entry enclosingClass].
	Error signal: 'No enclosing class named "', name, '"'
)
emptyBody = (
	| body |
	#BOGUS. (* Should be able to use immutable collections. *)
	body:: CodeBodyAST new
		parameters: List new;
		temporaries: List new;
		statements: (List new add: NilAST new; yourself).
	scopeMap at: body put: nil.
	^body
)
futureFor: expression <ExpressionAST> ^<ExpressionAST> = (
	(* @here Future computing: [expression] *)
	| 
	scope <Scope>
	block <BlockAST>
	codebody <CodeBodyAST>
	futureExp <ExpressionAST>
	|
	
	scope:: Scope new.
	scope superScope: currentScope.
	
	futureExp:: NormalSendAST new
		receiver: (NormalSendAST new
			receiver: implicitReceiverNode;
			message: (MessageAST new selector: #Future; arguments: {}));
		message: (MessageAST new selector: #computing:; arguments: {
			block:: BlockAST new body: (
				 codebody:: CodeBodyAST new
					parameters: List new;
					temporaries: List new;
					statements: {expression})}).

	scopeMap at: codebody put: scope.
	scopeMap at: block put: scope.
	^futureExp
)
implicitReceiverNode ^<VariableAST> = (
	^VariableAST new name: #'@here'; start: 0; end: 0.
)
inClosureDuring: block = (
	| original |
	original:: inClosure.
	inClosure:: true.
	^block ensure: [inClosure:: original]
)
isImplicitReceiverNode: node <AST> ^<Boolean> = (
	node isVariableNode ifFalse: [^false].
	^node name = #'@here'
)
isInlineableConditional: node <NormalSendAST> ^<Boolean> = (
	canInlineSeqexps ifFalse: [valueExpected ifTrue: [^false]].
	node message isEventual ifTrue: [^false].
	({#ifTrue:. #ifFalse:. #ifTrue:ifFalse:. #ifFalse:ifTrue:} includes: node message selector)
	     ifFalse: [^false].
	node message arguments do: [:arg <AST> | (isRemovableBlock: arg withArgs: 0) ifFalse: [^false]].
	^true
)
isInlineableLoop: node <NormalSendAST> ^<Boolean>= (
	| selector <Symbol>  args |
	canInlineSeqexps ifFalse: [valueExpected ifTrue: [^false]].
	node message isEventual ifTrue: [^false].
	selector:: node message selector.
	args:: node message arguments.
	({#whileTrue. #whileFalse. #whileTrue:. #whileFalse:. #repeat} includes: selector) ifTrue:
		[args do:
			[:each |
			(isRemovableBlock: each withArgs: 0) ifFalse: [^false]].
		^isRemovableBlock: node receiver withArgs: 0].
	
	(selector = #timesRepeat:) ifTrue:[^isRemovableBlock: args last withArgs: 0].
	({#to:do:. #to:by:do:} includes: selector) ifFalse: [^false].
	(isRemovableBlock: args last withArgs: 1) ifFalse: [^false].
	(selector = #to:do:) ifTrue: [^true].
	^args size = 3
)
isOuterNode: node <AST> ^<Boolean> = (
	node isVariableNode ifFalse: [^false].
	^node name = #outer
)
isRemovableBlock: block <BlockAST> withArgs: numArgs <Integer> ^<Boolean> = (
	(* Answers true if block can be removed (inlined) within another block. *)
	block isBlockNode ifFalse: [^false].
	block parameters size = numArgs ifFalse: [^false].
	^true
)
isSelfNode: node <AST> ^<Boolean> = (
	node isVariableNode ifFalse: [^false].
	^node name = #self 
)
isSuperNode: node <AST> ^<Boolean> = (
	node isVariableNode ifFalse: [^false].
	^node name = #super 
)
offsetOfEnclosingObjectForClass: name <Symbol> ^<Integer> = (
	| entry <ClassEntry> |
	entry:: currentScope at: #'@currentClass'.
	[entry isNil] whileFalse:
		[entry name = name ifTrue: [
			| offset = outer Compiler currentDepth - entry depth - 1. |
			assert: [offset >= 0] message: 'Invalid enclosing object index'.
			^offset].
		entry:: entry enclosingClass].
	Error signal: 'No enclosing class named "', name, '"'
)
offsetOfImplicitReceiverTarget: binding <SymbolTableEntry> ^<Integer> = (
	(* Note this calculation differs from the one used by explicit outer sends by a factor of one. This is because an explicit outer send needs the depth of the enclosing object with for a class whose name is a given selector, whereas an implicit receiver send needs the depth of the enclosing object for the class that defined a given selector. *)
	| depth |
	depth:: outer Compiler currentDepth - binding depth.
	assert: [depth >= 0] message: 'Invalid enclosing object index'.
	^depth
)
processEventualSend: node <NormalSendAST> = (
	subclassResponsibility
)
processImplicitReceiverSend: node <NormalSendAST> = (
	| 
	message = node message.
	selector = message selector. 
	binding <SymbolTableEntry>
	|
	
	selector = #self 
		ifTrue: [^ReceiverAST new copyPositionFrom: message].
	selector = #nil 
		ifTrue: [^NilAST new copyPositionFrom: message].
	selector = #false
		ifTrue: [^(BooleanAST withValue: false) copyPositionFrom: message].
	selector = #true
		ifTrue: [^(BooleanAST withValue: true) copyPositionFrom: message].
	
	binding:: currentScope at: selector ifAbsent: [nil].
	
	binding isNil (* Nothing is lexically visible. *) 
		ifTrue: [^processImplicitReceiverSend: message binding: nil].
	
	binding isLocalBinding
		ifTrue: [^processLocalAccess: message of: binding].

	binding isDebugMappedLocalEntry
		ifTrue: [^processMappedVariable: message decl: binding].
	
	assert: [binding isMethodBinding | binding isSlotBinding | binding isClassBinding]
	message: 'Unknown binding type'.
	^processImplicitReceiverSend: message binding: binding
)
processImplicitReceiverSend: msg <MessageAST> binding: binding <ClassEntry | SlotEntry | MethodEntry> = (
	| depth = binding isNil ifTrue: [0] ifFalse: [offsetOfImplicitReceiverTarget: binding]. |
	^(ImplicitReceiverSendAST new
		depth: depth;
		binding: binding;
		message: (msg apply: self))
		copyPositionFrom: msg
)
processInlineableConditional: node <NormalSendAST> = (
	|
	receiver = node receiver apply: self.
	selector = node message selector.
	numArgs = node message arguments size.
	arg1 = numArgs > 0 ifTrue:
		[(rewriteInlinedBlockNode: (node message arguments at: 1) forValue: valueExpected) body].
	arg2 = numArgs > 1 ifTrue:
		[(rewriteInlinedBlockNode: (node message arguments at: 2) forValue: valueExpected) body].
	|
	selector = #ifTrue:
		ifTrue: [^ConditionalAST if: receiver is: true then: arg1].
	selector = #ifFalse:
		ifTrue: [^ConditionalAST if: receiver is: false then: arg1].
	selector = #ifTrue:ifFalse:
		ifTrue: [^ConditionalAST if: receiver is: true then: arg1 else: arg2].
	selector = #ifFalse:ifTrue: 
		ifTrue: [^ConditionalAST if: receiver is: false then: arg1 else: arg2].
	assert: [false] message: 'Unknown conditional selector'
)
processInlineableLoop: node <NormalSendAST> ^<LoopAST> = (
	|
	rcvr = node receiver.
	msg = node message.
	sel = msg selector.
	numArgs = msg arguments size.
	arg1 = numArgs >= 1 ifTrue: [msg arguments at: 1].
	arg2 = numArgs >= 2 ifTrue: [msg arguments at: 2].
	arg3 = numArgs >= 3 ifTrue: [msg arguments at: 3].
	|
	
	sel = #whileTrue ifTrue: [^LoopAST new
		while: true
		do: (rewriteInlinedBlockNode: rcvr forValue: true) body].
	sel = #whileFalse ifTrue: [^LoopAST new
		while: false
		do: (rewriteInlinedBlockNode: rcvr forValue: true) body].
	sel = #whileTrue: ifTrue: [^LoopAST new
		while: (rewriteInlinedBlockNode: rcvr forValue: true) body
		is: true
		do: (rewriteInlinedBlockNode: arg1 forValue: false) body].
	sel = #whileFalse: ifTrue: [^LoopAST new
		while: (rewriteInlinedBlockNode: rcvr forValue: true) body
		is: false
		do: (rewriteInlinedBlockNode: arg1 forValue: false) body].
	
	sel = #repeat ifTrue: [^LoopAST new
		repeat: (rewriteInlinedBlockNode: rcvr forValue: false) body].
	
	sel = #timesRepeat: ifTrue: [^LoopAST new
		do: (rcvr apply: self)
		timesRepeat: (rewriteInlinedBlockNode: arg1 forValue: false)].
	
	sel = #to:do: ifTrue: [^LoopAST new
		from: (rcvr apply: self)
		to: (arg1 apply: self)
		do: (rewriteInlinedBlockNode: arg2 forValue: false)].
	
	sel = #to:by:do: ifTrue: [^LoopAST new
		from: (rcvr apply: self)
		to: (arg1 apply: self)
		by: (arg2 apply: self)
		do: (rewriteInlinedBlockNode: arg3 forValue: false)].
	
	assert: [false] message: 'Unknown loop selector'
)
processLocalAccess: msg <MessageAST> of: decl <SlotEntry> = (
	^msg selector last = $:
		ifTrue: [processLocalWrite: msg to: decl]
		ifFalse: [processLocalRead: msg from: decl]
)
processLocalRead: message <MessageAST> from: declaration <LocalEntry> = (
	assert: [message arguments isEmpty] message: ''.
	assert: [declaration isNil not] message: ''.
	^(LocalReadAST of: declaration)
		start: message start;
		end: message end
)
processLocalWrite: message <MessageAST> to: declaration <LocalEntry> = (
	assert: [message arguments size = 1] message: ''.
	assert: [declaration isTemporaryAST] message: ''.
	^(LocalWriteAST
		to: declaration assign: (applyForValueTo: message arguments first))
		copyPositionFrom: message
)
processOuterExpression: node <NormalSendAST> = (
	^EnclosingObjectAST new
		depth: (offsetOfEnclosingObjectForClass: node message selector);
		start: node receiver start;
		end: node message end
)
processOuterSend: node <NormalSendAST> = (
	(* +1 because we're looking for members of the enclosing class, not the siblings of the enclosing class. *)
	| binding = currentScope
		at: node message selector
		depth: (depthOfEnclosingClass: node receiver message selector) + 1. |
	^OuterSendAST new
		depth: (offsetOfEnclosingObjectForClass: node receiver message selector);
		binding: binding;
		message: (node message apply: self);
		start: node receiver receiver start;
		end: node message end
)
processSelfSend: node <NormalSendAST> = (
	| binding = currentScope at: node message selector depth: outer Compiler currentDepth. |
	^SelfSendAST new
		message: (node message apply: self);
		binding: binding;
		copyPositionFrom: node
)
processSetterSend: node <SetterSendAST> binding: binding ^<AST> = (
	|
	setterTempBinding <LocalEntry>
	setterTempRead
	setterTempWrite
	message <MessageAST> 
	send <NormalSendAST>
	depth
	body <CodeBodyAST>  
	|
	valueExpected
		ifFalse: [^processImplicitReceiverSend: node message binding: binding].
	
	setterTempBinding:: currentScope at: namer setterTemp.
	setterTempBinding used: true.
	
	(* t := exp *)
	setterTempWrite:: LocalWriteAST
		to: setterTempBinding
		assign: (node message arguments first apply: self). 

	(* setter: t *)
	setterTempRead:: LocalReadAST of: setterTempBinding. 
	message:: MessageAST new selector: node message selector; arguments: {setterTempRead}.
	assert: [isImplicitReceiverNode: node receiver] message: 'Setter send receiver should be implicit'.
	depth:: binding isNil ifTrue: [0] ifFalse: [offsetOfImplicitReceiverTarget: binding].
	send:: ImplicitReceiverSendAST new
		depth: depth;
		binding: binding;
		message: message. (* Do not rewrite message twice *)

	(* t:=exp. setter: t. t *)
	body:: CodeBodyAST new 
		parameters: List new;
		temporaries: {};
		statements: {setterTempWrite. send. setterTempRead}.
	scopeMap at: body put: currentScope.
	^body
)
processSuperSend: node <NormalSendAST> = (
	^SuperSendAST new
		message: (node message apply: self);
		copyPositionFrom: node
)
rewriteBlockNode: node <BlockAST> forValue: forValue <Boolean> ^ <BlockAST> = (
(* An empty block evaluates to nil when called. This method performs the necessary transformation if the block is empty; otherwise it recursively rewrites the block body. This rewrite is done on all blocks, regardless of whether they are inlined. *)
	| 
	rewrittenNode <BlockAST> 
      params <Collection[ParameterAST]>  
      bodyScope <Scope> 
	| 
	(* this shouldn't be handled here, but I'm not sure where the block / codebody 
	comes from. *)
	node body start isNumber
		ifFalse: [node body start: node start. node body end: node end].
	
	params:: node parameters collect:
		[:p <VarDeclAST> |
		checkForReservedWord: p name.
		(ParameterAST name: p name type: p type) start: p start; end: p end].
	bodyScope:: scopeMap at: node body.
	params do: [:each | (bodyScope at: each name) ast: each].
	rewrittenNode:: BlockAST new body: 
		(forValue ifTrue: [applyForValueTo: node body] ifFalse: [applyForEffectTo: node body]).
	rewrittenNode start: node start; end: node end.
	rewrittenNode body parameters: params.
	node body statements isEmpty ifTrue:
		[rewrittenNode body statements add: (NilAST new start: node body start; end: node body end)].
	scopeMap at: rewrittenNode put: (scopeMap at: node).
	^rewrittenNode
)
rewriteInlinedBlockNode: node <BlockAST> forValue: forValue <Boolean> ^ <CodeBodyAST> = (
(* An empty block evaluates to nil when called. This method performs the necessary transformation if the block is empty; otherwise it recursively rewrites the block body. This rewrite is done on all blocks, regardless of whether they are inlined. *)
	^rewriteBlockNode: node forValue: forValue
)
'node traversal'
public blockNode: node <BlockAST> = (
	| rewrittenBlock <BlockAST> last <AST> |
	inClosureDuring:
		[rewrittenBlock:: rewriteBlockNode: node forValue: true.
		last:: rewrittenBlock body statements last.
		(last isReturnStatNode or: [last isBlockLocalReturnAST]) ifFalse:
			[(* The last expression in a block is returned by it. *)
			rewrittenBlock body statements removeLast.
			rewrittenBlock body statements add:
				((BlockLocalReturnAST expression: last) copyPositionFrom: last)]].
	^rewrittenBlock
)
public cascadedSendNode: node <CascadedSendAST> = (
	| prevSend msg |
	prevSend:: node previousSend apply: self.
	msg:: node message apply: self.
	^CascadedSendAST new to: prevSend cascade: msg
)
public charNode: node <CharAST> = (
	^node
)
public codeBodyNode: node <CodeBodyAST> = (
	(* Move slot initializers to statements. Simultaneous slots. *)
	
	| bodyScope temporaries setterEntry statements result |
	bodyScope:: pushScopeForNode: node.
	
	temporaries:: List new.
	node temporaries do: 
		[:varDecl <VarDeclAST> | | t |
		checkForReservedWord: varDecl name.
		t:: TemporaryAST name: varDecl name type: varDecl type.
		t copyPositionFrom: varDecl.
		(bodyScope at: t name) ast: t.
		temporaries add: t].

	setterEntry:: LocalEntry forDeclaration: (TemporaryAST name: namer setterTemp type: nil) atDepth: nil.
	bodyScope at: namer setterTemp put: setterEntry.
	bodyScope at: (namer setterTemp, ':') asSymbol put: setterEntry.
	temporaries add: setterEntry ast.
	
	statements:: List new.
	node temporaries do: 
		[:varDecl <VarDeclAST> |
		| initializer |
		initializer:: varDecl initializer.
		nil = initializer ifFalse: 
			[node isSeq ifFalse: 
				[initializer:: futureFor: initializer].
			statements add: (LocalWriteAST
				to: (bodyScope at: varDecl name)
				assign: (self applyForValueTo: initializer))]].

	node statements keysAndValuesDo:
		[:index :statement | 
		| rewritten |
		rewritten:: (index = node statements size and: [valueExpected])
			ifTrue: [applyForValueTo: statement]
			ifFalse: [applyForEffectTo: statement].
		statements add: rewritten].
	
	setterEntry used ifFalse: 
		[bodyScope at: namer setterTemp put: nil.
		bodyScope at: (namer setterTemp, ':') asSymbol put: nil.
		temporaries remove: setterEntry ast].

	popScope.
	result:: CodeBodyAST new
		parameters: node parameters
		temporaries: temporaries
		statements: statements.
	result literalMessages: node literalMessages.
	scopeMap at: result put: bodyScope.
	^result
)
public messageNode: node <MessageAST> ^<MessageAST> = (
    ^MessageAST new
		send: node selector
		with: (node arguments collect: [:arg | applyForValueTo: arg]);
		isEventual: node isEventual;
		start: node start;
		end: node end
)
public messagePatternNode: node <MessagePatternAST> ^<MessagePatternAST> = (
	| params <List[ParameterAST]> patternScope <Scope> |
	checkForReservedWord: node selector.
	params:: node parameters collect:
		[:p <VarDeclAST> | 
		checkForReservedWord: p name.
		(ParameterAST name: p name type: p type)
			start: p start;
			end: p end].
	patternScope:: scopeMap at: node.
	params do: [:p | (patternScope at: p name) ast: p].
	^MessagePatternAST new
		selector: node selector parameters: params;
		start: node start;
		end: node end.
)
public methodNode: node <MethodAST> = (
	(* Need setter temp? Implicit ^self? *)
	| pattern body accessModifier result |
	pattern:: node pattern apply: self.
	(* We add the implicit ^self before rewritting the body to ensure the last non-return statment is rewritten for effect. *)
	(node body statements isEmpty or: [node body statements last isReturnStatNode not])
		ifTrue:	[node body statements add:
					(ReturnStatAST new expression: (VariableAST new name: #self))].
	body:: node body apply: self.
	body parameters: pattern parameters.
	assert: [inClosure not] message: ''.
	result:: MethodAST new
		pattern: pattern
		body: body
		accessModifier: node accessModifier.
	scopeMap at: result put: (scopeMap at: node).
	^result
)
public normalSendNode: node <NormalSendAST> ^<AST> = (
	(node message isEventual)
		ifTrue: [^processEventualSend: node].
	(isImplicitReceiverNode: node receiver)
		ifTrue: [^processImplicitReceiverSend: node].
	(isSelfNode: node receiver)
		ifTrue: [^processSelfSend: node].	
	(isSuperNode: node receiver)
		ifTrue: [^processSuperSend: node].	
	(isOuterNode: node receiver)
		ifTrue: [^processOuterExpression: node].
	(node receiver isSendNode and: [isOuterNode: node receiver receiver])
		ifTrue: [^processOuterSend: node].
	(isInlineableConditional: node)
		ifTrue: [^processInlineableConditional: node].
	(isInlineableLoop: node)
		ifTrue: [^processInlineableLoop: node].
	
	(* And lo, we really have a normal send. *)
	^(OrdinarySendAST
		to: (node receiver apply: self) send: (node message apply: self))
		start: node start; end: node end
)
public numberNode: node <NumberAST> = (
	^node
)
public returnStatNode: node <ReturnStatAST> = (
	^((inClosure ifTrue: [NonlocalReturnAST] ifFalse: [MethodLocalReturnAST])
		expression: (applyForValueTo: node expression))
		copyPositionFrom: node
)
public setterSendNode: node <SetterSendAST> ^<AST> = (
	| 
	message = node message.
	selector = message selector. 
	binding <SymbolTableEntry>
	|
	
	binding:: currentScope at: selector ifAbsent: [nil].
	
	binding isNil (* Nothing is lexically visible. *) 
		ifTrue: [^processSetterSend: node binding: nil].
	
	binding isLocalBinding
		ifTrue: [^processLocalAccess: message of: binding].

	binding isDebugMappedLocalEntry
		ifTrue: [^processMappedVariable: message decl: binding].
	
	^processSetterSend: node binding: binding
)
public stringNode: node <StringAST> = (
	^node
)
public symbolNode: node <SymbolAST> = (
	^node
)
public tupleNode: node <TupleAST> = (
	^TupleAST new elements: (node elements collect: [:e | applyForValueTo: e])
)
public variableNode: aNode <VariableAST> = (
	#BOGUS. (* Duplication with processLocalRead: *)
	assert: [aNode start isNumber] message: ''.
	aNode name = #self ifTrue:
		[^ReceiverAST new copyPositionFrom: aNode].
	aNode name = #nil ifTrue:
		[^NilAST new copyPositionFrom: aNode].
	aNode name = #true ifTrue:
		[^(BooleanAST withValue: true) copyPositionFrom: aNode].
	aNode name = #false ifTrue:
		[^(BooleanAST withValue: false) copyPositionFrom: aNode].		
	(* recognize inst vars for accessor methods? handle temps etc. *)
	assert: [(aNode name = #super) not] message: '"super" is not a valid expression'.
	assert: [(aNode name = #outer) not] message: '"outer" is not a valid expression'.
	halt.
	^aNode
)
'scopes'
currentScope ^<Scope> = (
	^scopeStack last
)
public popScope ^<Scope> = (
	^scopeStack removeLast
)
public pushScope: scope <Scope> = (
	^scopeStack addLast: scope
)
pushScopeForNode: node <AST> = (
	^pushScope: (scopeMap at: node)
)
) : (
)
class ScopeBuilder nestedIn: initialScope <Scope> atLevel: initialDepth <Integer> = ASTTool ((* The scope builder is a visitor on the AST. It computes a tree of scopes that shadows the AST itself. More precisely, it computes a mapping from ASTs to their scopes. This allows us to get to the appropriate scope for an abstract syntax node without polluting the AST with extraneous data like scopes.

We could associate each node in the AST with the scope in which it is found, but this would be overkill. Instead, only nodes that actually introduce new scopes (such as class sides, message patterns, code bodies and blocks) actually get mapped in this manner. The intent is that later phases of compilation will visit the tree and look up the scopes at the points where they are introduced.

The builder starts at a given node, in the context of some mixin, described by a mirror. This is because, in an incremental environment, we may not have the complete AST for a module, but instead be asked to process a part of that module, such as a nested class, slot definition or method. The surrounding scope can be computed from the mirror representing the immediately enclosing mixin.

Then we traverse the tree, creating and populating new scopes as needed. We maintain a stack of scopes (scopeStack) that initially contains only the surrounding scope. Scopes get pushed on to the stack when we encounter a node that introduces a scope, and popped when we finish with that node. The scopes are chained to their super scopes (the scope below them on the stack).

A possible optimization is to avoid a traversal of an entire side of a class.
One can process only a side without its subtrees (i.e., methods and nested classes). These can be visited later, as long as we ensure that the processing of the subtree begins with a proper super scope on top of the scope stack. *)| 
scopeStack <List[Scope]> = List new.
currentDepth <Integer> ::= initialDepth. (* The lexical nesting level of the class declaration currently being visited; top-level classes are level 0. *)
|pushScope: initialScope) (
'as yet unclassified'
public buildScopeFor: mm <MixinMirror> ^<Scope> = (
	assert: [mm isKindOfMixinMirror] message: ''.
	^incrementalScopeFor: mm.
)
incrementalScopeFor: mm <MixinMirror> ^<Scope> = (
	|
	enclosingMixin
	enclosingScope <Scope>
	scope <Scope>
	currentClass <ClassEntry>
	depth
	|
	enclosingMixin:: mm declaration enclosingClass.
	nil = enclosingMixin 
		ifTrue: [enclosingScope:: Scope new]
		ifFalse: [enclosingScope:: incrementalScopeFor: enclosingMixin instanceSide].
	scope:: Scope new superScope: enclosingScope.
	depth:: scope depth.
	currentClass:: ClassEntry 
		forDeclaration: (MessagePatternAST new selector: mm declaration name)
		atDepth: depth.
	currentClass enclosingClass: (scope at: #'@currentClass' ifAbsent: [nil]).
	scope at: #'@currentClass' put: currentClass.
	depth:: depth + 1.
	mm slots do: [:s <SlotMirror> | 
		| se = SlotEntry
			forDeclaration: (MessagePatternAST new selector: s name; accessModifier: s accessModifier)
			atDepth: depth. |
		scope at: s name put: se. (* getter *)
		scope at: (namer initializerSelectorForSlot: s) put: se.
		s isMutable ifTrue: [scope at: (namer setterSelectorFor: s) put: se. (* setter *)]].
	mm methods do: [:m <MethodMirror> | 
		| me = MethodEntry
			forDeclaration: (MessagePatternAST new selector: m name; accessModifier: m accessModifier)
			atDepth: depth. |
		scope at: m name put: me].
	mm nestedClasses do: [:c <ClassDeclarationMirror> | 
		| ce = ClassEntry
			forDeclaration: (MessagePatternAST new selector: c name; accessModifier: c accessModifier)
			atDepth: depth. |
		ce enclosingClass: currentClass.
		scope at: c name put: ce].
	^scope
)
'node traversal'
public blockNode: aNode <BlockAST> = (
	| parameterScope <Scope> |
	parameterScope:: Scope new.
	(* establish parameter scope *)
	aNode parameters do:
		[:parameter <VarDeclAST> | 
			parameterScope
			at: parameter name
			put: (LocalEntry
				forDeclaration: parameter
				atDepth: currentDepth)].
	nestScope: parameterScope.
	
	(* visit body *)
	aNode body apply: self.
	scopeMap at: aNode put: (scopeMap at: aNode body).
	
	popScope (* pop the parameter scope, ps *)
)
public cascadedSendNode: aNode <CascadedSendAST> = (

	(* generic traversal code *)
	(* visit receiver and messages *)
	aNode previousSend apply: self.
	aNode message apply: self.
)
public charNode: aNode <CharAST> = (
	(* leaf, do nothing *)
)
public classHeaderNode: aNode = (

	aNode constructor apply: self.
	aNode slots do: [:s | s initializer ifNotNil: [:i | i apply: self]].
	aNode initExprs do: [:e | e apply: self].
)
public classNode: aNode <ClassDeclarationAST> = (
	| thisClass <ClassEntry> vs <Scope> |
	
	thisClass:: ClassEntry
		forDeclaration: (MessagePatternAST new selector: aNode name; accessModifier: aNode accessModifier)
		atDepth: currentDepth.
	thisClass enclosingClass: (currentScope at: #'@currentClass' ifAbsent: [nil]).
	
	currentScope at: aNode name put: thisClass.
		
	vs:: Scope new. (* establish instance side scope *)
	currentDepth:: currentDepth + 1.
	aNode header slots do: [:v <SlotDeclAST> | 
		| se = SlotEntry
			forDeclaration: (MessagePatternAST new selector: v name; accessModifier: v accessModifier)
			atDepth: currentDepth. |
		vs at: v name put: se. (* getter *)
		vs at: (namer initializerSelectorForSlot: v) put: se.
		v isMutable ifTrue: [vs at: (namer setterSelectorFor: v) put: se]. (* setter *)].
		
	self nestScope: vs.
		currentScope at: #'@currentClass' put: thisClass.
  		aNode instanceSide apply: self.
	popScope.
	self nestScope: Scope new. (* establish class side scope *)
		currentScope at: #'@currentClass' put: thisClass.
  		aNode classSide apply: self.
	popScope.
	currentDepth:: currentDepth - 1.
)
public codeBodyNode: aNode <CodeBodyAST> = (
	| ts <Scope> |
	(* establish local slot scope *)

	ts:: Scope new.
	aNode temporaries do:[:t <SlotDefAST> | 
		|svd|
		svd:: LocalEntry forDeclaration: t slotDecl atDepth: currentDepth.
		ts at: t name put: svd. (* getter *)
		ts at: (namer initializerSelectorForSlot: t) put: svd. (* setter *)
		t isMutable ifTrue: [ts at: (setterSelectorFor: t) put: svd. (* setter *)]].

	nestScope: ts.
	scopeMap at: aNode put: ts.
	(* visit statements *)
	aNode temporaries do: [:t | t initializer isNil ifFalse: [t initializer apply: self]].
	aNode statements do: [:statement | statement apply: self].
	popScope.
)
public keywordPatternNode: n = (
	(* leaf, do nothing *)
)
public literalPatternNode: n = (
	(* leaf, do nothing *)
)
public messageNode: aNode <MessageAST> = (
	(* generic traversal code *)
	(* visit arguments *)
	aNode arguments do: [:arg <ExpressionAST> | arg apply: self]
)
public messagePatternNode: aNode <MessagePatternAST> = (

	| parameterScope <Scope> |
	parameterScope:: Scope new.
	(* establish parameter scope *)
	aNode parameters do:
		[:parameter <VarDeclAST> | 
		parameterScope
		at: parameter name
		put: (LocalEntry
			forDeclaration: parameter
			atDepth: currentDepth)].
	
	nestScope: parameterScope.
	scopeMap at: aNode put: parameterScope.
	(* the pattern scope, ps, must be popped by the caller *)
	(* establish type parameter scope - skip for now *)
)
public methodNode: aNode <MethodAST> = (

	(* register method in current scope *)
	currentScope
		at: aNode pattern selector
		put: (MethodEntry
			forDeclaration: (MessagePatternAST new selector: aNode selector; accessModifier: aNode accessModifier)
			atDepth: currentDepth).

	(* visit pattern *)
	aNode pattern apply: self.
	
	(* visit body *)
	aNode body apply: self.
	scopeMap at: aNode put: (scopeMap at: aNode body).

	popScope (* Pop pattern scope *)
)
public mixinApplication: node <MixinApplicationAST> = (

	node mixinExpr apply: self.
	node superclassExpr apply: self
)
public mixinApplicationClass: aNode <MixinApplicationClassAST> = (
	| thisClass <ClassEntry> vs <Scope> |
	#BOGUS yourself. (* WIP *)
	thisClass:: ClassEntry
		forDeclaration: (MessagePatternAST new selector: aNode name)
		atDepth: currentDepth.
	thisClass enclosingClass: (currentScope at: #'@currentClass' ifAbsent: [nil]).
	
	currentScope at: aNode name put: thisClass.
	scopeMap at: aNode put: currentScope.
)
public mixinClassNode: aNode = (
	(* leaf, do nothing *)
)
public normalSendNode: aNode <NormalSendAST> = (
	(* generic traversal code *)
	(* visit recvr and msg *)
	aNode receiver apply: self.
	aNode message apply: self.
)
public numberNode: aNode <NumberAST> = (
	(* leaf, do nothing *)
)
public returnStatNode: aNode <ReturnStatAST> = (
	(* generic traversal code *)
	(* visit expression *)
	aNode expression apply: self
)
public setterSendNode: aNode <SetterSendAST> = (
	(* visit recvr and msg *)
	aNode receiver apply: self.
	aNode message apply: self.
)
public sideNode: aNode <SideAST> = (

	scopeMap at: aNode put: currentScope.

	(* visit methods *)
	aNode categories do:
		[:c <CategoryAST> | 
		c methods do:
			[:m <MethodAST> | m apply: self]].
	
	(* visit nested classes *)
	aNode nestedClasses do:
		[:nc <ClassDeclarationAST> | nc apply: self].
)
public stringNode: aNode <StringAST> = (
	(* leaf, do nothing *)
)
public symbolNode: aNode <SymbolAST> = (
	(* leaf, do nothing *)
)
public tupleNode: aNode <TupleAST> = (
	(* visit elements *)
	aNode elements do: [:e <ExpressionAST> | e apply: self]
)
public varDeclNode: aNode <VarDeclAST> = (
	(* Do nothing. It could arguably add aNode's data to current scope - but in practice, the context knows better how to do this. *)
)
public variableNode: aNode <VariableAST> = (
	assert: [aNode name = #'@here' or: [isPseudoVariableNode: aNode]]
	message: 'Unexpected variable name'.
)
public wildcardPatternNode: node = (
	(* leaf, do nothing *)
)
'private'
currentScope ^ <Scope> = (
	^scopeStack last
)
isPseudoVariableNode: aNode <VariableAST> ^<Boolean> = (
	^aNode name = #self
		or: [aNode name = #super
		or: [aNode name = #outer]]
)
nestScope: s <Scope> = (
	(* Hook up a new lexically nested scope, and push onto the scope stack *)
	s superScope: currentScope.
	pushScope: s
)
popScope ^<Scope> = (
	^scopeStack removeLast
)
pushScope: s <Scope> = (
	scopeStack addLast: s
)
) : (
'as yet unclassified'
public new ^<Instance> = (
	^self nestedIn: Scope new atLevel: 0
)
)
'as yet unclassified'
public Scope = (
	^outer NewspeakCompilation Scope
)
checkForReservedWord: selector = (
	(namer isReservedWord: selector) ifTrue:
		[Error signal: '"', selector, '" is a reserved word'].
)
public compileClassHeader: source <String>
 within: enclosingDeclIR <IntermediateClassDeclaration> = (
	subclassResponsibility
)
setterSelectorFor: slot <SlotDefAST | InstanceVariableMirror> ^<Symbol> = (
	subclassResponsibility
)
'compiler entry'
public compileClassSource: source <ReadStream> within: enclosing <MixinMirror> ^<IntermediateClassDeclaration> = (
	subclassResponsibility
)
public compileExpressionSource: source <ReadStream> inContext: aContext <MethodContext> inMixin: enclosing <MixinMirror> allowBlackMarket: allowBlackMarket <Boolean> ^<IntermediateMethod> = (
	subclassResponsibility
)
public compileMethodSource: source <String> within: enclosing <MixinMirror> ^<IntermediateMethod> = (
	subclassResponsibility
)
) : (
)
class LocalEntry forDeclaration: decl <VarDeclAST> atDepth: d <Integer> = SymbolTableEntry forAST: decl atDepth: d ((* Semantic info for a parameter or temporary. *)|
public offset <Integer>
public remote <Boolean> ::= false.
public remoteVector <LocalEntry>

public used ::= false.
|) (
'as yet unclassified'
public isLocalBinding ^<Boolean> = (
	^true
)
public isTemporaryAST ^<Boolean> = (
	^ast isTemporaryAST
)
public name = (
	^ast name
)
) : (
)
class MethodEntry forDeclaration: decl atDepth: d = SymbolTableEntry forAST: decl atDepth: d (|
|) (
'as yet unclassified'
public isMethodBinding ^<Boolean> = (
	^true
)
) : (
)
class Namer = () (
'as yet unclassified'
public fullyQualifiedNameToSimple: name = (
	| index = name lastIndexOf: $`. |
	index = 0 ifTrue: [^name].
	^(name copyFrom: 1 + index to: name size) asSymbol
)
public fullyQualifySimpleName: sn with: fqp = (
	^(fqp, syntheticNameSeparator, sn) asSymbol
)
public initializerSelectorForSlot: slot <SlotDefAST | InstanceVariableMirror> ^<Symbol> = (
	^('init`', slot name, ':') asSymbol
)
public isReservedWord: selector = (
	^{#self. #super. #outer. #true. #false. #nil} includes: selector
)
public mixinNameOfClassNamed: className = (
	(* |
	simpleNames
	rawNames
	result
	|
	rawNames:: className subStrings: syntheticNameSeparator. 
	rawNames size =1 ifTrue:[^className].
	simpleNames:: rawNames select: [:n | n initialIntegerOrNil isNil].
	assert: [simpleNames size >= 2] message: ''.
	^(simpleNames fold: [:sn1 :sn2 | sn1, syntheticNameSeparator, sn2]) asSymbol. *)
	^className
)
public mixinSlotNameFor: nestedName = (
	| mixinName |
	mixinName:: self mixinNameOfClassNamed: nestedName.
	^(mixinName, syntheticNameSeparator, 'slot') asSymbol
)
public setterSelectorFor: slot <SlotDefAST | InstanceVariableMirror> ^<Symbol> = (
	slot isMutable ifFalse: [self warnObsolete].
	^((slot isMutable ifTrue: [ '' ] ifFalse: [ 'setOnce`' ]), slot name, ':') asSymbol.
)
public setterTemp = (
	^#'@setterTemp'
)
public syntheticNameSeparator = (
	^'`'
)
) : (
)
public class Scope = ((* A generic scope facility. *)|
public superScope <Scope>
bindings <Map[Symbol, SymbolTableEntry]> = Map new.
|) (
'access'
public at: key <Symbol> ^<SymbolTableEntry> = (
	(* Answers the value associated with aKey in this or one the super scopes or fails if aKey is absent. *)
	^self at: key ifAbsent: [Error signal: 'Key ', key, ' not found!']
)
public at: key depth: d = (
	depth = d ifFalse: [
		nil = superScope
			ifTrue: [^nil]
			ifFalse: [^superScope at: key depth: d]].
	^bindings at: key ifAbsent: [nil]
)
public at: key <Symbol> ifAbsent: blk <[X def]> ^<SymbolTableEntry | X> = (
	(* Answers the value associated with aKey in this or one of the superScopes or the value of aBlock if aKey is absent. *)
	(* Optimization note: This is written using [nil] blocks to avoid passing non-clean blocks dynamically down the scope structure. *)

	| val <T> |
	val:: self bindings at: key ifAbsent: [nil].
	nil = val ifFalse: [^val].
	nil = self superScope ifTrue: [^blk value].
	val:: self superScope at: key ifAbsent: [nil].
	nil = val ifFalse: [^val].
	^blk value
)
public at: key <Symbol> put: value <SymbolTableEntry> = (
	^self bindings at: key put: value
)
public at: key <Symbol> put: value <SymbolTableEntry> ifThere: aBlock <[X def]> ^<SymbolTableEntry | X>= (

	(* Associates aValue with aKey and answers aValue if aKey
    was absent. Otherwise answers the value of aBlock. *)
	| wasAbsent ::= false. |
	bindings at: key ifAbsent: [bindings at: key put: value. wasAbsent:: true].
	^wasAbsent
		ifTrue: [value]
		ifFalse: [aBlock value]
)
public depth ^<Integer> = (
	superScope isNil ifTrue: [^0].
	^superScope depth + 1.
)
'as yet unclassified'
public printOn: stm = (
	stm nextPutAll: 'Scope('.
	bindings keys
		do: [:key | stm nextPutAll: key]
		separatedBy: [ stm nextPutAll: ', '].
	stm nextPutAll: ') in '.
	superScope printOn: stm.
)
public setSuperScope: sc = (
	superScope isNil
		ifTrue: [superScope: sc]
		ifFalse: [superScope setSuperScope: sc]
)
) : (
)
class SlotEntry forDeclaration: decl <VarDeclAST> atDepth: d <Integer> = SymbolTableEntry forAST: decl atDepth: d () (
'as yet unclassified'
public isSlotBinding ^<Boolean> = (
	^true
)
public name = (
	^ast name
)
) : (
)
class SymbolTableEntry forAST: tree atDepth: d = ((* An entry in a scope. *)|
public ast <AST> ::= tree. (* Should investigate mutators of this slot and make immutable if possible. *)
public depth <Integer> = d.
|) (
'testing'
public isMessagePatternNode ^<Boolean> = (
	^self ast isMessagePatternNode
)
public isVarDeclNode ^<Boolean> = (
	^self ast isVarDeclNode
)
) : (
)
) : (
)

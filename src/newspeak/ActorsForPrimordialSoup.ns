Newspeak3
'Actors'
class ActorsForPrimordialSoup usingPlatform: p = (|
private WeakMap = p kernel WeakMap.
private List = p collections List.
private Map = p collections Map.
private Message = p kernel Message.

public Promise = PromiseFactories new.

public theScheduler
private internalRefs <WeakMap[Ref, InternalRef]> = WeakMap new.
private currentActor ::= InternalActor named: 'Initial actor'.
private pendingActors ::= List new.
private timerHeap = TimerHeap new.
private portMap = Map new.

private cachedPlatform = p.
|) (
public class Actor named: debugName <String> = (|
private (* N.B. Do not leak to subinstances. *) internalActor = InternalActor named: debugName.
|) (
public interrupt = (
	unimplemented
)
public onError: onError <[:E]> = (
	unimplemented.
)
public seed: value <Value> ^<FarReference[Value]> = (
	(* Creating a far reference to a PassByCopy is questionable. It may be that this should be seed: receiver perform: selector with: argument. *)
	(isValueObject: value) ifFalse: [Error signal: 'Cannot seed an actor with a non-Value.'].
	^createFarReferenceTo: value in: internalActor for: currentActor.
)
public terminate = (
	unimplemented
)
) : (
)
protected class EventualSendReactor selector: s arguments: a resolver: r = (
(* An eventual-send to a promise.

Note that all slots contain objects that belong to the actor which performed the eventual send. *)|
protected selector <Symbol> = s.
protected arguments <Array> = a.
protected resolver <InternalResolver> = r.
|) (
public reactBroken: error = (
	(* Broken promise contagion. *)	
	(* Should this be immediate? *)
	(* resolver internalBreak: error. ? *)
	currentActor enqueueMessage:
		(PendingDelivery
			receiver: resolver
			selector: #internalResolve:
			arguments: {InternalBrokenRef problem: error}
			resolver: nil)
)
public reactMoreResolved: internalRef = (
	resolver internalResolve: (asInternalRef: (internalRef eventualSend: selector arguments: arguments)).
)
public reactResolved: value = (
	resolver internalResolve: 
		(asInternalRef: (theScheduler
			eventualSendTo: value
			selector: selector
			arguments: arguments))
)
) : (
)
class InternalActor named: n = (|
	protected name <String> = n.
	protected head <PendingDelivery>
	protected tail <PendingDelivery>
|) (
public drainWork = (
	currentActor:: self.
	[nil = head] whileFalse: 
		[ | message = head. |
		head: message next.
		message deliver].
	tail: nil.
)
public enqueueMessage: actorMessage = (
	nil = head 
		ifTrue:
			[head:: tail:: actorMessage]
		ifFalse:
			[tail next: actorMessage.
			 tail: actorMessage].

	pendingActors add: self.
)
) : (
)
class InternalBrokenRef problem: p = InternalRef (|
protected problem = p.
|) (
public addReactor: reactor = (
	reactor reactBroken: problem.
)
public checkCycle ^<Boolean> = (
	^false
)
public eventualSend: selector <Symbol> arguments: arguments <Array> ^<Ref> = (
	^self externalRef (* I.e., broken with same problem. Should this wait for the next turn? *)
)
public immediateSend: message <Message> ^<Object> = (
	^Error signal: 'Cannot immediate-send to a broken ref: ', message selector
)
public printOn: stream = (
	stream nextPutAll: 'InternalBrokenRef: '.
	problem printOn: stream.
)
public refPrintOn: stream = (
	stream nextPutAll: '<broken ref: '.
	problem printOn: stream.
	stream nextPutAll: '>'.
)
public shorten ^<InternalRef> = (
	^self
)
public whenFulfilled: onValue whenBroken: onError ^<Ref> = (
	| localPromise = InternalLocalPromise new. |
	currentActor enqueueMessage:
		(PendingDelivery
			receiver: onError
			selector: #cull:
			arguments: {problem}
			resolver: localPromise).
	^localPromise externalRef
)
public wrapFor: targetActor = (
	#BOGUS.
	^(InternalBrokenRef problem: problem) externalRef
)
) : (
)
class InternalFarReference target: t targetsActor: ta = InternalRef (|
protected target = t.
protected targetsActor = ta.
|) (
public addReactor: reactor = (
	reactor reactResolved: externalRef
)
public checkCycle ^<Boolean> = (
	^false
)
public eventualSend: selector <Symbol> arguments: arguments <Array> ^<Ref> = (
	| resolverInTarget remotePromise redirector |
	resolverInTarget:: InternalLocalPromise new.
	targetsActor enqueueMessage:
		(PendingDelivery
			receiver: target
			selector: selector
			arguments: (wrapArguments: arguments from: currentActor to: targetsActor)
			resolver: resolverInTarget).
			
	remotePromise:: InternalRemotePromise 
		target: resolverInTarget 
		targetsActor: targetsActor.
			
	redirector:: RedirectReactor
		from: targetsActor
		to: currentActor
		resolver: remotePromise.
	targetsActor enqueueMessage:
		(PendingDelivery
			receiver: resolverInTarget
			selector: #addReactor:
			arguments: {redirector}
			resolver: nil).
			
	^remotePromise externalRef
)
public immediateSend: message <Message> ^<Object> = (
	^Error signal: 'Cannot immediate-send to an eventual ref: ', message selector
)
public printOn: stream = (
	stream nextPutAll: 'InternalFarRef: '.
	target printOn: stream.
)
public refPrintOn: stream = (
	stream nextPutAll: '<far ref: '.
	target printOn: stream.
	stream nextPutAll: '>'.
)
public shorten ^<InternalRef> = (
	^self
)
public whenFulfilled: onValue whenBroken: onError ^<Ref> = (
	| localPromise = InternalLocalPromise new. |
	currentActor enqueueMessage:
		(PendingDelivery
			receiver: onValue
			selector: #cull:
			arguments: {externalRef}
			resolver: localPromise).
	^localPromise externalRef
)
public wrapFor: targetActor = (
	targetsActor = targetActor ifTrue: [^target].
	^(InternalFarReference target: target targetsActor: targetsActor) externalRef.
)
) : (
)
class InternalLocalPromise = InternalRef (|
protected state ::= #unresolved. (* resolving. resolved *)
protected resolution <InternalRef>
protected reactors
|) (
public addReactor: reactor = (
	state = #unresolved ifTrue:
		[nil = reactors ifTrue: [reactors:: List new].
		reactors add: reactor.
		^self].
	state = #resolved ifTrue:
		[^resolution addReactor: reactor].
	halt.
)
public checkCycle ^<Boolean> = (
	state = #resolving ifTrue: [^true].
	state = #unresolved ifTrue: [^false].
	state = #resolved ifTrue: [^resolution checkCycle].
	halt.
)
public eventualSend: selector <Symbol> arguments: arguments <Array> ^<Ref> = (
	| localPromise |
	state = #resolved ifTrue: [^resolution eventualSend: selector arguments: arguments].
	localPromise:: InternalLocalPromise new.
	self addReactor: (EventualSendReactor selector: selector arguments: arguments resolver: localPromise).
	^localPromise externalRef
)
public immediateSend: message <Message> ^<Object> = (
	state = #resolved ifTrue: [^resolution immediateSend: message].
	^Error signal: 'Cannot immediate-send to an eventual ref: ', message selector
)
public internalResolve: internalRef <InternalRef> = (
	state = #unresolved ifFalse: [^Error signal: 'Already resolved'].
	internalRef isInternalRef ifFalse: [halt].

	state:: #resolving.
	internalRef checkCycle 
		ifTrue: [resolution:: InternalBrokenRef problem: (Error new messageText: 'Cyclic resolution')]
		ifFalse: [resolution:: internalRef].
	state:: #resolved.
	
	nil = reactors ifFalse:
		[reactors do: [:reactor | resolution addReactor: reactor].
		reactors:: nil].
)
public printOn: stream = (
	stream nextPutAll: 'InternalLocalPromise: '.
	state printOn: stream.
)
public refPrintOn: stream = (
	state = #resolved
		ifTrue: [resolution refPrintOn: stream]
		ifFalse: [stream nextPutAll: '<local promise>'].
)
public shorten ^<InternalRef> = (
	state = #unresolved ifTrue: [^self].
	state = #resolved ifTrue: [^resolution].
	halt.
)
public whenFulfilled: onValue whenBroken: onError ^<Ref> = (
	| localPromise |
	state = #resolved ifTrue: [^resolution whenFulfilled: onValue whenBroken: onError].
	localPromise:: InternalLocalPromise new.
	self addReactor: (WhenReactor onValue: onValue onError: onError resolver: localPromise).
	^localPromise externalRef
)
public wrapFor: targetActor = (
	state = #resolved ifTrue: [^resolution wrapFor: targetActor].
	
	^(InternalRemotePromise target: self targetsActor: currentActor) externalRef
)
) : (
)
class InternalNearRef wrapping: t = InternalRef (|
protected target = t.
|) (
public addReactor: reactor = (
	reactor reactResolved: target.
)
public checkCycle ^<Boolean> = (
	^false
)
public eventualSend: selector <Symbol> arguments: arguments <Array> ^<Ref> = (
	| localPromise = InternalLocalPromise new. |
	currentActor enqueueMessage:
		(PendingDelivery
			receiver: target
			selector: selector
			arguments: arguments
			resolver: localPromise).
	^localPromise externalRef
)
public immediateSend: message <Message> ^<Object> = (
	^message sendTo: target
)
public printOn: stream = (
	stream nextPutAll: 'InternalNearRef: '.
	target printOn: stream.
)
public refPrintOn: stream = (
	stream nextPutAll: '<near ref: '.
	target printOn: stream.
	stream nextPutAll: '>'.
)
public shorten ^<InternalRef> = (
	^self
)
public whenFulfilled: onValue whenBroken: onError ^<Ref> = (
	| localPromise = InternalLocalPromise new. |
	currentActor enqueueMessage:
		(PendingDelivery
			receiver: onValue
			selector: #cull:
			arguments: {target}
			resolver: localPromise).
	^localPromise externalRef
)
public wrapFor: targetActor = (
	(isValueObject: target) ifTrue: [^target].
	^createFarReferenceTo: target in: currentActor for: targetActor
)
) : (
)
class InternalRef = (|
|) (
public checkCycle ^<Boolean> = (
	subclassResponsibility
)
public eventualSend: selector <Symbol> arguments: arguments <Array> ^<Ref> = (
	subclassResponsibility
)
public externalRef = (
	^Ref wrapping: self
)
public immediateSend: message <Message> ^<Object> = (
	subclassResponsibility
)
public isInternalRef ^<Boolean> = (
	^true
)
public refPrintOn: stream = (
	subclassResponsibility
)
public shorten ^<InternalRef> = (
	subclassResponsibility
)
public whenFulfilled: onValue whenBroken: onError ^<Ref> = (
	subclassResponsibility
)
public wrapFor: targetActor = (
	subclassResponsibility
)
) : (
)
class InternalRemotePromise target: t targetsActor: ta = InternalRef (|
target <InternalLocalPromise> = t.
targetsActor <InternalActor> = ta.
state ::= #unresolved.
resolution <InternalRef>
|) (
public addReactor: reactor = (
	state = #resolved ifTrue: [^resolution addReactor: reactor].
	state = #unresolved ifTrue: [^reactor reactMoreResolved: self].
	stop5.
)
public checkCycle ^<Boolean> = (
	state = #resolving ifTrue: [^true].
	state = #unresolved ifTrue: [^false].
	state = #resolved ifTrue: [^resolution checkCycle].
	halt.
)
public eventualSend: selector <Symbol> arguments: arguments <Array> ^<Ref> = (
	| resolverInTarget remotePromise redirector |
	resolverInTarget:: InternalLocalPromise new.
	targetsActor enqueueMessage:
		(PendingDelivery
			receiver: target
			selector: #eventualSend:arguments:
			arguments: {selector. (wrapArguments: arguments from: currentActor to: targetsActor)}
			resolver: resolverInTarget).
			
	remotePromise:: InternalRemotePromise 
		target: resolverInTarget 
		targetsActor: targetsActor.
			
	redirector:: RedirectReactor
		from: targetsActor
		to: currentActor
		resolver: remotePromise.
	targetsActor enqueueMessage:
		(PendingDelivery
			receiver: resolverInTarget
			selector: #addReactor:
			arguments: {redirector}
			resolver: nil).
			
	^remotePromise externalRef
)
public immediateSend: message <Message> ^<Object> = (
	state = #resolved ifTrue: [^resolution immediateSend: message].
	^Error signal: 'Cannot immediate-send to an eventual ref: ', message selector
)
public internalResolve: internalRef <InternalRef> = (
	state = #unresolved ifFalse: [^Error signal: 'Already resolved'].
	internalRef isInternalRef ifFalse: [halt].

	state:: #resolving.
	internalRef checkCycle 
		ifTrue: [resolution:: InternalBrokenRef problem: (Error new messageText: 'Cyclic resolution')]
		ifFalse: [resolution:: internalRef].
	state:: #resolved.
)
public printOn: stream = (
	stream nextPutAll: 'InternalRemotePromise: '.
	state printOn: stream.
)
public redirectFrom: sourceActor to: destinationActor resolving: resolver = (
	| redirector |
	destinationActor = targetsActor ifTrue:
		[targetsActor enqueueMessage:
			(PendingDelivery
				receiver: resolver
				selector: #internalResolve:
				arguments: {target}
				resolver: nil).
		^self].
	
	redirector:: RedirectReactor
		from: targetsActor
		to: destinationActor
		resolver: resolver.
	targetsActor enqueueMessage:
		(PendingDelivery
			receiver: target
			selector: #addReactor:
			arguments: {redirector}
			resolver: nil).
)
public refPrintOn: stream = (
	state = #resolved
		ifTrue: [resolution refPrintOn: stream]
		ifFalse: [stream nextPutAll: '<remote promise>'].
)
public shorten ^<InternalRef> = (
	state = #unresolved ifTrue: [^self].
	state = #resolved ifTrue: [^resolution].
	halt.
)
public whenFulfilled: onValue whenBroken: onError ^<Ref> = (
	| localPromise redirector |
	state = #resolved ifTrue: [^resolution whenFulfilled: onValue whenBroken: onError].

	localPromise:: InternalLocalPromise new.
	redirector:: RedirectReactor
		from: targetsActor
		to: currentActor
		resolver: localPromise.
	targetsActor enqueueMessage:
		(PendingDelivery
			receiver: target
			selector: #addReactor:
			arguments: {redirector}
			resolver: nil).
	^localPromise whenFulfilled: onValue whenBroken: onError.
)
public wrapFor: targetActor = (
	state = #resolved ifTrue: [^resolution wrapFor: targetActor].

	targetActor = targetsActor ifTrue: [^target externalRef].
	
	^(InternalRemotePromise target: target targetsActor: targetsActor) externalRef
)
) : (
)
class InternalTimer = (|
callback
actor
public dueTime
public id
millisecondDuration
repeating
public externalTimer
|) (
public < other = (
	dueTime = other dueTime ifTrue: [^id < other id].
	^dueTime < other dueTime
)
public after: duration do: callbackX = (
	callback:: callbackX.
	actor:: currentActor.
	dueTime:: currentMonotonicMillis + duration + 1.
	millisecondDuration:: duration.
	repeating:: false.
	timerHeap insert: self.
)
public cancel = (
	callback:: nil.
)
public every: duration do: callbackX = (
	callback:: callbackX.
	actor:: currentActor.
	dueTime:: currentMonotonicMillis + duration + 1.
	millisecondDuration:: duration.
	repeating:: true.
	timerHeap insert: self.
)
public fire = (
	nil = callback ifTrue: [^self]. (* Cancelled. *)
	repeating
		ifTrue: 
			[dueTime:: currentMonotonicMillis + millisecondDuration.
			timerHeap insert: self.
			[callback value: externalTimer] 
				on: Exception 
				do: [:ex | (* unhandledException: ex *)]]
		ifFalse:
			[ | savedCallback = callback. |
			callback:: nil.
			[savedCallback value]
				on: Exception
				do: [:ex | (* unhandledException: ex *)]].
)
public isActive = (
	^(nil = callback) not
)
) : (
)
protected class PendingDelivery receiver: r selector: s arguments: a resolver: y = (
(* A message in an actor's event queue. Every turn starts by sending #deliverIn:.

Note that all slots contain objects that belong to the actor in which the message is queued, even the resolver. *)|
protected receiver <Object> = r.
protected selector <Symbol> = s.
protected arguments <Array> = a.
protected resolver <InternalResolver> = y.

public next
|) (
public deliver = (
	| resolution type msg |
	
	msg:: Message selector: selector arguments: arguments.
	
	[resolution:: msg sendTo: receiver.
	 type:: #value] 
		on: Exception
		do: [:error |
			nil = resolver ifTrue: 
				['Exception in turn without resolver' out. 
				 error pass].
			resolution:: error.
			type:: #error].

	nil = resolver ifTrue: [^self].
	
	resolver internalResolve: (#value = type 
		ifTrue: [asInternalRef: resolution] 
		ifFalse: [InternalBrokenRef problem: resolution]).
)
) : (
)
public class Port fromId: i = (|
public id = i.
public handler
|) (
public close = (
	close: id.
	portMap removeKey: id.
)
private close: portId = (
	(* :literalmessage: primitive: 136 *)
	halt
)
public deliver: bytes = (
	| deserializer message |
	deserializer:: cachedPlatform victoryFuel Deserializer new.
	message:: deserializer deserialize: bytes.
	handler value: message
)
private rawSpawn: bytes = (
	(* :literalmessage: primitive: 137 *)
	halt.
)
public send: message = (
	| serializer bytes |
	serializer:: cachedPlatform victoryFuel Serializer new.
	bytes:: serializer serialize: message.
	to: id send: bytes.
)
public spawn: message = (
	| serializer bytes |
	serializer:: cachedPlatform victoryFuel Serializer new.
	bytes:: serializer serialize: message.
	rawSpawn: bytes.
)
private to: port send: data = (
	(* :literalmessage: primitive: 138 *)
	halt
)
) : (
private createPort = (
	(* :literalmessage: primitive: 135 *)
	halt.
)
public new = (
	| 
	id = createPort.
	port = self fromId: id.
	|
	portMap at: id put: port.
	^port
)
)
class PromiseFactories = () (
public all: refs <List[Promise[V, E]]> ^<Promise[List[V], E]> = (
	(* Answers a promise that resolves with all the resolutions of refs, or the first problem. *)
)
public broken: problem <E> ^<Promise[nil, E]> = (
	^Resolver new break: problem; promise
)
public fulfilled: resolution <V> ^<Promise[V, nil]> = (
	^Resolver new fulfill: resolution; promise	
)
public timeout: ref <Promise[V, E]> after: milliseconds <Integer> ^<Promise[V, E | TimeoutError]> = (
	(* Answers a promise that resolves with the resolution of ref, or a TimeoutError if refs is not resolved within milliseconds. *)
	#BOGUS. (* Should have proper duration type. *)
)
public when: ref <Promise[V, E]> fulfilled: onValue <[:V | V2 def]> ^<Promise[V2, E]>  = (
	(* Subscribe to notification of a reference being fulfilled. If ref is fulfilled, onValue will run in some turn after the turn that resolves ref, and the returned promise with be resolved with the result of onValue. If ref is broken, the returned promise with be broken with the same error. *)
	^(asInternalRef: ref) whenFulfilled: onValue whenBroken: [:e | e signal] (* Should we make this the behavior of a nil catch-clause instead? *)
)
public when: ref <Promise[V, E]> fulfilled: onValue <[:V | V2 def]> broken: onError <[:E | E2 def]> ^<Promise[V2, E2]>  = (
	(* Subscribe to notification of a reference being fulfilled or broken. onValue or onError respectively will run in some turn after the turn that resolves ref., and the returned promise with be resolved with the result of the callback. *)
	^(asInternalRef: ref) whenFulfilled: onValue whenBroken: onError
)
public when: ref <Promise> partitioned: onPartition <[:Promise | R def] | [R def]> ^<Promise[R, nil]>  = (
	(* Subscribe to notification of a reference breaking due to partition. *)
)
) : (
)
protected class RedirectReactor from: s to: d resolver: r = (
(* A bridge between InternalResolvers in different actors. *)|
protected sourceActor <Actor> = s.
protected destinationActor <Actor> = d.
protected resolver <InternalResolver>  = r.
|) (
public reactBroken: r = (
	| msg |
	currentActor = sourceActor ifFalse: [halt].
	msg:: PendingDelivery
		receiver: resolver
		selector: #internalResolve:
		arguments: {InternalBrokenRef problem: r}
		resolver: nil.
	destinationActor enqueueMessage: msg.
)
public reactMoreResolved: internalRef = (
	internalRef redirectFrom: sourceActor to: destinationActor resolving: resolver.
)
public reactResolved: r = (
	| msg |
	currentActor = sourceActor ifFalse: [halt].
	msg:: PendingDelivery
		receiver: resolver
		selector: #internalResolve:
		arguments: {asInternalRef: (wrapArgument: r from: sourceActor to: destinationActor)}
		resolver: nil.
	destinationActor enqueueMessage: msg.
)
) : (
)
class Ref wrapping: ref = (|
protected internalRef = ref.
|internalRefs at: self put: ref) (
protected doesNotUnderstand: message <Message> = (
	(* For the debugger/inspector. Questionable. *)
	(* Should probably override public method of Object as well. *)
	0 = message arguments size ifTrue: [(message selector startsWith: 'is') ifTrue: [^false]].
	^internalRef immediateSend: message
)
public isPromise = (
	^true
)
public printOn: stream = (
	(* BOGUS - debugging *)
	internalRef refPrintOn: stream.
)
protected yourself = (
	^super yourself
)
) : (
)
public class Resolver = (
(*A Resolver represents the authority to resolve a Promise and is the control facet of the promise's eventual resolution.*)|
	private (* N.B. We must not leak access to an InternalResolver via subobjects. *) internalResolver = InternalLocalPromise new.
	public promise <Promise[V, E]> = internalResolver externalRef.
|) (
public break: error <E> = (
	internalResolver internalResolve: (InternalBrokenRef problem: error).
)
public fulfill: value <V> = (
	internalResolver internalResolve: (asInternalRef: value).
)
public isResolver ^<Boolean> = (
	^true
)
) : (
)
class Scheduler application: a platform: p = (|
	application ::= a.
	platform ::= p.
|) (
private dispatchHandle: handle status: status signals: signals count: count = (
	halt.
)
private dispatchMessage: message port: port = (
	nil = message ifFalse:
		[nil = port 
			ifTrue: [enqueueStartupMessage: message] 
			ifFalse: [enqueuePortMessage: message port: port]].
	finish: drainEventLoop.
)
public drainEventLoop = (
	timerHeap drainWork.
	[pendingActors isEmpty] whileFalse:
		[pendingActors removeLast drainWork].
	^timerHeap nextDueTime
)
private enqueuePortMessage: bytes port: portId = (
	| port |
	port:: portMap at: portId ifAbsent: [^self].
	
	currentActor enqueueMessage:
		(PendingDelivery
			receiver: port
			selector: #deliver:
			arguments: {bytes}
			resolver: nil).
)
private enqueueStartupMessage: argvOrBytes = (
	| args |
	argvOrBytes isByteArray
		ifTrue: 
			[ | deserializer |
			deserializer:: cachedPlatform victoryFuel Deserializer new.
			args:: deserializer deserialize: argvOrBytes]
		ifFalse:
			[args:: argvOrBytes].
	
	currentActor enqueueMessage:
		(PendingDelivery
			receiver: application
			selector: #main:args:
			arguments: {platform. args}
			resolver: nil).
			
	application:: nil.
	platform:: nil.
)
public eventualSendTo: receiver selector: selector arguments: arguments = (
	(* Sent from the compilation of an eventual send. *)
	^(asInternalRef: receiver) eventualSend: selector arguments: arguments
)
private exit: code = (
	(* :literalmessage: primitive: 107 *)
	halt
)
private finish: wakeup = (
	(* :literalmessage: primitive: 139 *)
	halt.
)
public unhandledException: exception from: signalActivationSender = (
	| activation |
	'Unhandled exception: ' out.
	exception out.
	activation:: signalActivationSender.
	[nil = activation] whileFalse: 
		[activation out. 
		 activation:: activation sender].
	exit: -1.
)
) : (
)
public class Timer wrapping: i = (|
	private internalTimer = i.
|) (
public cancel = (
	internalTimer cancel.
)
public isActive ^<Boolean> = (
	^internalTimer isActive
)
public isTimer ^<Boolean> = (
	^true
)
) : (
public after: duration do: callback <[]> ^<Timer> = (
	^Timer wrapping: (InternalTimer new after: duration do: callback)
)
public every: duration do: callback <[:Timer]> ^<Timer> = (
	| internal external |
	internal:: InternalTimer new every: duration do: callback.
	external:: Timer wrapping: internal.
	internal externalTimer: external.
	^external
)
)
class TimerHeap = (|
private table ::= Array new: 32.
private	used ::= 0.
private nextId ::= 0.
|) (
downHeapFrom: startParentIndex = (
	| parentIndex ::= startParentIndex. parent leftChildIndex rightChildIndex |
	parent:: table at: parentIndex.	
	[leftChildIndex:: parentIndex << 1.
	 rightChildIndex:: parentIndex << 1 + 1.
	 leftChildIndex <= used] whileTrue:
		[ | leftChild rightChild |
		leftChild:: table at: leftChildIndex.
		rightChildIndex <= used 
			ifTrue:
				[rightChild:: table at: rightChildIndex.
				 leftChild < rightChild
					ifTrue:
						[parent < leftChild ifTrue: [^self].
						 table at: leftChildIndex put: parent.
						 table at: parentIndex put: leftChild.
						 parentIndex:: leftChildIndex]
					ifFalse:
						[parent < rightChild ifTrue: [^self].
						 table at: rightChildIndex put: parent.
						 table at: parentIndex put: rightChild.
						 parentIndex:: rightChildIndex]]
			ifFalse:
				[(* Only has left child. *)
				 parent < leftChild ifTrue: [^self].
				 table at: leftChildIndex put: parent.
				 table at: parentIndex put: leftChild.
				 parentIndex:: leftChildIndex]].
)
public drainWork = (
	| now = currentMonotonicMillis. |
	[used > 0] whileTrue:
		[peek dueTime > now ifTrue: [^self].
		 pop fire].
)
public insert: timer = (
	used >= table size ifTrue: 
		[ | newSize = table size << 1. |
		 ('Growing timer heap to ', newSize printString) out.
		 table:: table copyWithSize: newSize].
	used = 0 ifTrue: [nextId:: 0]. (* Reset id space when possible. *)

	used:: 1 + used.
	table at: used put: timer.
	
	timer id: nextId.
	nextId:: 1 + nextId. (* Heap isn't a stable sort. Use a tie breaker to ensure timers fire in the order they are scheduled if their due times are the same. *)

	upheapFrom: used.
)
public nextDueTime = (
	| next = peek. |
	nil = next ifTrue: [^0].
	^1000000 * next dueTime
)
public peek = (
	0 = used ifTrue: [^nil].
	^table at: 1
)
public pop = (
	| min = table at: 1. |
	table at: 1 put: (table at: used).
	table at: used put: nil.
	used:: used - 1.
	downHeapFrom: 1.
	min id: nil.
	^min
)
upheapFrom: startChildIndex = (
	| childIndex ::= startChildIndex. |
	[childIndex = 1] whileFalse: 
		[ | parentIndex child parent |
		parentIndex:: childIndex >> 1.
		child:: table at: childIndex.
		parent:: table at: parentIndex.
		parent < child ifTrue: [^self].
		table at: childIndex put: parent.
		table at: parentIndex put: child.
		childIndex:: parentIndex].
)
) : (
)
protected class WhenReactor onValue: v onError: e resolver: r = (
(* A when-catch for a promise.

Note that all slots contain objects that belong to the actor which sent #whenResolved:. *)|
	protected onValue <[:V] | []> = v.
	protected onError <[:E] | []> = e.
	protected resolver <InternalResolver> = r.
|) (
public reactBroken: value = (
	currentActor enqueueMessage:
		(PendingDelivery 
			receiver: onError
			selector: #cull:
			arguments: {value}
			resolver: resolver).
)
public reactMoreResolved: internalRef = (
	resolver internalResolve: (asInternalRef: (internalRef whenFulfilled: onValue whenBroken: onError)).
)
public reactResolved: value = (
	currentActor enqueueMessage:
		(PendingDelivery 
			receiver: onValue
			selector: #cull:
			arguments: {value}
			resolver: resolver).
)
) : (
)
private asInternalRef: externalRefOrUnboxedNearRef = (
	^(isRef: externalRefOrUnboxedNearRef)
		ifTrue: [internalRefs at: externalRefOrUnboxedNearRef]
		ifFalse: [InternalNearRef wrapping: externalRefOrUnboxedNearRef]
)
public buildSchedulerForApplication: app platform: platform = (
	^theScheduler:: Scheduler application: app platform: platform
)
private classOf: object = (
	(* :literalmessage: primitive: 85 *)
	halt.
)
private createFarReferenceTo: target in: targetActor for: sourceActor = (
	^(InternalFarReference target: target targetsActor: targetActor) externalRef.
)
private currentMonotonicNanos = (
	(* :literalmessage: primitive: 100 *)
	halt.
)
private currentMonotonicMillis = (
	^currentMonotonicNanos quo: 1000000
)
private isRef: object <Object> ^<Boolean> = (
	^Ref = (classOf: object)
)
private isValueObject: object <Object> ^<Boolean> = (
	nil = object ifTrue: [^true].
	true = object ifTrue: [^true].
	false = object ifTrue: [^true].
	object isString ifTrue: [^true].
	object isNumber ifTrue: [^true].
	object isBehavior ifTrue: [^true (* ^isValueObject: object enclosingClass *)].
	Promise = object ifTrue: [^true].
	^false
)
private wrapArgument: argument from: sourceActor to: targetActor = (
	(* [argument] lives in [sourceActor], answer the corresponding proxy that lives in [targetActor] *)

	sourceActor = targetActor ifTrue: [halt. (* We can't tell which side a near reference belongs to here, so we must have decided this earlier. *) ].

	^(asInternalRef: argument) wrapFor: targetActor
)
private wrapArguments: arguments from: sourceActor to: targetActor = (
	^arguments collect: [:argument | wrapArgument: argument from: sourceActor to: targetActor].
)
) : (
)

Newspeak3
'NS2PrimordialSoup'
class MirrorsForPrimordialSoup usingPlatform: platform internalKernel: ik namespace: ns = (|
(* TODO: These need to be real identity collections for schema changes. *)
private IdentityMap = platform collections IdentityMap.

private List = platform collections List.
private WeakMap = platform kernel WeakMap.
private StringBuilder = platform kernel StringBuilder.
private InstanceMixin = ik InstanceMixin.
private ClassMixin = ik ClassMixin.
private Metaclass = ik Metaclass.

private Activation = ik Activation.
private Closure = ik Closure.
private Message = ik Message.
private ByteString = ik ByteString.

private reflectees = WeakMap new.

private cachedPlatform = platform.
private internalKernel = ik.
private namespace = ns.
private parsingX
private intermediatesX
private compilerX
|) (
public class ActivationMirror reflecting: activation = (
(* :bogus: This constructor should not be public. *)| private reflectee <Activation> = activation. |reflectees at: self put: activation) (
public closure ^<ObjectMirror> = (
	| rawClosure = reflectee closure. |
	nil = rawClosure ifTrue: [^nil].
	^ObjectMirror reflecting: rawClosure
)
public evaluate: expression <String> ^<ThreadMirror> = (
	halt.
)
public locals ^<List[LocalSlotMirror]> = (
	halt.
)
public message ^<MessageMirror> = (
	(* If this activation is from an MNU, should this answer the original message or #doesNotUnderstand: ? *)
	| 
	numArgs = reflectee method numArgs. 
	arguments = Array new: numArgs.
	|
	1 to: numArgs do: [:i | arguments at: i put: (ObjectMirror reflecting: (reflectee tempAt: i))].
	^MessageMirror
		selector: reflectee method selector
		arguments: arguments	
)
public method ^<MethorMirror> = (
	^MethodMirror reflecting: reflectee method
)
public receiver ^<ObjectMirror> = (
	^ObjectMirror reflecting: reflectee receiver
)
public restart ^<ThreadMirror> = (
	halt.
)
public return: result <ObjectMirror> ^<ThreadMirror> = (
	halt.
)
public sender ^<ActivationMirror> = (
	| rawSender = reflectee sender. |
	nil = rawSender ifTrue: [^nil].
	rawSender method primitive = 142 ifTrue: [^nil (* Hide simulation root. *)].
	^ActivationMirror reflecting: rawSender
)
public stepInto ^<ThreadMirror> = (
	halt.
)
public stepIntoBlock ^<ThreadMirror> = (
	halt.
)
public stepOver ^<ThreadMirror> = (
	halt.
)
) : (
public invokeSuspended: closure = (
	| simulator thread |
	simulator:: Simulator new.
	simulator activateClosure: closure arguments: {}.
	
	thread:: Thread new.
	thread state: #suspended.
	thread suspendedActivation: simulator activation.
	
	^ThreadMirror reflecting: thread
)
)
class AtomicInstaller = (|
private updateMixinsAndClasses <IdentityMap[OldObject,NewObject]>
private updateInstances <IdentityMap[OldObject,NewObject]>
private existingClasses <IdentityMap[HierarchyDepth,Set[Class]]>
private newExistingMixins <Map[IntermediateClassDeclaration,InstanceMixin]>
|) (
allInstVarNamesOf: cls = (
	nil = cls ifTrue: [^{}].
	^(allInstVarNamesOf: (superclassOf: cls)) , ((mixinOf: cls) _slots collect: [:slotDesc | slotDesc at: 1])
)
private cleanup = (
	updateMixinsAndClasses: nil.
	updateInstances: nil.
	existingClasses: nil.
	newExistingMixins: nil.
)
private depthFor: klassArg <Class> ^<Integer> = (
	| klass depth |
	depth: 0.
	klass: klassArg.
	[nil = klass] whileFalse: 
		[klass:: superclassOf: klass. 
		depth: depth + 1].
	^depth
)
in: collection lastIndexOf: element = (
	collection size to: 1 by: -1 do: [:index | (collection at: index) = element ifTrue: [^index]].
	^0
)
public install: classDecls <List[IntermediateClassDeclaration]> = (
	
	| results |
	setup.
	results:: classDecls collect: [:classDecl | processClassDeclaration: classDecl].
	processExistingClasses.
	installAll.
	newExistingMixins keysAndValuesDo:
		[:classDecl :mixin | classDecl existingMixin: mixin]. 
	
	cleanup.

	^results (* <List[InstanceMixin]> *)
)
private installAll = (
	| updateCount oldObjects newObjects index |
	updateCount:: updateMixinsAndClasses size + updateInstances size.
	oldObjects:: Array new: updateCount.
	newObjects:: Array new: updateCount.
	index: 1.
	updateInstances keysAndValuesDo: 
		[:old :new | 
		oldObjects at: index put: old.
		newObjects at: index put: new.
		index: index + 1].
	(* Put updated mixins and classes last, so A -> C follows B -> C (see class comment). *)
	updateMixinsAndClasses keysAndValuesDo: 
		[:old :new | 
		oldObjects at: index put: old.
		newObjects at: index put: (updateInstances at: old ifAbsent: [new]). (* Follow B to avoid B -> C, A -> B. *)
		index: index + 1].
	updateCount = 0 ifTrue: [^self].
	elementsOf: oldObjects forwardIdentityToElementsOf: newObjects.
)
private layoutHasChangedBetween: oldClass <Behavior> and: newClass <Behavior> ^<Boolean> = (
	| oldCls newCls oldMixin newMixin oldSlots newSlots |
	oldCls:: oldClass.
	newCls:: newClass.
	[nil = oldCls] whileFalse:
		[oldMixin:: mixinOf: oldCls.
		 newMixin:: mixinOf: newCls.
		 oldMixin = newMixin ifFalse:
			[oldSlots:: oldMixin _slots.
			 newSlots:: newMixin _slots.
			 oldSlots size = newSlots size ifFalse: [^true].
			 1 to: oldSlots size do: 
				[:index | ((oldSlots at: index) at: 1) = ((newSlots at: index) at: 1) ifFalse: [^true]]].
		 oldCls:: superclassOf: oldCls.
		 newCls:: superclassOf: newCls].
	^false
)
private methodDictionaryFor: mixin <AbstractMixin> from: imixin <IntermediateMixin> ^<MethodDictionary> = (
	| cmethods |
	cmethods:: imixin assembleMethods collect:
		[:imethod <IntermediateMethod> | 
		imethod methodMixin: mixin.
		imethod compiledMethod].
	
	1 to: cmethods size do: [:i |
		i + 1 to: cmethods size do: [:j |
			(cmethods at: i) selector = (cmethods at: j) selector ifTrue: 
				['---conflicting methods' out.
				cmethods do: [:cmethod | cmethod selector out].
				conflictingMethods]]].
	
	^cmethods asArray
)
private noteUpdateOf: existingMixin <InstanceMixin | nil> to: newMixin <InstanceMixin> = (
	| applications <WeakArray> |
	nil = existingMixin ifTrue: [^self].
	
	updateMixinsAndClasses at: existingMixin put: newMixin.
	updateMixinsAndClasses at: existingMixin _classMixin put: newMixin _classMixin.
	
	applications:: existingMixin _applications.
	nil = applications ifFalse: 
		[applications do: [:application <Class> | sortClass: application]].
)
private processClassDeclaration: classDecl <IntermediateClassDeclaration> ^<InstanceMixin> = (
	
	|
	mixin <Mixin>
	classMixin <ClassMixin>
	existingMixin <Mixin>
	nested
	|

	mixin:: InstanceMixin new.
	classMixin:: ClassMixin new.
	
	mixin _headerSource: classDecl headerSource.
	mixin _accessModifier: classDecl accessModifier.
	mixin _primaryFactorySelector: classDecl factoryName.
	assert: [classDecl factoryName isNil not] message: 'Missing factory name'.
	mixin _name: classDecl simpleName.
	mixin _classMixin: classMixin.
	mixin _methods: (methodDictionaryFor: mixin from: classDecl instanceSide).
	mixin _slots: (classDecl instanceSide assembleSlots collect:
		[:s <IntermediateSlotDeclaration> | {s simpleName. s isMutable. s accessModifier}]) asArray.
	
	classMixin _instanceMixin: mixin.
	classMixin _methods: (methodDictionaryFor: classMixin from: classDecl classSide).
	
	existingMixin:: classDecl existingMixin.
	noteUpdateOf: existingMixin to: mixin.
	
	nil = existingMixin 
		ifTrue:
		[newExistingMixins at: classDecl put: mixin]
		ifFalse:
		[(* If this is the top-most thing changed in this installation and not a top level class, the enclosingMixin won't otherwise be set and would incorrectly end up nil. *)
		mixin _enclosingMixin: existingMixin _enclosingMixin.
		mixin _classMixin _enclosingMixin: existingMixin _enclosingMixin].
	
	nested:: classDecl instanceSide nestedClasses collect:
		[:nestedClassDecl <IntermediateClassDeclaration> |
		| nestedMixin <InstanceMixin> |
		nestedMixin:: processClassDeclaration: nestedClassDecl.
		nestedMixin _enclosingMixin: mixin.
		nestedMixin _classMixin _enclosingMixin: mixin.
		nestedMixin].
	mixin _nestedMixins: nested asArray.
	^mixin
)
private processExistingClass: oldClass <Class> = (
	
	| oldSuperclass newSuperclass oldMixin newMixin oldEnclosingObject newClass |
	oldSuperclass:: superclassOf: oldClass.
	newSuperclass:: updateMixinsAndClasses at: oldSuperclass ifAbsent: [oldSuperclass].

	oldMixin:: mixinOf: oldClass.
	newMixin:: updateMixinsAndClasses at: oldMixin ifAbsent: [oldMixin].
	
	oldEnclosingObject:: enclosingObjectOf: oldClass.

	newClass:: newMixin 
		apply: newSuperclass 
		withName: newMixin _name
		enclosingObject: oldEnclosingObject.
	
	updateMixinsAndClasses at: oldClass put: newClass.
	updateMixinsAndClasses at: (classOf: oldClass) put: (classOf: newClass).
)
private processExistingClasses = (
	| maxDepth ::= 0. |
	(* Process superclasses before subclasses. Create all new classes before remapping any instances. Remap instances in any order. *)
	existingClasses keysAndValuesDo: 
		[:inheritanceDepth :classes | 
		inheritanceDepth > maxDepth ifTrue: 
			[maxDepth:: inheritanceDepth]].

	0 to: maxDepth do: 
		[:inheritanceDepth |
		(existingClasses at: inheritanceDepth ifAbsent: [{}]) do:
			[:oldClass <Class> | processExistingClass: oldClass]].

	existingClasses keysAndValuesDo:
		[:inheritanceDepth :classes | 
		classes do:
			[:oldClass <Class> | processInstancesOf: oldClass]].
)
private processInstancesOf: oldClass <Class> = (
	| 
	newClass <Class> = updateMixinsAndClasses at: oldClass.
	oldSlotNames <Array[Symbol]>
	newSlotCount <Integer>
	remapIndices <Array[Integer]>
	|
	(layoutHasChangedBetween: oldClass and: newClass) ifFalse: [^self].
	
	(* Heuristic: choose the latter slot if a slot name is duplicated to favor overriding slots. *)
	oldSlotNames:: allInstVarNamesOf: oldClass.
	remapIndices:: (allInstVarNamesOf: newClass) collect:
		[:newSlotName | in: oldSlotNames lastIndexOf: newSlotName].
	newSlotCount:: remapIndices size.

	(* 'remapping with ' out.
	(((allInstVarNamesOf: oldClass) inject: '' into: [:a :b | a, ' ', b])
	, ' -> ',
	((allInstVarNamesOf: newClass) inject: '' into: [:a :b | a, ' ', b])) out.
	1 to: remapIndices size do: [:newIndex | 
		(newIndex printString, '<-', (remapIndices at: newIndex) printString) out]. *)

	(allInstancesOf: oldClass) do: 
		[:oldInstance |
		(* Avoid A -> D (see class comment). *)
		(updateMixinsAndClasses includesKey: oldInstance) ifFalse:
			[ | newInstance = allocate: newClass. |
			(* Copy state from oldInstance to newInstance. *)
			1 to: newSlotCount do: [:newIndex |
				| oldIndex value |
				oldIndex:: remapIndices at: newIndex.
				0 = oldIndex ifFalse: [
					value:: slotOf: oldInstance at: oldIndex.
					slotOf: newInstance at: newIndex put: value]]. 

			updateInstances at: oldInstance put: newInstance]].
)
private setup = (
	updateMixinsAndClasses:: IdentityMap new.
	updateInstances:: IdentityMap new.
	existingClasses:: IdentityMap new.
	newExistingMixins:: IdentityMap new. (* Regular Map okay here. *)
)
private sortClass: app <Class> = (
	| classes depth subclasses |
	nil = app ifTrue: [^self]. (* InstanceMixin>>applications and Class>>subclasses are weak. *)
	
	depth:: depthFor: app.
	classes:: existingClasses at: depth ifAbsentPut: [List new].
	classes add: app.
	
	subclasses:: subclassesOf: app.
	nil = subclasses ifFalse: 
		[subclasses do: [:subclass | sortClass: subclass]].
)
) : (
)
public class ClassDeclarationBuilder fromIntermediate: ir = (|
private intermediate <IntermediateClassDeclaration> = ir.
public header <ClassHeaderBuilder> = ClassHeaderBuilder fromIntermediate: ir.
|) (
public accessModifier ^<Symbol> = (
	^intermediate accessModifier
)
private checkForHeaderConflicts: newIntermediate <IntermediateClassDeclaration> = (
	
	newIntermediate instanceSide slots do:
		[:slot <IntermediateSlotDeclaration> | 
		intermediate instanceSide
			checkNameConflictsForSlot: slot name
			mutable: slot isMutable].
		
	intermediate classSide checkNameConflictsForFactory: newIntermediate factoryName.
)
public classSide ^<MixinBuilder> = (
	| ir builder |
	ir:: intermediate classSide.
	builder:: ir builder.
	nil = builder ifTrue:
		[builder:: MixinBuilder fromIntermediate: ir.
		 ir builder: builder].
	^builder
)
public enclosingClass ^<ClassDeclarationBuilder> = (
	| enclosingIR enclosingNested enclosingBuilder |
	enclosingIR:: intermediate enclosingClass.
	nil = enclosingIR ifFalse: 
		[^enclosingIR declaration builder].
	nil = intermediate existingMixin ifTrue: 
		[intermediate isTopLevel ifFalse: [halt]. ^nil].
	nil = intermediate existingMixin _enclosingMixin ifTrue: 
		[intermediate isTopLevel ifFalse: [halt]. ^nil].
	
	enclosingIR:: buildIntermediateFor: intermediate existingMixin _enclosingMixin within: nil.
	
	(* Patch up link *)
	intermediate enclosingClass: enclosingIR instanceSide.
	
	(* Patch down link and accessor. *)
	enclosingNested:: enclosingIR instanceSide nestedClasses.
	1 to: enclosingNested size do: [:i |
		(enclosingNested at: i) simpleName = intermediate simpleName ifTrue:
			[intermediate accessor: (enclosingNested at: i) accessor.
			 enclosingNested at: i put: intermediate]].
	
	enclosingBuilder:: ClassDeclarationBuilder fromIntermediate: enclosingIR.
	enclosingIR builder: enclosingBuilder.
	^enclosingBuilder
)
public headerFromSource: newHeader <String> = (
	| prefix newIR |

	(* only top-level classes can specify categories *)
	prefix:: intermediate isTopLevel
		ifTrue: [ 'Newspeak3 ''category'' ' ]
		ifFalse: [ ' ' ].

	self enclosingClass. (* For side effect. *)
	newIR:: compiler
		compileClassHeader: (prefix, newHeader)
		within: intermediate enclosingClass.

	checkForHeaderConflicts: newIR.
	assert: [intermediate simpleName = newIR simpleName] message: ''.

	intermediate headerSource: newIR headerSource.
	intermediate factoryName: newIR factoryName.
	intermediate comment: newIR comment.
	intermediate accessor: newIR accessor.
	intermediate factory: newIR factory.
	intermediate initializers: newIR initializers.
	intermediate instanceSide slots: newIR instanceSide slots.
)
public install ^<ClassDeclarationMirror> = (
	| installer outermost |
	installer:: AtomicInstaller new.
	outermost:: intermediate.
	[nil = outermost enclosingClass] whileFalse: 
		[outermost:: outermost enclosingClass declaration]. 
	installer install: {outermost}.
	nil = intermediate existingMixin ifTrue: [halt].
	^ClassDeclarationMirror reflecting: intermediate existingMixin
)
public instanceSide ^<MixinBuilder> = (
	| ir builder |
	ir:: intermediate instanceSide.
	builder:: ir builder.
	nil = builder ifTrue:
		[builder:: MixinBuilder fromIntermediate: ir.
		 ir builder: builder].
	^builder
)
public name = (
	^intermediate simpleName
)
public source ^<String> = (
	| sb = StringBuilder new. |
	to: sb writeClassDeclaration: intermediate.
	^sb asString
)
private to: sb writeClassDeclaration: declIR = (
	sb add: declIR headerSource.
	sb writeln: ' ('.
	declIR instanceSide nestedClasses do:
		[:nestedIR | to: sb writeClassDeclaration: nestedIR].
	declIR instanceSide methods do:
		[:method | sb writeln: method source].
	sb writeln: ') : ('.
	declIR classSide methods do:
		[:method | sb writeln: method source].
	sb writeln: ')'.
)
) : (
public fromSource: source <String> ^<ClassDeclarationBuilder> = (
	^self fromUnitSource: 'Newspeak3 ''Uncategorized'' ', source
)
public fromUnitSource: source <String> ^<ClassDeclarationBuilder> = (
	| ir <IntermediateClassDeclaration> builder |
	ir:: compiler compileClassSource: source within: nil.
	builder:: self fromIntermediate: ir.
	ir builder: builder.
	^builder
)
)
private class ClassDeclarationMirror reflecting: mxn = (| mixin <InstanceMixin> = mxn. |) (
public accessModifier ^<Symbol> = (
	^mixin _accessModifier
)
public applyToObject ^<ClassMirror> = (
	nil = mixin _enclosingMixin ifFalse: [^notTopLevel].
	^ClassMirror reflecting: (mixin apply: Object withName: mixin _name enclosingObject: nil)
)
public asBuilder ^<ClassDeclarationBuilder> = (
	| ec ir builder |
	(* nil = mixin _enclosingMixin ifFalse: [unimplemented]. *)
	ec:: nil. (* Intermediates for enclosing class (if any) computed lazily. *)
	ir:: buildIntermediateFor: mixin within: ec.
	builder:: ClassDeclarationBuilder fromIntermediate: ir.
	ir builder: builder.
	^builder
)
public classSide ^<MixinMirror> = (
	^MixinMirror reflecting: mixin _classMixin
)
public definingMixin ^<MixinMirror> = (
	| em = mixin _enclosingMixin. |
	nil = em ifTrue: [^nil].
	^MixinMirror reflecting: em
)
public enclosingClass ^<ClassDeclarationMirror> = (
	| em = mixin _enclosingMixin. |
	nil = em ifTrue: [^nil].
	^ClassDeclarationMirror reflecting: em
)
public instanceSide ^<MixinMirror> = (
	^MixinMirror reflecting: mixin
)
public name = (
	^mixin _name
)
public printString = (
	^'ClassDeclarationMirror:',simpleName.
)
public simpleName = (
	(* halt. TestEnvironment classAccessorName *)
	^mixin _name
)
public source ^<String> = (
	| sb = StringBuilder new. |
	to: sb writeClassDeclaration: mixin.
	^sb asString
)
private to: sb writeClassDeclaration: instanceMixin = (
	sb add: instanceMixin _headerSource.
	sb writeln: ' ('.
	instanceMixin _nestedMixins do:
		[:nestedMixin | to: sb writeClassDeclaration: nestedMixin].
	instanceMixin _methods do:
		[:method | method isSynthetic ifFalse:
			[sb writeln: method source]].
	sb writeln: ') : ('.
	instanceMixin _classMixin _methods do:
		[:method | method isSynthetic ifFalse:
			[sb writeln: method source]].
	sb writeln: ')'.
)
) : (
)
private class ClassHeaderBuilder fromIntermediate: ir = (|
private intermediate <IntermediateClassDeclaration> = ir.
|) (
public name = (
	^intermediate simpleName
)
public name: newName <String> = (
	| token newClassSource newIR |

	intermediate builder enclosingClass. (* For side effect. *)

	(* check for name conflict with sibling members *)
	intermediate isTopLevel ifFalse:
		[ | existing |
		existing:: intermediate enclosingClass nestedClasses 
			detect: [:nested | nested simpleName = newName]
			ifNone: [nil].
		(nil = existing or: [existing = intermediate builder])
			ifFalse: [^Error signal: 'A sibling already exists with the name ', newName]].

	(* patch header source with the new name *)
	token:: (parsing Parser for: source) advanceToken parseClassHeaderForName.
	newClassSource::
		(intermediate isTopLevel
			(* only top-level classes can specify categories *)
			ifTrue: [ 'Newspeak3 ''Category'' ' ]
			ifFalse: [ ' ' ]),
		(source copyFrom: 1 to: token start - 1) ,
		newName,
		(source copyFrom: token end + 1 to: source size).

	(* compile etc *)
	newIR:: compiler
		compileClassHeader: newClassSource
		within: intermediate enclosingClass.
		
	intermediate simpleName: newIR simpleName.
	intermediate headerSource: newIR headerSource.
	intermediate factoryName: newIR factoryName.
	intermediate comment: newIR comment.
	intermediate accessor: newIR accessor.
	intermediate factory: newIR factory.
	intermediate initializers: newIR initializers.
	intermediate instanceSide slots: newIR instanceSide slots.
)
public source ^<String> = (
	^intermediate headerSource
)
) : (
)
public class ClassMirror reflecting: behavior = (|
public reflectee <Behavior> = behavior.
|(isBehavior: behavior) ifFalse: [^Error new signal].
reflectees at: self put: behavior) (
public = other ^<Boolean> = (
	(is: reflectee identicalTo: (reflectees at: other)) ifFalse: [^false].
	^other isKindOfClassMirror
)
public enclosingObject ^<ObjectMirror> = (
	^ObjectMirror reflecting: (enclosingObjectOf: reflectee)
)
public hash ^<Integer> = (
	^(identityHashOf: reflectee) hash bitXor: class hash
)
public isKindOfClassMirror ^<Boolean> = (
	^true
)
public isMeta ^<Boolean> = (
	^Metaclass = (classOf: reflectee)
)
public methods ^<Collection[MethodMirror]> = (
	| cls <Behavior> results <Collection[MethodMirror]> |
	cls:: reflectee.
	results:: List new.
	[nil = cls] whileFalse:
		[(methodsOf: cls) do: 
			[:method <Method> | 
			method isSynthetic ifFalse:
				[results add: (MethodMirror reflecting: method)]].
		cls:: superclassOf: cls].
	^MirrorGroup wrapping: results.
)
public mixin ^<MixinMirror> = (
	^MixinMirror reflecting: (mixinOf: reflectee)
)
public nestedClasses = (
	| cls <Behavior> results <Collection[ClassDeclarationMirror]> |
	cls:: reflectee.
	results:: List new.
	[nil = cls] whileFalse:
		[(mixinOf: cls) _nestedMixins do: 
			[:nestedMixin <InstanceMixin> | 
			results add: (ClassDeclarationMirror reflecting: nestedMixin)].
		cls:: superclassOf: cls].
	^MirrorGroup wrapping: results
)
public slots ^<Collection[SlotDeclarationMirror]> = (
	| cls <Behavior> classes result <Collection[SlotDeclarationMirror]> |
	cls:: reflectee.
	classes:: List new.
	result:: List new.
	[nil = cls] whileFalse: 
		[classes add: cls.
		cls:: superclassOf: cls].
	classes size to: 1 by: -1 do: 
		[:index |
		cls:: classes at: index.
		(mixinOf: cls) _slots do: 
			[:slotDescriptor |
			| name isMutable accessModifier |
			name:: slotDescriptor at: 1.
			isMutable:: slotDescriptor at: 2.
			accessModifier:: slotDescriptor at: 3.
			(name indexOf: '`') = 0 ifTrue:
				[(* Not synthetic. *)
				result add: (SlotDeclarationMirror 
					name: name 
					isMutable: isMutable 
					accessModifier: accessModifier
					mixin: self mixin)]]].
	^MirrorGroup wrapping: result
)
public superclass ^<ClassMirror> = (
	| s = superclassOf: reflectee. |
	nil = s ifTrue: [^nil].
	^ClassMirror reflecting: s
)
) : (
)
private class MethodBuilder reflecting: ir in: builder = (|
private intermediate = ir.
public definingMixin = builder.
|) (
public accessModifier = (
	^intermediate accessModifier
)
public name = (
	^intermediate selector
)
) : (
)
private class MethodMirror reflecting: m = (| 
	method <Method> = m.
|reflectees at: self put: m) (
public = other ^<Boolean> = (
	(is: method identicalTo: (reflectees at: other)) ifFalse: [^false].
	^other isKindOfMethodMirror
)
public accessModifier ^<Symbol> = (
	^method accessModifier
)
public definingMixin ^<MixinMirror> = (
	^MixinMirror reflecting: method mixin
)
public hash ^<Integer> = (
	^(identityHashOf: method) hash bitXor: class hash
)
public isKindOfMethodMirror ^<Boolean> = (
	^true
)
public name = (
	^method selector
)
) : (
)
private class MirrorGroup wrapping: collection = (|
mirrors = collection.
|) (
public collect: blk <[:Mirror]> = (
	^mirrors collect: blk
)
public do: blk <[:Mirror]> = (
	mirrors do: blk
)
public includesMirrorNamed: name = (
	mirrors do: [:mirror | mirror name = name ifTrue: [^true]].
	^false
)
public reject: blk <[:Mirror]> = (
	^mirrors reject: blk
)
) : (
)
private class MixinBuilder fromIntermediate: ir = (|
private intermediate <IntermediateMixin> = ir.
private methodsX
private nestedClassesX
private slotsX
|) (
public declaration ^<ClassDeclarationBuilder> = (
	^intermediate declaration builder
)
public isKindOfMixinMirror ^<Boolean> = (
	^true
)
public methods = (
	nil = methodsX ifTrue:
		[methodsX:: MutableMethodGroup fromIntermediate: intermediate].
	^methodsX
)
public nestedClasses = (
	nil = nestedClassesX ifTrue:
		[nestedClassesX:: MutableNestedClassGroup fromIntermediate: intermediate].
	^nestedClassesX
)
public slots = (
	nil = slotsX ifTrue:
		[slotsX:: MutableSlotGroup fromIntermediate: intermediate].
	^slotsX
)
) : (
)
private class MixinMirror reflecting: mxn = (|
mixin <AbstractMixin> = mxn.
|reflectees at: self put: mxn) (
public = other ^<Boolean> = (
	(mixin = (reflectees at: other)) ifFalse: [^false].
	^other isKindOfMixinMirror
)
public declaration ^<ClassDeclarationMirror> = (
	^ClassDeclarationMirror reflecting: 
		(mixin isMeta ifTrue: [mixin _instanceMixin] ifFalse: [mixin])
)
public enclosingMixin ^<ClassDeclarationMirror> = (
	| em = mixin _enclosingMixin. |
	nil = em ifTrue: [^nil].
	^MixinMirror reflecting: em
)
public hash ^<Integer> = (
	^mixin hash bitXor: class hash
)
public isKindOfMixinMirror ^<Boolean> = (
	^true
)
public isMeta ^<Boolean> = (
	^mixin isMeta
)
public methods ^<Collection[MethodMirror]> = (
	| results = List new. |
	mixin _methods do: 
		[:method | 
		method isSynthetic ifFalse:
			[results add: (MethodMirror reflecting: method)]].
	^MirrorGroup wrapping: results.
)
public name ^<String> = (
	^mixin _name
)
public nestedClasses ^<Collection[ClassDeclarationMirror]> = (
	| results <Collection[ClassDeclarationMirror]> |
	mixin isMeta ifTrue: [^MirrorGroup wrapping: {}].
	results:: List new.
	mixin _nestedMixins do:
		[:nestedMixin <InstanceMixin> | 
		results add: (ClassDeclarationMirror reflecting: nestedMixin)].
	^MirrorGroup wrapping: results
)
public slots ^<Collection[SlotDeclarationMirror]> = (
	| results = List new. |
	mixin isMeta ifTrue: [^MirrorGroup wrapping: {}].
	mixin _slots do: [:slotDescriptor | 
		| slotName isMutable accessModifier |
		slotName:: slotDescriptor at: 1.
		isMutable:: slotDescriptor at: 2.
		accessModifier:: slotDescriptor at: 3.
		0 = (slotName indexOf: '`') ifTrue: (* not synthetic *)
			[results add: (SlotDeclarationMirror 
				name: slotName 
				isMutable: isMutable 
				accessModifier: accessModifier
				mixin: self)]].
	^MirrorGroup wrapping: results.
)
) : (
)
private class MutableMethodGroup fromIntermediate: ir = (|
private intermediate <IntermediateMixin> = ir.
|) (
public addFromSource: source <String> = (
	| 
	imethod <IntermediateMethod>
	|
	imethod:: compiler
		compileMethodSource: source 
		within: intermediate builder.

	imethod category: #'as yet unclassified'.

	intermediate checkNameConflictsForMethod: imethod selector.
	
	intermediate methods removeAllSuchThat: 
		[:ea | ea selector = imethod selector].
	intermediate methods add: imethod.
	
	^MethodBuilder reflecting: imethod in: intermediate builder
)
public do: action = (
	intermediate methods do: 
		[:intermediateMethod |
		action value: (MethodBuilder 
			reflecting: intermediateMethod
			in: intermediate builder)].
)
public removeMirrorNamed: name <Symbol> = (
	intermediate methods removeAllSuchThat:
		[:imethod | imethod isSynthetic not and: [imethod selector = name]].
)
) : (
)
private class MutableNestedClassGroup fromIntermediate: ir = (|
private intermediate <IntermediateMixin> = ir.
|) (
public addFromSource: source <String> ^<ClassDeclarationBuilder> = (
	| idecl <IntermediateClassDeclaration> builder |
	
	idecl:: compiler 
		compileClassSource: source
		within: intermediate.
		
	intermediate checkNameConflictsForNestedClass: idecl simpleName.
	
	intermediate nestedClasses removeAllSuchThat: 
		[:nestedIR | nestedIR simpleName = idecl simpleName].
	intermediate nestedClasses add: idecl.
	
	builder:: ClassDeclarationBuilder fromIntermediate: idecl.
	idecl builder: builder.
	^builder
)
public do: action = (
	intermediate nestedClasses do: 
		[:intermediateClassDeclaration |
		| builder |
		builder:: intermediateClassDeclaration builder.
		nil = builder ifTrue:
			[builder:: ClassDeclarationBuilder fromIntermediate: intermediateClassDeclaration.
			intermediateClassDeclaration builder: builder.
			
			(* :bogus: also find existingMixin *)
			].
		action value: builder].
)
public removeMirrorNamed: name <Symbol> = (
	| nestedIntermediate |
	intermediate nestedClasses removeAllSuchThat:
		[:inested | inested simpleName = name].
)
) : (
)
private class MutableSlotGroup fromIntermediate: ir = (|
private intermediate <IntermediateMixin> = ir.
|) (
public do: action = (
	intermediate slots do: 
		[:intermediateSlot |
		action value: (SlotDeclarationMirror 
			name: intermediateSlot name
			isMutable: intermediateSlot isMutable
			accessModifier: intermediateSlot accessModifier 
			mixin: intermediate builder)].
)
) : (
)
public class ObjectMirror reflecting: object = (|
public reflectee = object.
|reflectees at: self put: reflectee) (
public = other ^<Boolean> = (
	(is: reflectee identicalTo: (reflectees at: other)) ifFalse: [^false].
	^other isKindOfObjectMirror
)
public evaluate: expression <String>
ifCompilerError: compilationErrorHandler <[:Error]> 
ifError: evalErrorHandler <[:ObjectMirror[Error] :ActivationMirror]> ^<ObjectMirror> = (
	
	(* Evaluate [expression] with the reflectee as the receiver. If [expression] cannot be compiled, activate [compilationErrorHandler] with the exception. If the evaluation of [expression] raises an error, activate [evalErrorHandler] with the error. Otherwise return an ObjectMirror on the result of [expression]. *)
	
	| cls mxn mtdMirror result |
	[cls:: classOf: reflectee.
	mxn:: (ClassMirror reflecting: cls) mixin.
	mtdMirror:: compiler
		compileExpressionSource: expression
		inContext: nil
		inMixin: mxn. 
		
	mtdMirror category: #DoIts.
	mtdMirror methodMixin: (mixinOf: cls).
	mtdMirror compiledMethod source: expression.
	(* :todo: at: #debugInfo put: mtdMirror debugInfo *)]
			on: Error
			do: [:e | ^compilationErrorHandler cull: e ].
	
	[result:: 
		object: reflectee 
		executeMethod: mtdMirror compiledMethod
		with: {}]
			on: Error
			do: [:e | ^evalErrorHandler cull: e].

	^ObjectMirror reflecting: result
)
public evaluateSuspended: expression <String> ^<ThreadMirror> = (
	| cls mxn mtdMirror thread simulator |
	cls:: classOf: reflectee.
	mxn:: (ClassMirror reflecting: cls) mixin.
	mtdMirror:: compiler
		compileExpressionSource: expression
		inContext: nil
		inMixin: mxn. 
		
	mtdMirror category: #DoIts.
	mtdMirror methodMixin: (mixinOf: cls).
	mtdMirror compiledMethod source: expression.
	(* :todo: at: #debugInfo put: mtdMirror debugInfo *)

	simulator:: Simulator new.
	simulator activate: mtdMirror compiledMethod receiver: reflectee arguments: {}.

	thread:: Thread new.
	thread state: #suspended.
	thread suspendedActivation: simulator activation.
	
	^ThreadMirror reflecting: thread
)
public getClass ^<ClassMirror> = (
	^ClassMirror reflecting: (classOf: reflectee)
)
public getSlot: name = (
	| index raw |
	index:: indexOfSlotNamed: name in: (classOf: reflectee).
	raw:: slotOf: reflectee at: index.
	^ObjectMirror reflecting: raw	
)
public hash ^<Integer> = (
	^(identityHashOf: reflectee) bitXor: class hash
)
private indexOfSlotNamed: name in: startCls = (
	| cls index |
	cls:: startCls.
	index:: 1.
	[nil = cls] whileFalse: 
		[(mixinOf: cls) _slots do: 
			[:slotDescriptor |
			(slotDescriptor at: 1) = name ifTrue: [^index].
			index:: 1 + index].
		cls:: (superclassOf: cls)].
	^ -1
)
public isKindOfObjectMirror ^<Boolean> = (
	^true
)
private object: object executeMethod: method with: arguments = (
	| activation |
	activation:: Activation new.
	
	activation sender: currentActivation sender.
	activation bci: 1.
	activation method: method.
	activation closure: nil.
	activation receiver: object.
	activation tempSize: arguments size + method numTemps.
	1 to: arguments size do:
		[:index | activation tempAt: index put: (arguments at: index)].
	jumpTo: activation.
	UNREACHABLE.
)
public setSlot: name to: value = (
	| index raw |
	index:: indexOfSlotNamed: name in: (classOf: reflectee).
	slotOf: reflectee at: index put: value.
)
) : (
)
private class Simulator = (|
public activation
|) (
aboutToReturn: result through: firstUnwindActivation = (
	| method |
	method:: behavior: Activation methodAt: #aboutToReturn:through:.
	activate: method receiver: activation arguments: {result. firstUnwindActivation}.
)
public activate: newMethod receiver: newReceiver arguments: arguments = (
	| primitive = newMethod primitive. result newActivation |

	0 = primitive ifFalse: 
		[(* Simulation guard *)
		112 = primitive ifTrue: ['simulation guard' out. halt. ].
	
		(* Current activation *)
		133 = primitive ifTrue: [activation push: activation. ^self].

		(* Closure activation *)
		90 =  primitive ifTrue: 
			[newReceiver numArgs = 0 ifTrue: 
				[^activateClosure: newReceiver arguments: arguments]].
		91 =  primitive ifTrue: 
			[newReceiver numArgs = 1 ifTrue: 
				[^activateClosure: newReceiver arguments: arguments]].
		92 =  primitive ifTrue: 
			[newReceiver numArgs = 2 ifTrue: 
				[^activateClosure: newReceiver arguments: arguments]].
		93 =  primitive ifTrue: 
			[newReceiver numArgs = 3 ifTrue: 
				[^activateClosure: newReceiver arguments: arguments]].
		94 =  primitive ifTrue: [
			| closureArgs = arguments at: 1. |
			(Array = (classOf: closureArgs)) ifTrue: 
				[closureArgs size = newReceiver numArgs ifTrue: 
					[^activateClosure: newReceiver arguments: closureArgs]]].
	
		(* Jump *)
		95 = primitive ifTrue: [
			activation:: arguments at: 1.
			^self].
	
		(* Perform *)
		89 =  primitive ifTrue: [
			| object selector performArguments |
			object:: arguments at: 1.
			selector:: arguments at: 2.
			performArguments:: arguments at: 3.
			(* :todo: Where should we fail on arity mismatch? *)
			(ByteString = (classOf: selector)) ifTrue: 
				[(Array = (classOf: performArguments)) ifTrue: 
					[activation push: object.
					performArguments do: [:arg | activation push: arg].
					^ordinarySend: selector numArgs: performArguments size]]].
	
		result:: doPrimitive: primitive receiver: newReceiver arguments: arguments.
		arguments = result ifFalse: [activation push: result. ^self].
		('simulated primitive failed: ', newMethod selector) out].

	newActivation:: Activation new.
	newActivation sender: activation.
	newActivation bci: 1.
	newActivation method: newMethod.
	newActivation closure: nil.
	newActivation receiver: newReceiver.
	
	newActivation tempSize: arguments size + newMethod numTemps.
	1 to: arguments size do: 
		[:index | newActivation tempAt: index put: (arguments at: index)].
	
	(* ('sim: ', newActivation printString) out. *)

	activation:: newActivation.
)
public activateClosure: closure arguments: arguments = (
	| newActivation |
	newActivation:: Activation new.
	newActivation sender: activation.
	newActivation bci: (initialBCIOf: closure).
	newActivation method: (definingActivationOf: closure) method.
	newActivation closure: closure.
	newActivation receiver: (definingActivationOf: closure) receiver.
	arguments size = closure numArgs ifFalse: [halt].
	arguments do: 
		[:argument | newActivation push: argument].
	1 to: (numCopiedOf: closure) do: 
		[:index | newActivation push: (copiedOf: closure at: index)].
	
	(* ('sim: ', newActivation printString) out. *)
	activation:: newActivation.
)
behavior: behavior hasSelector: selector = (
	(methodsOf: behavior) do: [:method | method selector = selector ifTrue: [^true]].
	^false
)
behavior: behavior methodAt: selector = (
	(methodsOf: behavior) do: [:method | method selector = selector ifTrue: [^method]].
	^nil
)
blockReturn: result = (
	localReturn: result
)
cannotReturn: result = (
	| method |
	method:: behavior: Activation methodAt: #cannotReturn:.
	activate: method receiver: activation arguments: {result}.
)
commonArithmeticSend: offset = (
	0 = offset ifTrue: [^ordinarySend: #+ numArgs: 1].
	1 = offset ifTrue: [^ordinarySend: #- numArgs: 1].
	2 = offset ifTrue: [^ordinarySend: #< numArgs: 1].
	3 = offset ifTrue: [^ordinarySend: #> numArgs: 1].
	4 = offset ifTrue: [^ordinarySend: #<= numArgs: 1].
	5 = offset ifTrue: [^ordinarySend: #>= numArgs: 1].
	6 = offset ifTrue: [^ordinarySend: #= numArgs: 1].
	7 = offset ifTrue: [^ordinarySend: #~= numArgs: 1].
	8 = offset ifTrue: [^ordinarySend: #* numArgs: 1].
	9 = offset ifTrue: [^ordinarySend: #/ numArgs: 1].
	10 = offset ifTrue: [^ordinarySend: #\\ numArgs: 1].
	11 = offset ifTrue: [^ordinarySend: #@ numArgs: 1].
	12 = offset ifTrue: [^ordinarySend: #bitShift: numArgs: 1].
	13 = offset ifTrue: [^ordinarySend: #// numArgs: 1].
	14 = offset ifTrue: [^ordinarySend: #bitAnd: numArgs: 1].
	15 = offset ifTrue: [^ordinarySend: #bitOr: numArgs: 1].
)
commonSend: offset = (
	0 = offset ifTrue: [^ordinarySend: #at: numArgs: 1].
	1 = offset ifTrue: [^ordinarySend: #at:put: numArgs: 2].
	2 = offset ifTrue: [^ordinarySend: #size numArgs: 0].
	3 = offset ifTrue: [^ordinarySend: #next numArgs: 0].
	4 = offset ifTrue: [^ordinarySend: #nextPut: numArgs: 1].
	5 = offset ifTrue: [^ordinarySend: #atEnd numArgs: 0].
	6 = offset ifTrue: [^ordinarySend: #== numArgs: 1].
	7 = offset ifTrue: [^ordinarySend: #class numArgs: 0].
	8 = offset ifTrue: [^ordinarySend: #blockCopy: numArgs: 1].
	9 = offset ifTrue: [^ordinarySend: #value numArgs: 0].
	10 = offset ifTrue: [^ordinarySend: #value: numArgs: 1].
	11 = offset ifTrue: [^ordinarySend: #do: numArgs: 1].
	12 = offset ifTrue: [^ordinarySend: #new numArgs: 0].
	13 = offset ifTrue: [^ordinarySend: #new: numArgs: 1].
	14 = offset ifTrue: [^ordinarySend: #x numArgs: 0].
	15 = offset ifTrue: [^ordinarySend: #y numArgs: 0].
)
private doPrimitive: index <Integer> receiver: receiver <Object> arguments: arguments <Array> = (
	(* :literalmessage: primitive: 141 *)
	'doPrimitive failed' out.
	index out.
	receiver out.
	arguments size out.
	halt.
)
dup = (
	activation push: activation top.
)
findApplicationOf: mixin startingAt: startingBehavior = (
	| behavior ::= startingBehavior. |
	[nil = behavior] whileFalse: 
		[mixin = (mixinOf: behavior) ifTrue: [^behavior].
		 behavior:: (superclassOf: behavior)].
	halt.
)
implicitReceiverSend: selectorOffset numArgs: numArgs = (
	| selector arguments candidateReceiver candidateMixin candidateMixinApplication |
	selector:: activation method literals at: selectorOffset + 1.
	arguments:: Array new: numArgs.
	numArgs to: 1 by: -1 do: [:i | arguments at: i put: activation pop].
	candidateReceiver:: activation receiver.
	candidateMixin:: activation method mixin.
	[candidateMixinApplication::
		findApplicationOf: candidateMixin 
		startingAt: (classOf: candidateReceiver).
	(behavior: candidateMixinApplication hasSelector: selector) ifTrue:
		[^sendLexical: selector to: candidateReceiver arguments: arguments wrt: candidateMixin].
	candidateMixin:: candidateMixin _enclosingMixin.
	nil = candidateMixin ifTrue:
		[^sendProtected: selector to: activation receiver arguments: arguments startingAt: (classOf: activation receiver)].
	candidateReceiver:: enclosingObjectOf: candidateMixinApplication.
	] repeat.
)
interpretNext1Byte: byte extA: extA extB: extB = (
	byte <= 15 ifTrue: [^self unusedBytecode (* squeak: pushReceiverVariable *)].
	byte <= 31 ifTrue: [^self pushLiteralVariable: (byte bitAnd: 15)].
	byte <= 63 ifTrue: [^self pushLiteral: (byte bitAnd: 31)].
	byte <= 71 ifTrue: [^self pushTemporary: (byte bitAnd: 7)].
	byte <= 75 ifTrue: [^self pushTemporary: (byte bitAnd: 7) + 8].
	byte <= 76 ifTrue: [^self pushReceiver].
	byte <= 77 ifTrue: [^self pushSpecial: extB].
	byte <= 78 ifTrue: [^self pushInteger: 0].
	byte <= 79 ifTrue: [^self pushInteger: 1].
	byte <= 95 ifTrue: [^self commonArithmeticSend: (byte bitAnd: 15)].
	byte <= 111 ifTrue: [^self commonSend: (byte bitAnd: 15)].
	byte <= 127 ifTrue: 
		[^self ordinarySend: (activation method literals at: (byte bitAnd: 15) + 1) numArgs: 0].
	byte <= 143 ifTrue: 
		[^self ordinarySend: (activation method literals at: (byte bitAnd: 15) + 1) numArgs: 1].
	byte <= 159 ifTrue: 
		[^self ordinarySend: (activation method literals at: (byte bitAnd: 15) + 1) numArgs: 2].
	byte <= 175 ifTrue: [^self implicitReceiverSend: (byte bitAnd: 15) numArgs: 0].
	byte <= 183 ifTrue: [^self unusedBytecode (* squeak: popIntoReceiverVariable *)].
	byte <= 191 ifTrue: [^self popIntoTemporary: (byte bitAnd: 7)].
	byte <= 199 ifTrue: [^self jump: (byte bitAnd: 7) + 1].
	byte <= 207 ifTrue: [^self popJumpTrue: (byte bitAnd: 7) + 1].
	byte <= 215 ifTrue: [^self popJumpFalse: (byte bitAnd: 7) + 1].
	byte <= 216 ifTrue: [^self methodReturn: activation receiver].
	byte <= 217 ifTrue: [^self methodReturn: activation pop].
	byte <= 218 ifTrue: [^self blockReturn: activation pop].
	byte <= 219 ifTrue: [^self dup].
	byte <= 220 ifTrue: [^self pop].
	byte <= 221 ifTrue: [^self (* nop *)].
	byte <= 222 ifTrue: [^self break].

	(* 223 *) ^self unusedBytecode
)
interpretNext2Byte: byte1 byte: byte2 extA: extA extB: extB = (
	byte1 <= 224 ifTrue: 
		[^self interpretNextInstructionExtA: (extA << 8) + byte2 extB: extB].
	byte1 <= 225 ifTrue: 
		[^self interpretNextInstructionExtA: extA extB: 
			((extB = 0 and: [byte2 > 127]) 
				ifTrue: [byte2 - 256] 
				ifFalse: [(extB << 8) + byte2])].
	
	byte1 <= 226 ifTrue: [^self unusedBytecode (* squeak: pushReceiverVariable *)].
	byte1 <= 227 ifTrue: [^self pushLiteralVariable: (extA << 8) + byte2].
	byte1 <= 228 ifTrue: [^self pushLiteral: (extA << 8) + byte2].
	byte1 <= 229 ifTrue: [^self pushInteger: (extB << 8) + byte2].
	byte1 <= 230 ifTrue: [^self pushTemporary: byte2].
	byte1 <= 231 ifTrue: 
		[byte2 < 128 
			ifTrue: [^self pushNewArray: byte2]
			ifFalse: [^self pushNewArrayWithElements: byte2 - 128]].
	byte1 <= 232 ifTrue: [^self unusedBytecode (* squeak: storeIntoReceiverVariable *)].
	byte1 <= 233 ifTrue: [^self unusedBytecode (* squeak: storeIntoLiteralVariable *)].
	byte1 <= 234 ifTrue: [^self storeIntoTemporary: byte2].
	byte1 <= 235 ifTrue: [^self unusedBytecode (* squeak: popIntoReceiverVariable *)].
	byte1 <= 236 ifTrue: [^self unusedBytecode (* squeak: popIntoLiteralVariable *)].
	byte1 <= 237 ifTrue: [^self popIntoTemporary: byte2].
	byte1 <= 238 ifTrue: 
		[^self ordinarySend: (activation method literals at: (extA << 5) + (byte2 >> 3) + 1)
		numArgs: (extB << 3) + (byte2 bitAnd: 7)].
	byte1 <= 239 ifTrue: [^self unusedBytecode (* squeak: staticSuperSend *)].
	byte1 <= 240 ifTrue: 
		[^self implicitReceiverSend: (extA << 5) + (byte2 >> 3) 
		numArgs: (extB << 3) + (byte2 bitAnd: 7)].
	byte1 <= 241 ifTrue: 
		[^self superSend: (extA << 5) + (byte2 >> 3) 
		numArgs: (extB << 3) + (byte2 bitAnd: 7)].
	byte1 <= 242 ifTrue: [^self jump: (extB << 8) + byte2].
	byte1 <= 243 ifTrue: [^self popJumpTrue: (extB << 8) + byte2].
	byte1 <= 244 ifTrue: [^self popJumpFalse: (extB << 8) + byte2].
	byte1 <= 245 ifTrue: 
		[^self selfSend: (extA << 5) + (byte2 >> 3) 
		numArgs: (extB << 3) + (byte2 bitAnd: 7)].

	(* 246, 247, 248 *) ^self unusedBytecode
)
interpretNext3Byte: byte1 byte: byte2 byte: byte3 extA: extA extB: extB ^<Activation> = (
	byte1 <= 249 ifTrue: [^unusedBytecode (* squeak: callPrimitive *)].
	byte1 <= 250 ifTrue: [^self pushRemoteTemp: byte2 inVector: byte3].
	byte1 <= 251 ifTrue: [^self storeIntoRemoteTemp: byte2 inVector: byte3].
	byte1 <= 252 ifTrue: [^self popIntoRemoteTemp: byte2 inVector: byte3].
	byte1 <= 253 ifTrue: 
		[^self 
			pushClosureNumCopied: ((byte2 >> 3) bitAnd: 7) + ((extA // 16) << 3)
			numArgs: (byte2 bitAnd: 7) + ((extA \\ 16) << 3)
			blockSize: (extB << 8) + byte3].
	byte1 <= 254 ifTrue: 
		[^self 
			outerSend: (extA << 5) + (byte2 >> 3) 
			numArgs: (extB << 3) + (byte2 bitAnd: 7)
			depth: byte3].
	
	(* 255 *)
	^unusedBytecode
)
public interpretNextInstruction = (
	self interpretNextInstructionExtA: 0 extB: 0 
)
interpretNextInstructionExtA: extA extB: extB = (
	| bci bytecode byte byte2 byte3 |
	bci:: activation bci.
	bytecode:: activation method bytecode.
	byte:: bytecode at: bci.
	byte <= 223 ifTrue: 
		[activation bci: bci + 1. 
		 ^interpretNext1Byte: byte extA: extA extB: extB].

	byte2:: bytecode at: bci + 1.
	byte <= 248 ifTrue: 
		[activation bci: bci + 2.
		^interpretNext2Byte: byte byte: byte2 extA: extA extB: extB].

	byte3:: bytecode at: bci + 2.
	activation bci: bci + 3.
	^interpretNext3Byte: byte byte: byte2 byte: byte3 extA: extA extB: extB
)
jump: delta = (
	activation bci: activation bci + delta.
)
localReturn: result = (
	| sender = activation sender. |
	nil = sender ifTrue: [^cannotReturn: result].
	sender isDead ifTrue: [^cannotReturn: result].
	activation terminate.
	sender push: result.
	activation: sender.
)
methodReturn: result = (
	nil = activation closure
		ifTrue: [localReturn: result]
		ifFalse: [nonLocalReturn: result]
)
private newClosureIn: definingActivation initialBCI: initialBCI numArgs: numArgs numCopied: numCopied = (
	(* :literalmessage: primitive: 69 *)
	halt.
)
nonBooleanReceiver: nonBoolean = (
	| method |
	method:: behavior: Activation methodAt: #nonBooleanReceiver:.
	activate: method receiver: activation arguments: {nonBoolean}.
)
nonLocalReturn: result = (
	| closure home unwind sender zap next |
	closure:: activation closure.
	home:: definingActivationOf: closure.
	closure:: home closure.
	[nil = closure] whileFalse: 
		[home:: definingActivationOf: closure.
		 closure:: home closure].
	
	unwind:: activation sender.
	[unwind = home] whileFalse: 
		[nil = unwind ifTrue: 
			[^cannotReturn: result].
		unwind method primitive = 113 ifTrue:
			[^aboutToReturn: result through: unwind].
		unwind method primitive = 142 ifTrue:
			[^cannotReturn: result].
		unwind:: unwind sender].
	
	sender:: home sender.
	(nil = sender or: [sender isDead]) ifTrue:
		[^cannotReturn: result].
	
	(* Mark activations on the dynamic chain up to the return target as dead. Note this follows the behavior of Squeak instead of the blue book, which only zaps A. *)
	zap:: activation.
	[next:: zap sender.
	 zap terminate.
	 zap:: next.
	 zap = sender] whileFalse.
	
	sender push: result.
	activation: sender.
	(* ('sim: ', activation printString) out. *)
)
ordinarySend: selector numArgs: numArgs = (
	| arguments messageReceiver lookupClass targetMethod |
	arguments:: Array new: numArgs.
	numArgs to: 1 by: -1 do: [:i | arguments at: i put: activation pop].
	messageReceiver:: activation pop.
	lookupClass:: classOf: messageReceiver.
	[nil = lookupClass] whileFalse:
		[targetMethod:: behavior: lookupClass methodAt: selector.
		(((nil = targetMethod) not) and: [targetMethod isPublic])
			ifTrue: [^activate: targetMethod receiver: messageReceiver arguments: arguments].
		lookupClass:: superclassOf: lookupClass].
	^sendDnu: selector to: messageReceiver arguments: arguments.
)
outerSend: selectorOffset numArgs: numArgs depth: depth = (
	| selector arguments receiver targetMixin count mixinApplication |
	selector:: activation method literals at: selectorOffset + 1.
	arguments:: Array new: numArgs.
	numArgs to: 1 by: -1 do: [:i | arguments at: i put: activation pop].
	receiver:: activation receiver.
	targetMixin:: activation method mixin.
	count:: 0.
	[count < depth] whileTrue:
		[count:: count + 1.
		mixinApplication:: findApplicationOf: targetMixin startingAt: (classOf: receiver).
		receiver:: enclosingObjectOf: mixinApplication.
		targetMixin:: targetMixin _enclosingMixin].
	^sendLexical: selector to: receiver arguments: arguments wrt: targetMixin.
)
pop = (
	activation pop
)
popIntoRemoteTemp: offset inVector: vectorOffset = (
	| vector = activation tempAt: 1 + vectorOffset. |
	vector at: 1 + offset put: activation pop.
)
popIntoTemporary: offset = (
	activation tempAt: 1 + offset put: activation pop.
)
popJumpFalse: delta = (
	| top = activation pop. |
	true = top ifTrue: [^self].
	false = top ifTrue:
		[activation bci: activation bci + delta.
		^self].
	^nonBooleanReceiver: top
)
popJumpTrue: delta = (
	| top = activation pop. |
	true = top ifTrue: 
		[activation bci: activation bci + delta.
		^self].
	false = top ifTrue: [^self].
	^nonBooleanReceiver: top
)
pushClosureNumCopied: numCopied numArgs: numArgs blockSize: blockSize ^<Activation> = (
	| newClosure |
	newClosure:: 
		newClosureIn: activation
		initialBCI: activation bci
		numArgs: numArgs 
		numCopied: numCopied.
		
	numCopied to: 1 by: -1 do: 
		[:index | copiedOf: newClosure at: index put: activation pop].

	activation push: newClosure.
	activation bci: activation bci + blockSize.
)
pushEnclosingObject: depth = (
	| enclosingObject targetMixin count mixinApplication |
	enclosingObject:: activation receiver.
	targetMixin:: activation method mixin.
	count:: 0.
	[count < depth] whileTrue:
		[count:: count + 1.
		mixinApplication:: findApplicationOf: targetMixin startingAt: (classOf: enclosingObject).
		enclosingObject:: enclosingObjectOf: mixinApplication.
		targetMixin:: targetMixin _enclosingMixin].
	activation push: enclosingObject.
)
pushInteger: value = (
	activation push: value
)
pushLiteral: offset = (
	| literals = activation method literals. |
	literals size + 1 = offset
		ifTrue: [(* Squeak method class association *) activation push: activation method mixin]
		ifFalse: [activation push: (literals at: 1 + offset)].
)
pushLiteralVariable: offset = (
	(* Not used in Newspeak, except by the implementation of eventual sends. *)
	pushScheduler.
)
pushNewArray: size ^<Activation> = (
	activation push: (Array new: size).
)
pushNewArrayWithElements: size ^<Activation> = (
	| newArray = Array new: size. |
	size to: 1 by: -1 do: [:index | newArray at: index put: activation pop].
	activation push: newArray.
)
pushReceiver = (
	activation push: activation receiver.
)
pushRemoteTemp: offset inVector: vectorOffset = (
	| vector = activation tempAt: 1 + vectorOffset. |
	activation push: (vector at: 1 + offset).
)
pushSpecial: extB = (
	extB < 0 ifTrue: [^pushEnclosingObject: 0 - extB].
	
	0 = extB ifTrue: [activation push: false. ^self].
	1 = extB ifTrue: [activation push: true. ^self].
	2 = extB ifTrue: [activation push: nil. ^self].
	
	^unusedBytecode
)
pushTemporary: offset = (
	activation push: (activation tempAt: 1 + offset).
)
selfSend: selectorOffset numArgs: numArgs = (
	| selector arguments |
	selector:: activation method literals at: selectorOffset + 1.
	arguments:: Array new: numArgs.
	numArgs to: 1 by: -1 do: [:i | arguments at: i put: activation pop].
	^sendLexical: selector to: activation receiver arguments: arguments wrt: activation method mixin
)
sendDnu: selector to: messageReceiver arguments: arguments = (
	| lookupClass message dnuMethod |
	lookupClass:: classOf: messageReceiver.
	message:: Message selector: selector arguments: arguments.
	[nil = lookupClass] whileFalse:
		[dnuMethod:: behavior: lookupClass methodAt: #doesNotUnderstand:.
		 nil = dnuMethod ifFalse: 
			[^activate: dnuMethod receiver: messageReceiver arguments: {message} ].
		 lookupClass:: superclassOf: lookupClass].
	error: 'Recursive doesNotUnderstand:'
)
sendLexical: selector to: messageReceiver arguments: arguments wrt: mixin = (
	| mixinApplication targetMethod |
	mixinApplication:: findApplicationOf: mixin startingAt: (classOf: messageReceiver).
	targetMethod:: behavior: mixinApplication methodAt: selector.
	((nil = targetMethod) not and: [targetMethod isPrivate]) ifTrue:
		[^activate: targetMethod receiver: messageReceiver arguments: arguments].
	^sendProtected: selector to: messageReceiver arguments: arguments startingAt: (classOf: messageReceiver)
)
sendProtected: selector to: messageReceiver arguments: arguments startingAt: mixinApp = (
	| lookupClass targetMethod |
	lookupClass:: mixinApp.
	[nil = lookupClass] whileFalse:
		[targetMethod:: behavior: lookupClass methodAt: selector.
		(((nil = targetMethod) not) and: [targetMethod isPrivate not])
			ifTrue: [^activate: targetMethod receiver: messageReceiver arguments: arguments].
		lookupClass:: superclassOf: lookupClass].
	^sendDnu: selector to: messageReceiver arguments: arguments.
)
storeIntoRemoteTemp: offset inVector: vectorOffset = (
	| vector = activation tempAt: 1 + vectorOffset. |
	vector at: 1 + offset put: activation top.
)
storeIntoTemporary: offset = (
	activation tempAt: 1 + offset put: activation top.
)
superSend: selectorOffset numArgs: numArgs = (
	| selector arguments messageReceiver methodMixinApplication |
	selector:: activation method literals at: selectorOffset + 1.
	arguments:: Array new: numArgs.
	numArgs to: 1 by: -1 do: [:i | arguments at: i put: activation pop].
	messageReceiver:: activation receiver.
	methodMixinApplication:: findApplicationOf: activation method mixin startingAt: (classOf: messageReceiver).
	^sendProtected: selector to: messageReceiver arguments: arguments startingAt: (superclassOf: methodMixinApplication)
)
public trace = (
	| a ::= activation. |
	'sim trace: ' out.
	[nil = a] whileFalse: 
		[a out.
		a:: a sender].
)
public traceLong = (
	| a ::= activation. |
	'sim trace long: ' out.
	[nil = a] whileFalse: 
		['' out.
		a out.
		a bci out.
		a receiver out.
		1 to: a tempSize do: [:i | (a tempAt: i) out].
		a:: a sender].
)
) : (
)
private class SlotDeclarationMirror name: n isMutable: m accessModifier: a mixin: mxn = (|
public name = n.
public isMutable = m.
public accessModifier = a.
public definingMixin = mxn.
|) (
) : (
)
private class Thread = (
|
public state ::= #initial.
public result
public suspendedActivation
public steppingGoal
|
) (
) : (
)
private class ThreadMirror reflecting: t = (
	| protected thread = t. |
) (
private createSimulationRoot = (
	| root = Activation new. |
	(* bottom sender: nil *) (* Note that the current activation is not attached as the sender of the simulated activation. This prevents a non-local return from crossing the simulation boundry. *)
	root method: simulatorRootMethod. (* Marks the activation as a simulation root. Used to route unhandled exceptions. *)
	root bci: 0. (* Marks the activation as not dead so the final return can succeed. *)
	(* bottom closure: nil *)
	(* bottom receiver: nil *)
	root push: thread. (* Known to exception signaling machinery. *)
	^root
)
private findBottom: top <Activation> = (
	| bottom ::= top. |
	[nil = bottom sender or: [bottom sender method primitive = 142]] whileFalse:
		[bottom:: bottom sender].
	^bottom
)
public isBroken ^<Boolean> = (
	^thread state = #broken
)
public isFulfilled ^<Boolean> = (
	^thread state = #fulfilled
)
public isRunning ^<Boolean> = (
	halt.
)
public isSuspended ^<Boolean> = (
	^thread state = #suspended
)
public isTerminated ^<Boolean> = (
	halt.
)
public result ^<ObjectMirror | nil> = (
	thread state = #fulfilled ifTrue: [^ObjectMirror reflecting: thread result].
	thread state = #broken ifTrue: [^ObjectMirror reflecting: thread result].
	^nil
)
public resume ^<ThreadMirror> = (
	(* :literalmessage: primitive: 142 *)
	| threadAtTemp1 bottom res |
	threadAtTemp1:: thread. (* Known to exception signaling machinery. *)

	bottom:: findBottom: thread suspendedActivation.

	thread state: #running.
	bottom sender: currentActivation.
	res:: jumpTo: thread suspendedActivation.

	thread state = #broken ifTrue:
		[thread result: res.
		 thread suspendedActivation: nil. 
		 ^self].

	thread state: #fulfilled.
	thread result: res.
	^self
)
public resumeSlowly ^<ThreadMirror> = (
	| root bottom simulator = Simulator new. |

	root:: createSimulationRoot.
	bottom:: findBottom: thread suspendedActivation.

	thread state: #running.
	bottom sender: root.
	simulator activation: thread suspendedActivation.
	[root = simulator activation] whileFalse:
		[simulator interpretNextInstruction].

	thread state = #broken ifTrue:
		[thread result: simulator activation pop.
		 thread suspendedActivation: nil. 
		 ^self].

	thread state: #fulfilled.
	thread result: simulator activation pop.
	^self
)
public stepInto = (
	| root bottom simulator = Simulator new. |
	
	root:: createSimulationRoot.
	bottom:: findBottom: thread suspendedActivation.
	
	thread state: #running.
	bottom sender: root.
	simulator activation: thread suspendedActivation.
	simulator interpretNextInstruction. (* :todo: Step past anything synthetic. *)

	root = simulator activation ifTrue:
		[thread state = #broken ifTrue:
			[thread result: simulator activation pop.
			 thread suspendedActivation: nil.
			 ^self].

		thread state: #fulfilled.
		thread result: simulator activation pop.
		^self].
	
	thread state: #suspended.
	thread suspendedActivation: simulator activation.
	^self
)
public suspendedActivation ^<ActivationMirror | nil> = (
	isSuspended ifFalse: [^nil].
	^ActivationMirror reflecting: thread suspendedActivation
)
public terminate ^<ThreadMirror> = (
	halt.
)
) : (
)
private allInstancesOf: cls = (
	(* :literalmessage: primitive: 96 *)
	halt.
)
private allocate: cls = (
	(* :literalmessage: primitive: 34 *)
	halt.
)
buildIntermediate: i <IntermediateMixin> from: mixin <AbstractMixin> within: ec = (
	| initializers = List new. |

	mixin _methods do: 
		[:method |
		|
		selector = method selector.
		imethod = intermediates IntermediateMethod new.
		|
		imethod method: method.
		imethod methodMixin: mixin.
		imethod selector: selector.
		imethod accessModifier: method accessModifier.
		imethod isSynthetic: method isSynthetic.
		imethod category: 42.
		(isSubinitializerSelector: selector) ifTrue:
			[initializers add: imethod].
		imethod isSynthetic ifFalse:
			[i methods add: imethod]].
	
	mixin isMeta ifTrue:
		[ | factoryName factoryM factoryIR |
		factoryName:: mixin _instanceMixin _primaryFactorySelector.
		factoryM:: mixin _methods detect: [:ea | ea selector = factoryName].
		factoryIR:: intermediates IntermediateMethod new.
		factoryIR method: factoryM.
		factoryIR methodMixin: mixin.
		factoryIR selector: factoryName.
		factoryIR accessModifier: factoryM accessModifier.
		factoryIR isSynthetic: true.
		factoryIR category: nil.
		i declaration factory: factoryIR.
		^self].

	i declaration initializers: initializers.
	
	mixin _slots do:
		[:tuple |
		| slot = intermediates IntermediateSlotDeclaration new. |
		slot name: (tuple at: 1).
		slot isMutable: (tuple at: 2).
		slot accessModifier: (tuple at: 3).
		(isSyntheticSlotSelector: slot name) ifFalse: 
			[i slots add: slot]].
	
	mixin _nestedMixins do:
		[:nestedMixin <InstanceMixin> |
		| 
		nestedIR <IntermediateClassDeclaration> 
		accessorM <Method> 
		accessorIR <IntermediateMethod>
		|
		nestedIR:: buildIntermediateFor: nestedMixin within: ec.
		i nestedClasses add: nestedIR.
		
		accessorM:: mixin _methods detect: [:ea | ea selector = nestedIR simpleName].
		accessorIR:: intermediates IntermediateMethod new.
		accessorIR method: accessorM.
		accessorIR methodMixin: mixin.
		accessorIR selector: nestedIR simpleName.
		accessorIR accessModifier: accessorM accessModifier.
		accessorIR isSynthetic: true.
		accessorIR category: nil.
		nestedIR accessor: accessorIR].
)
buildIntermediateFor: mixin <InstanceMixin> within: ec <ICD> ^<IntermediateClassDeclaration> = (
	| i = intermediates IntermediateClassDeclaration new. |
	i simpleName: mixin _name.
	i headerSource: mixin _headerSource.
	i factoryName: mixin _primaryFactorySelector.
	i comment: nil.
	i category: 42.
	i enclosingClass: ec.
	i existingMixin: mixin.
	buildIntermediate: i instanceSide from: mixin within: i.
	buildIntermediate: i classSide from: mixin _classMixin within: i.
	^i
)
private classOf: object = (
	(* :literalmessage: primitive: 85 *)
	primitiveFailed: 'Mirror classOf:'.
)
private compiler = (
	nil = compilerX ifTrue: [constructCompiler].
	^compilerX
)
private constructCompiler = (
	| asts compilation |
	asts:: namespace NewspeakASTs 
		usingLib: cachedPlatform.
	parsingX:: namespace NewspeakPredictiveParsing 
		usingPlatform: cachedPlatform
		asts: asts.
	intermediatesX:: namespace Intermediates 
		usingPlatform: cachedPlatform
		internalKernel: internalKernel.
	compilation:: namespace Newspeak2SqueakCompilation 
		usingPlatform: cachedPlatform 
		asts: asts
		newspeakParser: parsingX
		intermediates: intermediatesX.
	compilerX:: compilation Compiler new.
)
private copiedOf: closure <Closure> at: index <Integer> ^<Object> = (
	(* :literalmessage: primitive: 77 *)
	primitiveFailed: 'Mirror copiedOf:at:'.
)
private copiedOf: closure <Closure> at: index <Integer> put: value <Object> ^<Object> = (
	(* :literalmessage: primitive: 78 *)
	primitiveFailed: 'Mirror copiedOf:at:put:'.
)
private currentActivation ^<Activation> = (
	(* :literalmessage: primitive: 133 *)
	^halt
)
private definingActivationOf: closure <Closure> ^<Activation> = (
	(* :literalmessage: primitive: 71 *)
	primitiveFailed: 'Mirror definingActivationOf:'.
)
private elementsOf: old forwardIdentityToElementsOf: new = (
	(* :literalmessage: primitive: 98 *)
	halt.
)
private enclosingObjectOf: behavior = (
	^self slotOf: behavior at: 3
)
private identityHashOf: a = (
	(* :literalmessage: primitive: 87 *)
	halt.
)
private initialBCIOf: closure <Closure> ^<Integer> = (
	(* :literalmessage: primitive: 73 *)
	primitiveFailed: 'Mirror initialBCIOf:'.
)
private intermediates = (
	nil = intermediatesX ifTrue: [constructCompiler].
	^intermediatesX
)
private is: a identicalTo: b = (
	(* :literalmessage: primitive: 86 *)
	halt.
)
private isBehavior: object = (
	| cls |
	cls:: classOf: object.
	Metaclass = cls ifTrue: [^true (* [object] is a metaclass *)].
	cls:: classOf: cls.
	Metaclass = cls ifTrue: [^true (* [object] is a class *)].
	cls:: classOf: cls.
	assert: [Metaclass = cls] message: ''.
	^false
)
private isSubinitializerSelector: selector = (
	(selector startsWith: 'mixinInitializer`') ifTrue: [^true].
	(selector startsWith: 'initializer`') ifTrue: [^true].
	^false
)
private isSyntheticSlotSelector: selector = (
	^selector endsWith: '`slot'
)
private jumpTo: activation = (
	(* :literalmessage: primitive: 95 *)
	halt.
)
private methodsOf: behavior = (
	^self slotOf: behavior at: 2
)
private mixinOf: behavior = (
	^self slotOf: behavior at: 4
)
private numCopiedOf: closure <Closure> ^<Integer> = (
	(* :literalmessage: primitive: 70 *)
	primitiveFailed: 'Mirror numCopiedOf:'.
)
private parsing = (
	nil = parsingX ifTrue: [constructCompiler].
	^parsingX
)
private simulatorRoot = (
	(* :literalmessage: primitive: 142 *)
	halt.
)
private simulatorRootMethod = (
	| methods = methodsOf: self class. |
	1 to: methods size do: 
		[:index | | method = methods at: index. |
		method selector = #simulatorRoot ifTrue: [^method]].
	halt.
)
private slotOf: object at: index = (
	(* :literalmessage: primitive: 35 *)
	primitiveFailed: 'Mirror slotOf:at:'.
)
private slotOf: object at: index put: value = (
	(* :literalmessage: primitive: 36 *)
	primitiveFailed: 'Mirror slotOf:at:put:'.
)
private subclassesOf: klass = (
	^self slotOf: klass at: 8
)
private superclassOf: behavior = (
	^self slotOf: behavior at: 1
)
) : (
)

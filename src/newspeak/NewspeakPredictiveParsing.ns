Newspeak3
'Newspeak'
class NewspeakPredictiveParsing usingPlatform: platform asts: asts = (
(* A predictive LL(3) parser for Newspeak.

Faster than the CombinatorialParsing-based parser, and can be modified without requiring a platform reset.

Brazil 1021 -> 50ms.
NewspeakCompilation  250 -> 16ms.

Todo:
 - Parse types according to the spec'd grammar. Currently we diet parse for a closing >.
 - Accept class declarations without bodies.
 - Attach better source positions for synthetic parts like the default superclass clause.
 - Separate the AST building from the parsing, something like the parser calling various #acceptFoo methods that subclasses should implement. Then add the colorizing and source mirror subclasses. *)|
	private List = platform collections List.

	private BinaryTypeOpAST = asts BinaryTypeOpAST.
	private BlockAST = asts BlockAST.
	private BlockTypeAST = asts BlockTypeAST.
	private CascadedSendAST = asts CascadedSendAST.
	private CharacterAST = asts CharacterAST.
	private ClassBodyAST = asts ClassBodyAST.
	private ClassDeclarationAST = asts ClassDeclarationAST.
	private ClassHeaderAST = asts ClassHeaderAST.
	private ClassPrefixAST = asts ClassPrefixAST.
	private CodeBodyAST = asts CodeBodyAST.
	private ImmutableSlotDefAST = asts ImmutableSlotDefAST.
	private InitializerAST = asts InitializerAST.
	private ParameterizedTypeAST = asts ParameterizedTypeAST.
	private MessageAST = asts MessageAST.
	private MessagePatternAST = asts MessagePatternAST.
	private MethodAST = asts MethodAST.
	private MixinApplicationClassAST = asts MixinApplicationClassAST.
	private MutableSlotDefAST = asts MutableSlotDefAST.
	private UnresolvedSendAST = asts UnresolvedSendAST.
	private NumberAST = asts NumberAST.
	private ReturnStatAST = asts ReturnStatAST.
	private SetterSendAST = asts SetterSendAST.
	private SideAST = asts SideAST.
	private StringAST = asts StringAST.
	private SymbolAST = asts SymbolAST.
	private TupleAST = asts TupleAST.
	private TypeIdAST = asts TypeIdAST.
	private UnaryTypeOpAST = asts UnaryTypeOpAST.
	private VarDeclAST = asts VarDeclAST.
	private VariableAST = asts VariableAST.
|) (
public class CommonParser = () (
public parseClassDeclaration: input <String> = (
	^(Parser for: input) advanceToken parseClassDeclarationEnd
)
public parseCompilationUnit: input <String> = (
	^(Parser for: input) advanceToken parseCompilationUnit
)
public parseExpression: input <String> = (
	^(Parser for: input) advanceToken parseDoItExpressionEnd
)
public parseExpressionAllowBacktick: input <String> = (
	^(Parser for: input) advanceToken parseDoItExpressionEnd
)
public parseMethodDeclaration: input <String> = (
	^(Parser for: input) advanceToken parseMethodDeclarationEnd
)
) : (
)
public class Parser for: string = Scanner for: string (
(* A recursive descent parser for Newspeak that looks up to 3 token ahead. *)
|
	protected implicitReceiver = VariableAST new name: #'@here'; start: 0; end: 0.
|) (
defaultClassSide = (
	^SideAST new
		nestedClasses: {};
		methods: {}
)
defaultConstructorPattern = (
	^MessagePatternAST new selector: #new parameters: {}; start: 1; end: 1
)
defaultSuperclassClause = (
	^UnresolvedSendAST new
		receiver:
			(UnresolvedSendAST new
				receiver: implicitReceiver;
				message: (MessageAST new send: #Object with: {}; start: 1; end: 1);
				start: 1; end: 1);
		message:
			(MessageAST new send: #new with: {}; start: 1; end: 1); start: 1; end: 1
)
expected: expectedKind = (
	^Error signal: 'Parse error: ', expectedKind, ' expected ', tokenStart printString
)
public parseAccessModifierOpt = (
	tokenKind = #identifier ifTrue:
		[tokenValue = #public ifTrue: [advanceToken. ^#public].
		 tokenValue = #protected ifTrue: [advanceToken. ^#protected].
		 tokenValue = #private ifTrue: [advanceToken. ^#private]].
	^#protected
)
public parseBinaryExpression = (
	(* binaryExpression = unaryExpression, binaryMsg star. *)
	| result message |
	
	result:: parseUnaryExpression.
	
	[peekHasBinaryMessage] whileTrue: 
		[message:: parseBinaryMessage.
		 result:: UnresolvedSendAST new
			to: result send: message;
			start: result start; end: tokenEnd].
	
	^result
)
public parseBinaryMessage = (
	(* binaryMsg = eventualSendOperator opt, binarySelector, unaryExpression. *)
	| messageStart isEventual selector argument |
	
	messageStart:: tokenStart.
	isEventual:: tokenKind = #'<-:'.
	isEventual ifTrue: [advanceToken].
	
	tokenKind = #binary ifFalse: [expected: 'binary selector'].
	selector:: tokenValue.
	advanceToken.
	argument:: parseUnaryExpression.

	^MessageAST new
		send: selector asSymbol with: {argument};
		isEventual: isEventual;
		start: messageStart; end: tokenEnd
)
public parseBinaryMessagePattern = (
	(* 	binaryMsgPattern = binarySelector, slotDecl. *)
	| patternStart selector parameter pattern returnType |
	
	tokenKind = #binary ifFalse: [expected: 'binary selector'].
	patternStart:: tokenStart.
	selector:: tokenValue asSymbol.
	advanceToken.

	parameter:: parseParameterDeclaration.
	
	tokenKind = #'^' ifTrue: [returnType:: parseReturnType].

	^MessagePatternAST new 
		selector: selector parameters: {parameter};
		returnType: returnType;
		start: patternStart; end: parameter end (* bogus *)
)
public parseCascadedMessage = (
	tokenKind = #';' ifFalse: [expected: 'semicolon'].
	advanceToken.
	peekHasUnaryMessage ifTrue: [^parseUnaryMessage].
	peekHasBinaryMessage ifTrue: [^parseBinaryMessage].
	peekHasKeywordMessage ifTrue: [^parseKeywordMessage].
	expected: 'message'.	
)
public parseCascadedMessageExpression = (
	| result message |
	result:: parseKeywordExpression.
	result isSendNode ifFalse: [^result].
	result receiver = implicitReceiver ifTrue: [^result].
	
	[tokenKind = #';'] whileTrue:
		[message:: parseCascadedMessage.
		 result:: CascadedSendAST new 
			to: result cascade: message;
			start: message start; end: message end].

	^result
)
public parseClassDeclaration = (
	(* classDeclaration = classHeader, sideDecl, classSideDecl opt *)

	| declStart header instanceSide classSide declEnd |
	declStart:: tokenStart.
	header:: parseClassHeader.
	instanceSide:: parseInstanceSide.
	tokenKind = #':'
		ifTrue: [classSide:: parseClassSide]
		ifFalse: [classSide:: defaultClassSide].
	
	^ClassDeclarationAST new
		header: header;
		instanceSide: instanceSide;
		classSide: classSide;
		start: declStart; end: 0
)
public parseClassDeclarationEnd = (
	| result = parseClassDeclaration. |
	tokenKind = #end ifFalse: [expected: 'end of input'].
	^result
)
public parseClassHeader = (
	(* classHeader = 
		(accessModifier opt, (tokenFromSymbol: #class), identifier, messagePattern, equalSign, 
		superclassClause opt, lparen, classComment opt, 
		slotDecls opt, initExprs,  rparen) |
		(accessModifier opt, (tokenFromSymbol: #class), identifier, empty, equalSign,
		superclassClause opt, lparen, classComment opt, 
		slotDecls opt,  initExprs, rparen). *)

	| declStart am name constructor superclassCall comment tempsBody inits declEnd x y |
	declStart:: tokenStart.
	am:: parseAccessModifierOpt.
	
	(tokenKind = #identifier and: [tokenValue = 'class']) ifFalse: [expected: 'class'].
	advanceToken.
	
	tokenKind = #identifier ifFalse: [expected: 'identifier'].
	name:: tokenValue.
	advanceToken.
	
	(* Cheat: skipping binary message pattern. *)
	(tokenKind = #identifier or: [tokenKind = #keyword]) 
		ifTrue: [constructor:: parseMessagePattern]
		ifFalse: [constructor:: defaultConstructorPattern].
		
	(tokenKind = #binary and: [tokenValue = '=']) ifFalse: [expected: '='].
	advanceToken.
	
	tokenKind = #identifier
		ifTrue: [superclassCall:: parseSuperclassClause]
		ifFalse: [superclassCall:: defaultSuperclassClause].

	tokenKind = #'(' ifFalse: [expected: '('].
	comment:: keepComment.
	advanceToken.
	
	tempsBody:: parseTemporariesOpt.
	
	inits:: parseInitExpressions.
	
	tokenKind = #')' ifFalse: [expected: ')'].
	declEnd:: tokenEnd.
	advanceToken.
	
	^ClassHeaderAST new
		name: name asSymbol; 
		constructor: constructor;
		superclassName: superclassCall receiver message selector;
		superclassCall: superclassCall receiver;
		superConstructorCall: superclassCall message;
		slots: tempsBody temporaries; 
		isSeq: tempsBody isSeq; 
		initExprs: inits; 
		category: 'Unclassified';
		classComment: (Token value: comment);
		inheritanceChain: {superclassCall};
		accessModifier: am;
		start: declStart; end: declEnd
)
public parseClassHeaderForName = (
	(* classHeader = 
		(accessModifier opt, (tokenFromSymbol: #class), identifier, messagePattern, equalSign, 
		superclassClause opt, lparen, classComment opt, 
		slotDecls opt, initExprs,  rparen) |
		(accessModifier opt, (tokenFromSymbol: #class), identifier, empty, equalSign,
		superclassClause opt, lparen, classComment opt, 
		slotDecls opt,  initExprs, rparen). *)

	| declStart am name constructor superclassCall comment tempsBody inits declEnd x y |
	declStart:: tokenStart.
	am:: parseAccessModifierOpt.
	
	(tokenKind = #identifier and: [tokenValue = 'class']) ifFalse: [expected: 'class'].
	advanceToken.
	
	tokenKind = #identifier ifFalse: [expected: 'identifier'].
	^(Token value: tokenValue)
		start: tokenStart; 
		end: tokenEnd.
)
public parseClassSide = (
	(* classSideDecl = colon, lparen, category star, rparen. *)
	
	| methods = List new. |

	(tokenKind = #':') ifFalse: [expected: ':'].
	advanceToken.
	
	(tokenKind = #'(') ifFalse: [expected: '('].
	advanceToken.

	[tokenKind = #')'] whileFalse: 
		[methods add: parseMethodDeclaration].

	advanceToken. (* Consume ) *)
	
	^SideAST new
		nestedClasses: {};
		methods: methods
)
public parseClosure = (
	(* block = lbracket, blockParameters opt, codeBody, rbracket. *)
	| closureStart closureEnd parameters = List new. body |

	tokenKind = #'[' ifFalse: [expected: '['].
	closureStart:: tokenStart.
	advanceToken.
	
	tokenKind = #':' ifTrue:
		[[tokenKind = #':' ifFalse: [expected: ':'].
		  advanceToken.
		  parameters add: parseParameterDeclaration.
		  tokenKind = #binary and: [tokenValue = '|']] whileFalse.
		  advanceToken].
	
	body:: parseCodeBody.
	body parameters: parameters.
	
	tokenKind = #']' ifFalse: [expected: ']'].
	closureEnd:: tokenEnd.
	advanceToken.
	
	^BlockAST new 
		body: body;
		start: closureStart; 
		end: closureEnd
)
public parseCodeBody = (
	(* codeBody = (literalMessageComment | comment | whitespace) star, temporaries opt, statements. *)
	| body statements |
	body:: parseTemporariesOpt.
	body statements: parseStatements.
	^body
)
public parseCompilationUnit = (
	(* compilationUnit = languageId, toplevelClass, eoi. *)
	| category result |
	tokenKind = #identifier ifFalse: [expected: 'identifier'].
	advanceToken.
	
	tokenKind = #string ifFalse: [expected: 'string'].
	category:: tokenValue.
	advanceToken.
	
	result:: parseClassDeclaration.
	result category: category asSymbol.
	
	tokenKind = #end ifFalse: [expected: 'end of input'].
	^result
)
public parseDoItExpressionEnd = (
	| result = parseCodeBody. |
	tokenKind = #end ifFalse: [expected: 'end of input'].
	^result
)
public parseExpression = (
	(* expression = setterKeyword star, sendExpression. *)
	| setterMessages = List new. result |
	[tokenKind = #setter] whileTrue: 
		[setterMessages add: 
			(MessageAST new
				send: tokenValue asSymbol with: nil;
				start: tokenStart; end: tokenEnd).
		 advanceToken].

	result:: parseSendExpression.
	setterMessages size to: 1 by: -1 do: 
		[:index | | setterMessage = setterMessages at: index. |
		setterMessage arguments: {result}.
		setterMessage end: result end.
		result:: SetterSendAST 
			to: implicitReceiver 
			send: setterMessage
			start: setterMessage start 
			end: setterMessage end].
	^result
)
public parseInitExpressions = (
	(* initExprs = expression starSeparatedOrTerminatedBy: dot. *)
	| statements = List new. |
	
	[(* ~FIRST(EXPRESSION) *)
	 tokenKind = #'^' ifTrue: [^statements].
	 tokenKind = #']' ifTrue: [^statements].
	 tokenKind = #')' ifTrue: [^statements].
	 tokenKind = #'}' ifTrue: [^statements].
	 tokenKind = #'.' ifTrue: [^statements].
	 tokenKind = #':' ifTrue: [^statements].
	 tokenKind = #';' ifTrue: [^statements].
	 tokenKind = #binary ifTrue: [^statements].
	 tokenKind = #end ifTrue: [^statements].

	 statements add: parseExpression.
	 tokenKind = #'.' ifTrue: [advanceToken]] repeat.
)
public parseInstanceSide = (
	(* sideDecl = lparen, classDecl star, category star, rparen. *)
	
	| nestedClasses = List new. methods = List new. member  |

	(tokenKind = #'(') ifFalse: [expected: '('].
	advanceToken.
	
	[peekHasClassDeclaration] whileTrue:
		[nestedClasses add: parseClassDeclaration].

	[tokenKind = #')'] whileFalse: 
		[methods add: parseMethodDeclaration].	

	advanceToken. (* Consume ) *)
	
	^SideAST new
		nestedClasses: nestedClasses;
		methods: methods
)
public parseKeywordExpression = (
	(* keywordExpression = binaryExpression, keywordMsg opt. *)
	| result message |
	
	result:: parseBinaryExpression.
	
	peekHasKeywordMessage ifFalse: [^result].
	
	message:: parseKeywordMessage.
	^UnresolvedSendAST new
		to: result send: message;
		start: result start; end: message end
)
public parseKeywordHereSend = (
	(* keywordHereSend = keywordMsg. *)
	| message |
	message:: parseKeywordMessage.
	^UnresolvedSendAST new
		to: implicitReceiver send: message;
		start: message start; end: message end
)
public parseKeywordMessage = (
	(* keywordMsg = eventualSendOperator opt, (keyword, binaryExpression) plus. *)
	| messageStart isEventual selector arguments = List new. |
	
	messageStart:: tokenStart.
	isEventual:: tokenKind = #'<-:'.
	isEventual ifTrue: [advanceToken].
	
	tokenKind = #keyword ifFalse: [expected: 'keyword'].
	selector:: tokenValue.
	advanceToken.
	arguments add: parseBinaryExpression.
	
	[tokenKind = #keyword] whileTrue: 
		[selector:: selector, tokenValue.
		 advanceToken.
		 arguments add: parseBinaryExpression].

	^MessageAST new
		send: selector asSymbol with: arguments asArray;
		isEventual: isEventual;
		start: messageStart; end: arguments last end
)
public parseKeywordMessagePattern = (
	(* keywordMsgPattern = (keyword, slotDecl) plus. *)
	| patternStart selector parameters = List new. returnType |
	
	tokenKind = #keyword ifFalse: [expected: 'keyword'].
	patternStart:: tokenStart.
	selector:: tokenValue.
	advanceToken.
	parameters add: parseParameterDeclaration.	
		
	[tokenKind = #keyword] whileTrue:
		[selector:: selector, tokenValue.
		 advanceToken.
		 parameters add: parseParameterDeclaration].

	tokenKind = #'^' ifTrue: [returnType:: parseReturnType].
	
	^MessagePatternAST new 
		selector: selector asSymbol parameters: parameters asArray;
		returnType: returnType;
		start: patternStart; end: parameters last end
)
public parseLiteral = (
	(* literal = pattern | number | symbolConstant | characterConstant | string | tuple. *)
	| n |
	
	tokenKind = #number ifTrue: 
		[n:: NumberAST new 
			value: tokenValue;
			start: tokenStart; end: tokenEnd.
		 advanceToken.
		 ^n].
	
	tokenKind = #binary ifTrue: 
		[tokenValue = '-' ifTrue: [
			advanceToken.
			tokenKind = 'number' ifFalse: [expected: 'number'].
			n:: NumberAST new
				value: tokenValue * -1; 
				start: tokenStart; end: tokenEnd.
		 	advanceToken.
		 	^n]].
	
	tokenKind = #symbol ifTrue: 
		[n:: SymbolAST new 
			value: tokenValue asSymbol;
			start: tokenStart; end: tokenEnd.
		 advanceToken.
		 ^n].
	
	tokenKind = #string ifTrue: 
		[n:: StringAST new
			value: tokenValue asSymbol;
			start: tokenStart; end: tokenEnd.
		 advanceToken.
		 ^n].
	
	tokenKind = #character ifTrue: 
		[n:: CharacterAST new
			value: ("a" = 'a' ifTrue: [tokenValue asSymbol] ifFalse: [tokenValue]);
			start: tokenStart; end: tokenEnd.
		 advanceToken.
		 ^n].
	
	tokenKind = #'{' ifTrue: 
		[^parseTuple].
	
	expected: 'literal'
)
public parseLiteralMessageCommentOpt = (
	[ | comment subparser pragmas = List new. pragma |
	[skipWhitespace.
	 comment:: keepComment.
	 nil = comment] whileFalse:
		[subparser:: Parser for: comment.
		 pragma:: subparser advanceToken parseLiteralMessageOpt.
		 nil = pragma ifFalse: [pragmas add: pragma]].
	pragmas isEmpty ifTrue: [^nil].
	^pragmas] on: Error do: [:e | ^nil].
)
public parseLiteralMessageOpt = (
	(* : literalmessage : unaryMessage | (keyword, literal)+ *)
	| selector arguments |
	tokenKind = #':' ifFalse: [^nil].
	advanceToken.
	tokenKind = #keyword ifFalse: [^nil].
	tokenValue = 'literalmessage:' ifFalse: [^nil].
	advanceToken.
	tokenKind = 'identifier' ifTrue: 
		[^MessageAST new send: tokenValue asSymbol with: {}].
	
	selector:: ''.
	arguments:: List new.
	[tokenKind = #end] whileFalse: 
		[tokenKind = #keyword ifFalse: [^nil].
		 selector:: selector, tokenValue.
		 advanceToken.
		 arguments add: parseLiteral].
	
	arguments isEmpty ifTrue: [^nil].
	^MessageAST new send: selector asSymbol with: arguments asArray
)
public parseMessagePattern = (
	(* messagePattern = unaryMsgPattern | binaryMsgPattern | keywordMsgPattern. *)
	
	tokenKind = #identifier ifTrue:
		[^parseUnaryMessagePattern].
	tokenKind = #binary ifTrue:
		[^parseBinaryMessagePattern].
	tokenKind = #keyword ifTrue:
		[^parseKeywordMessagePattern].

	expected: 'message pattern'.
)
public parseMethodDeclaration = (
	(* methodDecl = accessModifier opt, messagePattern, equalSign, lparen, codeBody, rparen. *)
	| declStart am pattern pragmas body declEnd |
	declStart:: tokenStart.
	am:: parseAccessModifierOpt.

	pattern:: parseMessagePattern.
	
	(tokenKind = #binary and: [tokenValue = '=']) ifFalse: [expected: '='].
	advanceToken.

	(tokenKind = #'(') ifFalse: [expected: '('].
	pragmas:: parseLiteralMessageCommentOpt.	
	advanceToken.
	
	body:: parseCodeBody.
	body literalMessages: pragmas.
	
	(tokenKind = #')') ifFalse: [expected: ')'].
	declEnd:: tokenEnd.
	advanceToken.
	
	body parameters: pattern parameters. (* asList? *)
	^MethodAST new
		pattern: pattern body: body accessModifier: am;
		start: declStart; end: declEnd
)
public parseMethodDeclarationEnd = (
	| result = parseMethodDeclaration. |
	tokenKind = #end ifFalse: [expected: 'end of input'].
	^result
)
public parseParameterDeclaration = (
	| varStart varEnd varName type result |
	tokenKind = #identifier ifFalse: [expected: 'identifier'].
	varStart:: tokenStart.
	varEnd:: tokenEnd.
	varName:: tokenValue asSymbol.
	advanceToken.

	(tokenKind = #binary and: [tokenValue = '<']) ifTrue:
		[type:: parseType].

	^(VarDeclAST name: varName type: type)
		start: varStart; end: varEnd.
)
public parseParenthesizedExpression = (
	(* parenthesizedExpression = lparen, expression, rparen. *)
	| result |
	tokenKind = #'(' ifFalse: [expected: '('].
	advanceToken.
	result:: parseExpression.	
	tokenKind = #')' ifFalse: [expected: ')'].
	advanceToken.
	^result
)
public parsePrimary = (
	(* primary = slotName | literal | block | parenthesizedExpression. *)
	| send |
	
	tokenKind = #identifier ifTrue: 
		[send:: unaryImplicitReceiverSend.
		 advanceToken.
		^send].
	
	tokenKind = #'[' ifTrue: 
		[^parseClosure].
	
	tokenKind = #'(' ifTrue: 
		[^parseParenthesizedExpression].
	
	^parseLiteral
)
public parseReturnStatement = (
	(* returnStatement = hat, expression, dot opt. *)
	| statementStart expression statementEnd |
	tokenKind = #'^' ifFalse: [expected: '^'].
	statementStart:: tokenStart.
	advanceToken.
	expression:: parseExpression.
	statementEnd:: tokenEnd.
	tokenKind = '.' ifTrue: [advanceToken].
	^ReturnStatAST new 
		expression: expression; 
		start: statementStart; end: statementEnd
)
public parseReturnType = (
	tokenKind = '^' ifFalse: [expected: '^'].
	advanceToken.
	^parseType	
)
public parseSendExpression = (
	(* sendExpression = keywordHereSend | cascadedMessageExpression. *)
	peekHasKeywordMessage ifTrue: [^parseKeywordHereSend].
	^parseCascadedMessageExpression
)
public parseSlotDeclaration = (
	(* slotDef = accessModifier opt, slotDecl, 
		(((tokenFromSymbol: #=) | (tokenFromSymbol: #'::=')), expression, dot) opt. *)
	| declStart am varStart varEnd varName type var |
	declStart:: tokenStart.
	am:: parseAccessModifierOpt.
	tokenKind = #identifier ifFalse: [expected: 'identifier'].
	varStart:: tokenStart.
	varEnd:: tokenEnd.
	varName:: tokenValue asSymbol.
	advanceToken.
	(tokenKind = #binary and: [tokenValue = '<']) ifTrue: 
		[type: parseType].
	var:: (VarDeclAST name: varName type: type)
		start: varStart; end: varEnd.
	
	tokenKind = #'::=' ifTrue: 
		[advanceToken.
		 ^MutableSlotDefAST new
			accessModifier: am;
			slotDecl: var; 
			initializer: parseSlotInitializer;
			start: declStart;
			end: tokenEnd].
		
	(tokenKind = #binary and: [tokenValue = '=']) ifTrue:
		[advanceToken.
		 ^ImmutableSlotDefAST new
			accessModifier: am;
			slotDecl: var; 
			initializer: parseSlotInitializer;
			start: declStart;
			end: tokenEnd].
	
	^MutableSlotDefAST new
		accessModifier: am;
		slotDecl: var; 
		initializer: nil;
		start: declStart;
		end: tokenEnd
)
public parseSlotInitializer = (
	(* slotDef = accessModifier opt, slotDecl, 
		(((tokenFromSymbol: #=) | (tokenFromSymbol: #'::=')), expression, dot) opt. *)
	| result |
	result:: parseExpression.
	tokenKind = #'.' ifFalse: [expected: '.'].
	advanceToken.
	^result
)
public parseStatements = (
	(* 
	furtherStatements = dot, statements.             
	statementSequence = expression, furtherStatements  opt.
 	statements = returnStatement | statementSequence | empty.
	*)
	| statements = List new. |
	
	[tokenKind = #'^' ifTrue:
		[statements add: parseReturnStatement.
		 ^statements].

	 (* ~FIRST(EXPRESSION) *)
	 tokenKind = #']' ifTrue: [^statements].
	 tokenKind = #')' ifTrue: [^statements].
	 tokenKind = #'}' ifTrue: [^statements].
	 tokenKind = #'.' ifTrue: [^statements].
	 tokenKind = #':' ifTrue: [^statements].
	 tokenKind = #';' ifTrue: [^statements].
	 tokenKind = #end ifTrue: [^statements].

	 statements add: parseExpression.
	 tokenKind = #'.' ifTrue: [advanceToken]] repeat.
)
public parseSuperclassClause = (
	(* superclassClause = superclassPrefix opt, identifier, message opt.
		outerReceiver = (tokenFromSymbol: #outer), identifier.
		superclassPrefix = outerReceiver | (tokenFromSymbol: #self) | (tokenFromSymbol: #super).	
	*)
	| clauseStart sc clauseEnd |

	tokenKind = #identifier ifFalse: [expected: 'identifier'].
	clauseStart:: tokenStart.
	
	({'self'. 'super'. 'outer'} includes: tokenValue) 
		ifFalse: [sc:: implicitReceiver]
		ifTrue:
			[sc:: VariableAST new name: tokenValue asSymbol; start: tokenStart; end: tokenEnd.
			 advanceToken.
			 sc name = #outer ifTrue:
				[tokenKind = #identifier ifFalse: [expected: 'identifier'].
				 sc:: UnresolvedSendAST new 
					receiver: sc; 
					message: 
						(MessageAST new 
							send: tokenValue asSymbol with: {}; 
							start: tokenStart; end: tokenEnd); 
	                         start: clauseStart; end: tokenEnd.
				 advanceToken]].
		
	tokenKind = #identifier ifFalse: [expected: 'identifier'].
	sc:: UnresolvedSendAST new 
		receiver: sc; 
		message: 
			(MessageAST new 
				send: tokenValue asSymbol with: {}; 
				start: tokenStart; end: tokenEnd); 
		start: clauseStart; end: tokenEnd.
	clauseEnd:: tokenEnd.
	advanceToken.
	
	^UnresolvedSendAST new
		receiver: sc;
		message: parseSuperclassMessage;
		start: clauseStart; end: clauseEnd
)
public parseSuperclassMessage = (
	tokenKind = #identifier ifTrue: [^parseUnaryMessage].
	tokenKind = #binary ifTrue: [^parseBinaryMessage].
	tokenKind = #keyword ifTrue: [^parseKeywordMessage].
	^MessageAST new send: #new with: {}; start: 1; end: 1
)
public parseTemporariesOpt = (
	| temps = List new. body |
	body:: CodeBodyAST new.
	body isSeq: true.
	body temporaries: temps.
	
	(* Also allow |||| as empty simultaneous slot declarations? *)
	
	(tokenKind = #binary and: [tokenValue = '||']) ifTrue: 
		[advanceToken.
		 tokenKind = #identifier ifFalse: [^body].
		 body isSeq: false.
		 [tokenKind = #binary and: [tokenValue = '||']] whileFalse: 
			[temps add: parseSlotDeclaration].
		 advanceToken. (* || *)
		 ^body].
	
	(tokenKind = #binary and: [tokenValue = '|']) ifTrue:
		[advanceToken.
		[tokenKind = #binary and: [tokenValue = '|']] whileFalse: 
			[temps add: parseSlotDeclaration].
		 advanceToken. (* | *)
		 ^body].
	
	^body (* No temporaries. *)
)
public parseTuple = (
	(* tuple = lcurly, (expression starSeparatedOrTerminatedBy: dot), rcurly. *)
	| tupleStart tupleEnd elements = List new. |

	tokenKind = #'{' ifFalse: [expected: '{'].
	tupleStart:: tokenStart.
	advanceToken.
	
	[tokenKind = #'}'] whileFalse: 
		[elements add: parseExpression.
		 tokenKind = #'.' ifTrue: [advanceToken]].
	
	tupleEnd:: tokenEnd.
	advanceToken. (* Consume } *)
	
	^TupleAST new elements: elements; start: tupleStart; end: tupleEnd
)
public parseType = (
	(* :todo: We're just diet parsing here. Do real parsing. *)
	
	(tokenKind = #binary and: [tokenValue = '<']) ifFalse: 
		[expected: '<'].
	advanceToken.
	
	[tokenKind = #end] whileFalse: 
		[
		(tokenKind = #binary and: [tokenValue = '>']) ifTrue: 
			[advanceToken. ^nil].
		advanceToken].

	expected: '>'
)
public parseUnaryExpression = (
	(* unaryExpression = primary, unaryMsg star. *)
	| result message |
	
	result:: parsePrimary.
	
	[peekHasUnaryMessage] whileTrue: 
		[message:: parseUnaryMessage.
		 result:: UnresolvedSendAST new
			to: result send: message;
			start: result start; end: message end].
	
	^result
)
public parseUnaryMessage = (
	(* unaryMsg = eventualSendOperator opt, unarySelector. *)
	| messageStart isEventual message |
		
	messageStart:: tokenStart.
	isEventual:: tokenKind = #'<-:'.
	isEventual ifTrue: [advanceToken].
	
	tokenKind = #identifier ifFalse: [expected: 'unary selector'].
	
	message:: MessageAST new
		send: tokenValue asSymbol with: {};
		isEventual: isEventual;
		start: messageStart; end: tokenEnd.
	advanceToken.
	^message
)
public parseUnaryMessagePattern = (
	(* unaryMsgPattern = unarySelector. *)
	| pattern |
	
	tokenKind = #identifier ifFalse: [expected: 'unary selector'].
	
	pattern:: MessagePatternAST new 
		selector: tokenValue asSymbol parameters: {};
		start: tokenStart; end: tokenEnd.
	advanceToken.
	
	tokenKind = #'^' ifTrue: [pattern returnType: parseReturnType].
	
	^pattern	
)
peekHasAccessModifier = (
	(* LL(1) *)
	tokenKind = #identifier ifFalse: [^false].
	tokenValue = #public ifTrue: [^true].
	tokenValue = #protected ifTrue: [^true].
	tokenValue = #private ifTrue: [^true].
	^false
)
peekHasBinaryMessage = (
	(* LL(2) *)
	| context result |
	tokenKind = #binary ifTrue: [^true].
	tokenKind = #'<-:' ifFalse: [^false].
	
	(* Unlikely *)
	context:: saveContext.
	advanceToken. (* Consume <-: *)
	result:: tokenKind = #binary.
	restoreContext: context.
	^result
)
peekHasClassDeclaration = (
	(* LL(3) *)
	(* classHeader = (accessModifier opt, (tokenFromSymbol: #class), identifier, ... *)

	| context = saveContext. |
	peekHasAccessModifier ifTrue: [advanceToken].
	
	(tokenKind = #identifier and: [tokenValue = 'class']) ifFalse: 
		[restoreContext: context.
		 ^false].
	advanceToken.
	
	tokenKind = #identifier ifFalse: 
		[restoreContext: context.
		 ^false].
	
	restoreContext: context.
	^true
)
peekHasKeywordMessage = (
	(* LL(2) *)
	| context result |
	tokenKind = #keyword ifTrue: [^true].
	tokenKind = #'<-:' ifFalse: [^false].
	
	(* Unlikely *)
	context:: saveContext.
	advanceToken. (* Consume <-: *)
	result:: tokenKind = #keyword.
	restoreContext: context.
	^result
)
peekHasUnaryMessage = (
	(* LL(2) *)
	| context result |
	tokenKind = #identifier ifTrue: [^true].
	tokenKind = #'<-:' ifFalse: [^false].
	
	(* Unlikely *)
	context:: saveContext.
	advanceToken. (* Consume <-: *)
	result:: tokenKind = #identifier.
	restoreContext: context.
	^result
)
unaryImplicitReceiverSend = (
	| selector = tokenValue asSymbol. message |
	selector = #self ifFalse: 
		[selector = #super ifFalse:
			[selector = #outer ifFalse:
				[message:: MessageAST new
					send: selector with: {};
					start: tokenStart; end: tokenEnd.
				^UnresolvedSendAST new 
					to: implicitReceiver send: message;
                          	start: tokenStart; end: tokenEnd]]].
	
	^VariableAST new name: selector; start: tokenStart; end: tokenEnd.
)
) : (
)
public class Scanner for: string = (
(* Turns Newspeak source into a stream of tokens.

The current token is available via #tokenKind, #tokenValue, #tokenStart, and #tokenEnd.

Frequency of Newspeak tokens:

#identifier 137832
#keyword 57744
#binary 54283
#'.' 25339
#'(' 23920
#')' 23920
#'[' 12090
#']' 12090
#'^' 11228
#number 10767
#string 6080
#setter 5520
#':' 5172
#';' 2253
#symbol 2015
#'{' 1477
#'}' 1477
#character 500
#'::=' 497
#'<-:' 161

*)|
	private input <String> = string.
	private size <Integer> = string size.
	private position <Integer> ::= 1. (* Index of the next rune to scan. *)

	public tokenStart <Integer> ::= 0.
	public tokenKind <Symbol>
	public tokenValue (* The evaluated token, not it's substring in the source. *)
|) (
public advanceToken = (
	| rune |
	skipWhitespaceAndComments.
	tokenStart:: position.
	tokenValue:: nil.
	position <= size ifFalse: 
		[tokenKind:: #end.
		 ^self].
	rune:: input runeAt: position.
	position:: position + 1.
	
	(isLetterOrUnderscore: rune) ifTrue:
		[^self scanIdentifierOrKeyword].
	(isSpecialCharacter: rune) ifTrue:
		[^self scanBinarySelector].
	(isDecimalDigit: rune) ifTrue:
		[^self scanNumber].

	rune = 58 ifTrue: [
		position + 1 <= size ifTrue:
			[(input runeAt: position) = 58 ifTrue: 
				[(input runeAt: position + 1) = 61 ifTrue: 
					[position:: position + 2.
					 tokenKind:: #'::='.
					 ^self]]].
		tokenKind:: #':'.
		^self].
	
	rune = 34 ifTrue: [^self scanCharacter].
	rune = 35 ifTrue: [^self scanSymbol].
	rune = 39 ifTrue: [^self scanString].	
	rune = 40 ifTrue: [tokenKind:: #'('. ^self].
	rune = 41 ifTrue: [tokenKind:: #')'. ^self].	
	rune = 46 ifTrue: [tokenKind:: #'.'. ^self].
	rune = 59 ifTrue: [tokenKind:: #';'. ^self].
	rune = 91 ifTrue: [tokenKind:: #'['. ^self].
	rune = 93 ifTrue: [tokenKind:: #']'. ^self].
	rune = 94 ifTrue: [tokenKind:: #'^'. ^self].
	rune = 123 ifTrue: [tokenKind:: #'{'. ^self].
	rune = 125 ifTrue: [tokenKind:: #'}'. ^self].

	scanError
)
private extendedDigitValue: rune = (
	rune <= 57 ifTrue: [^rune - 48].
	^rune - 55
)
private isAlphanumOrUnderscore: rune = (
	rune >= 97 ifTrue: [rune <= 122 ifTrue: [^true]].
	rune >= 65 ifTrue: [rune <= 90 ifTrue: [^true]].
	rune >= 48 ifTrue: [rune <= 57 ifTrue: [^true]].
	^rune = 95
)
private isDecimalDigit: rune = (
	rune >= 48 ifTrue: [rune <= 57 ifTrue: [^true]].
	^false
)
private isExtendedDigit: rune = (
	rune >= 48 ifTrue: [rune <= 57 ifTrue: [^true]].
	rune >= 65 ifTrue: [rune <= 90 ifTrue: [^true]].
	^false
)
private isLetterOrUnderscore: rune = (
	rune >= 97 ifTrue: [rune <= 122 ifTrue: [^true]].
	rune >= 65 ifTrue: [rune <= 90 ifTrue: [^true]].
	^rune = 95
)
private isSpecialCharacter: rune = (
	rune = 33 ifTrue: [^true]. (* ! *)
	rune = 37 ifTrue: [^true]. (* % *)
	rune = 38 ifTrue: [^true]. (* & *)
	rune = 42 ifTrue: [^true]. (* * *)
	rune = 43 ifTrue: [^true]. (* + *)
	rune = 44 ifTrue: [^true]. (* , *)
	rune = 45 ifTrue: [^true]. (* - *)
	rune = 47 ifTrue: [^true]. (* / *)
	rune = 60 ifTrue: [^true]. (* < *)
	rune = 61 ifTrue: [^true]. (* = *)
	rune = 62 ifTrue: [^true]. (* > *)
	rune = 63 ifTrue: [^true]. (* ? *)
	rune = 64 ifTrue: [^true]. (* @ *)
	rune = 92 ifTrue: [^true]. (* \ *)
	rune = 124 ifTrue: [^true]. (* | *)	
	rune = 126 ifTrue: [^true]. (* ~ *)	
	^false
)
protected keepComment = (
	| commentStart |
	skipWhitespace.
	commentStart:: position.
	skipComment ifFalse: [^nil].
	^input copyFrom: commentStart + 2 to: position - 1 - 2
)
private peekHasRadix = (
	position + 1 <= size ifFalse: [^false].
	(input runeAt: position) = 114 ifFalse: [^false].
	^isExtendedDigit: (input runeAt: position + 1)
)
protected restoreContext: context = (
	position:: context.
	advanceToken.
)
protected saveContext = (
	^tokenStart
)
private scanBinarySelector = (
	[position <= size and: [isSpecialCharacter: (input runeAt: position)]]
		whileTrue: [position:: position + 1].

	tokenValue:: input copyFrom: tokenStart to: position - 1.
	tokenKind:: #binary.
	
	(* Check for a longer match as the eventual send operator. *)
	tokenValue = #'<-' ifFalse: [^self].
	position <= size ifFalse: [^self].
	(input runeAt: position) = 58 ifTrue: 
		[position:: position + 1.
		 tokenValue:: nil.
		 tokenKind:: #'<-:'].
)
private scanCharacter = (
	position + 1 <= size ifFalse: [scanError: 'Unterminated character literal'].
	(input runeAt: position + 1) = 34 ifFalse: [scanError: 'Unterminated character literal'].
	
	tokenKind:: #character.
	tokenValue:: input at: position.
	position:: position + 2.
)
private scanError: message = (
	^Error signal: 'Parse error: ', message, ' ', position printString
)
private scanIdentifierOrKeyword = (
	| 
	pos ::= position.
	in = input.
	sz = size.
	|
	[pos <= sz ifFalse: [false] ifTrue: [isAlphanumOrUnderscore: (in runeAt: pos)]]
		whileTrue: [pos:: pos + 1].
	
	pos <= sz ifTrue: 
		[(in runeAt: pos) = 58 ifTrue:
			[tokenValue:: in copyFrom: tokenStart to: pos.
			 pos + 1 <= sz ifTrue: 
				[(input runeAt: pos + 1) = 58 ifTrue:
					[position:: pos + 2.
					 tokenKind:: #setter.
					 ^self]].
			position:: pos + 1.
			tokenKind:: #keyword.
			^self]].
	
	position:: pos.
	tokenValue:: input copyFrom: tokenStart to: pos - 1.
	tokenKind:: #identifier.
)
private scanMaybeExponent ^<Integer> = (
	| neg exp rune |
	position + 1 <= size ifFalse: [^1].
	(input runeAt: position) = 101 ifFalse: [^1].
	
	neg:: (input runeAt: position + 1) = 45.
	neg 
		ifTrue:
			[position + 2 <= size ifFalse: [^1].
			 (isDecimalDigit: (input runeAt: position + 2)) ifFalse: [^1].
			 position:: position + 2 (* Consume 'e-' *)]
		ifFalse:
			[(isDecimalDigit: (input runeAt: position + 1)) ifFalse: [^1].
			 position:: position + 1 (* Consume 'e' *)].

	exp:: 0.
	[position <= size and: [isDecimalDigit: (rune:: input runeAt: position)]]
		whileTrue: 
			[exp:: exp * 10 + (rune - 48).
			 position:: position + 1].

	neg ifTrue: [exp:: exp * -1].
	^10 ** exp
)
private scanMaybeFraction: radix <Integer> ^<Fraction> = (
	| numerator denominator rune digit |

	position + 1 <= size ifFalse: [^0].
	(input runeAt: position) = 46 ifFalse: [^0].
	(isExtendedDigit: (input runeAt: position + 1)) ifFalse: [^0].
	
	numerator:: 0.
	denominator:: 1.
	position:: position + 1. (* Consume '.' *)
	[position <= size and: [isExtendedDigit: (rune:: input runeAt: position)]]
		whileTrue: 
			[digit:: extendedDigitValue: rune.
			 digit < radix ifFalse: [scanError: 'Digit exceeds radix'].
			 numerator:: numerator * radix + digit.
			 denominator:: denominator * radix.
			 position:: position + 1].

	^numerator / denominator
)
private scanNumber = (
	(* '-'? decdigits+ [. decdigits?] ['e' '-'?' decdigit+] *)
	(* decdigit+ 'r' '-'? hexdigits+ [. hexdigits?] ['e' '-'?' decdigit+] *)
	
	| val rune radix digit |
	val:: (input runeAt: position - 1) - 48.
	
	[position <= size and: [isDecimalDigit: (rune:: input runeAt: position)]]
		whileTrue: 
			[val:: val * 10 + (rune - 48).
			 position:: position + 1].
	
	radix:: 10.
	peekHasRadix ifTrue:
		[radix:: val.
		 val:: 0.
		 position:: position + 1. (* Consume "r" *)
		 [position <= size and: [isExtendedDigit: (rune:: input runeAt: position)]]
			whileTrue: 
				[digit:: extendedDigitValue: rune.
				 digit < radix ifFalse: [scanError: 'Digit exceeds radix'].
				 val:: val * radix + digit.
				 position:: position + 1]].

	val:: val + (scanMaybeFraction: radix).
	val:: val * scanMaybeExponent.

	tokenKind:: #number.
	tokenValue:: val.	
)
private scanString = (
	| runes = List new. rune |
	tokenKind:: #string.
	[position <= size] whileTrue:
		[(rune:: input runeAt: position) = 39 ifTrue: 
			[position:: position + 1.
			 position <= size ifFalse:
				[tokenValue:: String fromRunes: runes. ^self].
			(input runeAt: position) = 39 ifFalse:
				[tokenValue:: String fromRunes: runes. ^self].
			(* Escaped single quote *)].
		runes add: rune.
		position:: position + 1].
	
	scanError: 'Unterminated string literal'
)
private scanSymbol = (
	| rune |
	position <= size ifFalse: 
		[scanError: 'Unterminated symbol literal'].
	rune:: input runeAt: position.
	position:: position + 1.
	rune = 39 ifTrue:
		[self scanString.
		 tokenKind:: #symbol.
		 ^self].
	(isSpecialCharacter: rune) ifTrue: 
		[self scanBinarySelector.
		 tokenKind:: #symbol.
		 tokenValue:: input copyFrom: tokenStart + 1 to: tokenEnd.
		 ^self].
	
	(isLetterOrUnderscore: rune) ifTrue:
		[^scanSymbolUnaryOrKeyword].
		
	scanError: 'Invalid symbol literal'
)
private scanSymbolUnaryOrKeyword = (
	tokenKind:: #symbol.
	[position <= size and: [isAlphanumOrUnderscore: (input runeAt: position)]]
		whileTrue: [position:: position + 1].
		
	position <= size ifFalse: 
		[tokenValue:: input copyFrom: tokenStart + 1 to: tokenEnd.
		 ^self].
	
	(input runeAt: position) = 58 ifFalse: 
		[tokenValue:: input copyFrom: tokenStart + 1 to: tokenEnd.
		 ^self].
	position:: position + 1. (* Consume : *)
	
	(* Keyword selector *)
	[position <= size and: [isAlphanumOrUnderscore: (input runeAt: position)]] 
		whileTrue:
			[[position <= size and: [isAlphanumOrUnderscore: (input runeAt: position)]]
				whileTrue: [position:: position + 1].
			 position <= size ifFalse: 
				[scanError: 'Unterminated symbol literal'].
			 (input runeAt: position) = 58 ifFalse: 
				[scanError: 'Unterminated symbol literal'].
			 position:: position + 1 (* Consume : *)].
	
	tokenValue:: input copyFrom: tokenStart + 1 to: tokenEnd.
)
private skipComment = (
	position + 1 <= size ifFalse: [^false].
	(input runeAt: position) = 40 (* ( *) ifFalse: [^false].
	(input runeAt: position + 1) = 42 (* * *) ifFalse: [^false].
	position:: position + 2.
	
	[position + 1 <= size] whileTrue: 
		[(* End of comment. *)
		(input runeAt: position) = 42 (* * *) ifTrue:
			[(input runeAt: position + 1) = 41 (* ) *) ifTrue: 
				[position: position + 2. ^true]].
	
		(* Nested comment. *)
		(input runeAt: position) = 40 (* ( *) ifTrue:
			[(input runeAt: position + 1) = 42 (* * *) ifTrue: 
				[skipComment.
				 position:: position - 1]].

		position:: position + 1].
	
	scanError: 'Unterminated comment'
)
protected skipWhitespace = (
	[position <= input size] whileTrue: 
		[(input runeAt: position) <= 32 ifFalse: [^self].
		 position:: position + 1].
)
private skipWhitespaceAndComments = (
	| outerLoopPosition ::= 0. |
	[outerLoopPosition = position] whileFalse: 
		[outerLoopPosition:: position.
		 [position <= input size 
			ifFalse: [false] 
			ifTrue: [(input runeAt: position) <= 32]] 
				whileTrue: [position:: position + 1].
		 skipComment].
)
public tokenEnd = (
	^position - 1
)
) : (
)
class Token value: v = (
(* Only used for class comments, where the AST expects a CombinatorialParsing-style Token. *)
|
public value = v.
public start
public end
|) (
) : (
)
) : (
)

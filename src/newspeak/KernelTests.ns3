Newspeak3
'Newspeak'
class KernelTests usingPlatform: p minitest: m = (|
private TestContext = m TestContext.
private MessageNotUnderstood = p kernel MessageNotUnderstood.
private Exception = p kernel Exception.
private Stopwatch = p kernel Stopwatch.
|) (
public class ArrayTests = TestContext () (
'as yet unclassified'
public testArrayAsArray = (
	| array = Array new: 3. |	
	assert: array asArray equals: array.
)
public testArrayAt = (
	| array = Array new: 2. empty = Array new: 0. |
	array at: 1 put: 'apple'.
	array at: 2 put: 'banana'.
	
	assert: (array at: 1) equals: 'apple'.
	assert: (array at: 2) equals: 'banana'.
	should: [array at: 0] signal: Error.
	should: [array at: 3] signal: Error.
	should: [array at: -3] signal: Error.
	should: [array at: nil] signal: Error.
	
	should: [empty at: 1] signal: Error.
)
public testArrayAtPut = (
	| array = Array new: 2. empty = Array new: 0. |
	assert: (array at: 1 put: 'apple') equals: 'apple'.
	assert: (array at: 2 put: 'banana') equals: 'banana'.
	should: [array at: 0 put: 'orange'] signal: Error.
	should: [array at: 3 put: 'orange'] signal: Error.
	should: [array at: -3 put: 'orange'] signal: Error.
	should: [array at: nil put: 'orange'] signal: Error.
	
	should: [empty at: 1 put: 'orange'] signal: Error.
)
public testArrayConcatenation = (
	| 
	a = Array new: 1.
	b = Array new: 3.
	c
	|
	a at: 1 put: 'apple'.
	b at: 1 put: 'banana'.
	b at: 2 put: 'orange'.
	b at: 3 put: 'strawberry'.
	c:: a, b.
	
	assert: c isArray.
	assert: c size equals: 4.
	assert: (c at: 1) equals: 'apple'.
	assert: (c at: 2) equals: 'banana'.
	assert: (c at: 3) equals: 'orange'.
	assert: (c at: 4) equals: 'strawberry'.
)
public testArrayEqualityIsIdentity = (
	|
	empty1 = Array new: 0.
	empty2 = Array new: 0.
	simple1 = Array new: 1.
	simple2 = Array new: 1.
	cycle1 = Array new: 1.
	cycle2 = Array new: 1.
	|
	simple1 at: 1 put: 42.
	simple2 at: 1 put: 42.
	cycle1 at: 1 put: cycle1.
	cycle2 at: 1 put: cycle2.
		
	assert: empty1 equals: empty1.
	assert: empty2 equals: empty2.
	deny: empty1 equals: empty2.
	deny: empty2 equals: empty1.
	
	assert: simple1 equals: simple1.
	assert: simple2 equals: simple2.
	deny: simple1 equals: simple2.
	deny: simple2 equals: simple1.

	assert: cycle1 equals: cycle1.
	assert: cycle2 equals: cycle2.
	deny: cycle1 equals: cycle2.
	deny: cycle2 equals: cycle1.
)
public testArrayFirstLast = (
	| array = Array new: 2. empty = Array new: 0. |
	array at: 1 put: 'apple'.
	array at: 2 put: 'banana'.
	
	assert: (array first) equals: 'apple'.
	assert: (array last) equals: 'banana'.

	should: [empty first] signal: Error.
	should: [empty last] signal: Error.
)
public testArrayFloatIndex = (
	| array = Array new: 1. |
	should: [array at: 1 asFloat] signal: Error.
	should: [array at: 1 asFloat put: 'apple'] signal: Error.
)
public testArrayIndexOf = (
	| array = Array new: 6. empty = Array new: 0. |
	array at: 1 put: 42.
	array at: 2 put: nil.
	array at: 3 put: 'apple'.
	array at: 4 put: 'banana'.
	array at: 5 put: 'apple'.
	array at: 6 put: 'banana'.
	
	assert: (array indexOf: 42) equals: 1.
	assert: (array indexOf: nil) equals: 2.
	assert: (array indexOf: 'apple') equals: 3.
	assert: (array indexOf: 'banana') equals: 4.
	assert: (array indexOf: 'noSuchElement') equals: 0.

	assert: (empty indexOf: 'noSuchElement') equals: 0.
)
public testArrayIsEmpty = (
	assert: (Array new: 0) isEmpty.
	deny: (Array new: 1) isEmpty.
)
public testArrayNew = (
	assert: (Array new: 0) size equals: 0.
	assert: (Array new: 500) size equals: 500.	

	should: [Array new: -1] signal: Error.
	should: [Array new: '10'] signal: Error.
	should: [Array new: nil] signal: Error.
	should: [Array new] signal: MessageNotUnderstood.
)
public testIsArray = (
	assert: (Array new: 0) isArray.
	deny: (ByteArray new: 0) isArray.
	deny: 0 isArray.
	deny: 1.5 isArray.
	deny: 'Array new' isArray.
	deny: nil isArray.
)
) : (
'as yet unclassified'
TEST_CONTEXT = ()
)
public class BehaviorTests = TestContext () (
'as yet unclassified'
public testBehaviorBasicNew = (
	should: [Object basicNew] signal: MessageNotUnderstood.
	
	(* :todo: basicNew should also fail from a class-side method. *)
)
public testBehaviorInternalsAreHidden = (
	(* Squeak, JS *)
	should: [Object superclass] signal: MessageNotUnderstood.
	should: [Object methodDictionary] signal: MessageNotUnderstood.
	should: [Object mixin] signal: MessageNotUnderstood.
	should: [Object enclosingObject] signal: MessageNotUnderstood.
	should: [Object format] signal: MessageNotUnderstood.

	(* PrimordialSoup *)
	should: [Object _superclass] signal: MessageNotUnderstood.
	should: [Object _methods] signal: MessageNotUnderstood.
	should: [Object _enclosingObject] signal: MessageNotUnderstood.
	should: [Object _mixin] signal: MessageNotUnderstood.
	should: [Object _classIndex] signal: MessageNotUnderstood.
	should: [Object _format] signal: MessageNotUnderstood.
)
public testBehaviorName = (
	(* :todo: Which to we want? *)
	(* should: [Object name] signal: MessageNotUnderstood.
	assert: Object name equals: 'Object'.
	assert: Object name equals: 'KernelForImplementation`Object'. *)
)
public testIsBehavior = (
	(* :todo: Which to we want? *)
	(* deny: Object isBehavior.
	assert: Object isBehavior. *)
)
) : (
'as yet unclassified'
TEST_CONTEXT = ()
)
public class BooleanTests = TestContext () (
'as yet unclassified'
public testBooleanAsString = (
	assert: true asString equals: 'true'.
	assert: false asString equals: 'false'.
)
public testBooleanEvaluatingConjuction = (
	assert: true & true.
	deny: true & false.
	deny: false & true.
	deny: false & false.
)
public testBooleanEvaluatingDisjuction = (
	assert: true | true.
	assert: true | false.
	assert: false | true.
	deny: false | false.
)
public testBooleanNonEvaluatingConjuction = (
	assert: (true and: [true]).
	deny: (true and: [false]).
	deny: (false and: [doesNotExecute]).
)
public testBooleanNonEvaluatingDisjuction = (
	assert: (true or: [doesNotExecute]).
	assert: (false or: [true]).
	deny: (false or: [false]).
)
public testBooleanNot = (
	deny: true not.
	assert: false not.
)
public testBooleanPrintString = (
	assert: true printString equals: 'true'.
	assert: false printString equals: 'false'.
)
) : (
'as yet unclassified'
TEST_CONTEXT = ()
)
public class ByteArrayTests = TestContext () (
'as yet unclassified'
public testByteArrayAt = (
	| array = ByteArray new: 2. empty = ByteArray new: 0. |
	array at: 1 put: 3.
	array at: 2 put: 4.
	
	assert: (array at: 1) equals: 3.
	assert: (array at: 2) equals: 4.
	should: [array at: 0] signal: Error.
	should: [array at: 3] signal: Error.
	should: [array at: -3] signal: Error.
	should: [array at: nil] signal: Error.
	
	should: [empty at: 1] signal: Error.
)
public testByteArrayAtPut = (
	| array = ByteArray new: 2. empty = ByteArray new: 0. |
	assert: (array at: 1 put: 3) equals: 3.
	assert: (array at: 2 put: 4) equals: 4.
	should: [array at: 0 put: 5] signal: Error.
	should: [array at: 3 put: 6] signal: Error.
	should: [array at: -3 put: 7] signal: Error.
	should: [array at: nil put: 8] signal: Error.

	assert: (array at: 1 put: 0) equals: 0.
	assert: (array at: 2 put: 255) equals: 255.
	should: [array at: 1 put: -1] signal: Error.
	should: [array at: 1 put: 256] signal: Error.
	
	should: [empty at: 1 put: 9] signal: Error.
)
public testByteArrayFloatIndex = (
	| array = ByteArray new: 1. |
	should: [array at: 1 asFloat] signal: Error.
	should: [array at: 1 asFloat put: 0] signal: Error.
)
public testByteArrayIsEmpty = (
	assert: (ByteArray new: 0) isEmpty.
	deny: (ByteArray new: 1) isEmpty.
)
public testByteArrayLargeAllocation = (
	| size = 8 * 1024 * 1024. |
	assert: (ByteArray new: size) size equals: size.	
	assert: (ByteArray new: size) size equals: size.	
	assert: (ByteArray new: size) size equals: size.	
)
public testByteArrayNew = (
	assert: (ByteArray new: 0) size equals: 0.
	assert: (ByteArray new: 500) size equals: 500.	

	should: [ByteArray new: -1] signal: Error.
	should: [ByteArray new: '10'] signal: Error.
	should: [ByteArray new: nil] signal: Error.
	should: [ByteArray new] signal: MessageNotUnderstood.
)
public testIsByteArray = (
	assert: (ByteArray new: 0) isByteArray.
	deny: (Array new: 0) isByteArray.
	deny: 0 isByteArray.
	deny: 1.5 isByteArray.
	deny: 'Array new' isByteArray.
	deny: nil isByteArray.
)
) : (
'as yet unclassified'
TEST_CONTEXT = ()
)
public class ClosureTests = TestContext () (
'as yet unclassified'
cannotReturn = (
	^[^42]
)
ensure1 = (
	[^'try-block'] ensure: [^'ensure-block'].
	^'afterward'
)
ensure2 = (
	^['try-block'] ensure: ['ensure-block'].
)
ensure3 = (
	[^'try-block'] ensure: ['ensure-block'].
	^'afterward'
)
public testCannotReturn = (
	should: [cannotReturn value] signal: Error.
)
public testCull = (
	assert: ([42] cull: 7) equals: 42.
	assert: ([42] cull: 7 cull: 9) equals: 42.
	assert: ([42] cull: 7 cull: 9 cull: 11) equals: 42.
	
	assert: ([:a | a] cull: 7) equals: 7.
	assert: ([:a | a] cull: 7 cull: 9) equals: 7.
	assert: ([:a | a] cull: 7 cull: 9 cull: 11) equals: 7.
	
	should: [[:a :b | a + b] cull: 7] signal: Error.
	assert: ([:a :b | a + b] cull: 7 cull: 9) equals: 16.
	assert: ([:a :b | a + b] cull: 7 cull: 9 cull: 11) equals: 16.
	
	should: [[:a :b :c | a + b + c] cull: 7] signal: Error.
	should: [[:a :b :c | a + b + c] cull: 7 cull: 9] signal: Error.
	assert: ([:a :b :c | a + b + c] cull: 7 cull: 9 cull: 11) equals: 27.
)
public testEnsure = (
	assert: ensure1 equals: 'ensure-block'.
	assert: ensure2 equals: 'try-block'.
	assert: ensure3 equals: 'try-block'.
	
)
public testIsClosure = (
	assert: [3 + 4] isClosure.
	deny: (3 + 4) isClosure.
	deny: {3 + 4} isClosure.
)
public testNumArgs = (
	assert: [3 + 4] numArgs equals: 0.
	assert: [:x | x + 4] numArgs equals: 1.
	assert: [:x :y | x + y] numArgs equals: 2.
)
public testValue = (
	assert: [3 - 4] value equals: -1.
	assert: ([:x | x - 4] value: 14) equals: 10.
	assert: ([:x :y | x - y] value: 42 value: 24) equals: 18.
	assert: ([:x :y :z | x - y + z] value: 13 value: 3 value: 1) equals: 11.
)
public testValueTooFew = (
	should: [[:x | x - 4] value] signal: Error.
	should: [[:x :y | x - y] value: 1] signal: Error.
	should: [[:x :y :z | 3 - 4] value: 1 value: 2] signal: Error.
)
public testValueTooMany = (
	should: [[3 - 4] value: 1] signal: Error.
	should: [[:x | x - 4] value: 1 value: 2] signal: Error.
	should: [[:x :y | x - y] value: 1 value: 2 value: 3] signal: Error.
)
public testValueWithArguments = (
	(* Should this be called apply: ? *)

	assert: ([3 - 4] valueWithArguments: {}) equals: -1.
	assert: ([:x | x - 4] valueWithArguments: {14}) equals: 10.
	assert: ([:x :y | x - y] valueWithArguments: {42. 24}) equals: 18.
	assert: ([:x :y :z | x - y + z] valueWithArguments: {13. 3. 1}) equals: 11.
)
public testValueWithArgumentsTooFew = (
	should: [[:x | x - 4] valueWithArguments: {}] signal: Error.
	should: [[:x :y | x - y] valueWithArguments: {1}] signal: Error.
	should: [[:x :y :z | x - y + z] valueWithArguments: {1. 2}] signal: Error.
)
public testValueWithArgumentsTooMany = (
	should: [[3 - 4] valueWithArguments: {1}] signal: Error.
	should: [[:x | x - 4] valueWithArguments: {1. 2}] signal: Error.
	should: [[:x :y | x - y] valueWithArguments: {1. 2. 3}] signal: Error.
	should: [[:x :y :z | x - y + z] valueWithArguments: {1. 2. 3. 4}] signal: Error.
)
) : (
'as yet unclassified'
TEST_CONTEXT = ()
)
class DnuAnswerMessage = () (
'as yet unclassified'
protected doesNotUnderstand: message = (
	^message
)
) : (
)
public class ExceptionTests = TestContext () (
'as yet unclassified'
public testExceptionHandled = (
	|
	beforeSignal ::= false.
	afterSignal ::= false.
	handler ::= false.
	exceptionSignaled
	exceptionHandled
	result
	|
	
	result:: 
		[beforeSignal:: true.
		 exceptionSignaled:: Exception new.
		 exceptionSignaled signal.
		 afterSignal:: true.
		 42] 
			on: Exception 
			do: [:ex | handler:: true. exceptionHandled:: ex. 84].
			
	assert: beforeSignal.
	deny: afterSignal.
	assert: handler.
	assert: exceptionSignaled equals: exceptionHandled.
	assert: result equals: 84.
)
public testExceptionInvalidPass = (
	| ex |

	(* Already handled. *)
	ex:: Exception new.
	[ex signal] on: Exception do: [:e | ].
	should: [ex pass] signal: Error.
	
	(* Already resumed. *)
	ex:: Exception new.
	[ex signal] on: Exception do: [:e | e resume: 42].
	should: [ex pass] signal: Error.
	
	(* Already returned. *)
	ex:: Exception new.
	[ex signal] on: Exception do: [:e | e return: 42].
	should: [ex pass] signal: Error.
	
	(* Never signaled. *)
	ex:: Exception new.
	should: [ex pass] signal: Error.
)
public testExceptionInvalidResume = (
	| ex |

	(* Already handled. *)
	ex:: Exception new.
	[ex signal] on: Exception do: [:e | ].
	should: [ex resume: 84] signal: Error.
	
	(* Already resumed. *)
	ex:: Exception new.
	[ex signal] on: Exception do: [:e | e resume: 42].
	should: [ex resume: 84] signal: Error.
	
	(* Already returned. *)
	ex:: Exception new.
	[ex signal] on: Exception do: [:e | e return: 42].
	should: [ex resume: 84] signal: Error.
	
	(* Never signaled. *)
	ex:: Exception new.
	should: [ex resume: 84] signal: Error.
)
public testExceptionInvalidReturn = (
	| ex |

	(* Already handled. *)
	ex:: Exception new.
	[ex signal] on: Exception do: [:e | ].
	should: [ex return: 84] signal: Error.
	
	(* Already resumed. *)
	ex:: Exception new.
	[ex signal] on: Exception do: [:e | e resume: 42].
	should: [ex return: 84] signal: Error.
	
	(* Already returned. *)
	ex:: Exception new.
	[ex signal] on: Exception do: [:e | e return: 42].
	should: [ex return: 84] signal: Error.
	
	(* Never signaled. *)
	ex:: Exception new.
	should: [ex return: 84] signal: Error.
)
public testExceptionPass = (
	|
	beforeSignal ::= false.
	afterSignal ::= false.
	afterInnerTry ::= false.
	outerHandler ::= false.
	innerHandler ::= false.
	afterPass ::= false.
	|
	

	[
		[
			beforeSignal:: true.
			Exception new signal.
			afterSignal:: true.
		] on: Exception do: 
			[:ex | 
			innerHandler:: true.
			ex pass.
			afterPass:: true].
		afterInnerTry:: true.
	] on: Exception do: [:ex | outerHandler:: true].
			
	assert: beforeSignal.
	deny: afterSignal.
	assert: innerHandler.
	deny: afterPass.
	deny: afterInnerTry.
	assert: outerHandler.
)
public testExceptionResume = (
	|
	beforeSignal ::= false.
	afterSignal ::= false.
	handler ::= false.
	afterResume ::= false.
	exceptionSignaled
	exceptionHandled
	signalResult
	result
	|
	
	result:: 
		[beforeSignal:: true.
		 exceptionSignaled:: Exception new.
		 signalResult:: exceptionSignaled signal.
		 afterSignal:: true.
		 42] 
			on: Exception 
			do: 
				[:ex | 
				handler:: true. 
				exceptionHandled:: ex. 
				ex resume: 63.
				afterResume:: true.
				84].
			
	assert: beforeSignal.
	assert: afterSignal.
	assert: handler.
	deny: afterResume.
	assert: exceptionSignaled equals: exceptionHandled.
	assert: signalResult equals: 63.
	assert: result equals: 42.
)
public testExceptionReturn = (
	|
	beforeSignal ::= false.
	afterSignal ::= false.
	handler ::= false.
	afterReturn ::= false.
	exceptionSignaled
	exceptionHandled
	signalResult
	result
	|
	
	result:: 
		[beforeSignal:: true.
		 exceptionSignaled:: Exception new.
		 signalResult:: exceptionSignaled signal.
		 afterSignal:: true.
		 42] 
			on: Exception 
			do: 
				[:ex | 
				handler:: true. 
				exceptionHandled:: ex. 
				ex return: 63.
				afterReturn:: true.
				84].
			
	assert: beforeSignal.
	deny: afterSignal.
	assert: handler.
	deny: afterReturn.
	assert: exceptionSignaled equals: exceptionHandled.
	assert: signalResult equals: nil.
	assert: result equals: 63.
)
public testExceptionSignalInHandler = (
	|
	outerBefore ::= false.
	outerAfter ::= false.
	innerBefore ::= false.
	innerAfter ::= false.
	innerExceptionSignaled
	innerExceptionCaught
	handlerExceptionSignaled
	outerExceptionCaught
	|

	[outerBefore:: true.
		[innerBefore:: true.
		 innerExceptionSignaled:: Exception new.
		 innerExceptionSignaled signal.
		 innerAfter:: true]
			on: Exception 
			do: 
				[:ex |  
				handlerExceptionSignaled:: Exception new.
				handlerExceptionSignaled signal].
	 outerAfter:: true]
		on: Exception
		do: [:ex | outerExceptionCaught:: ex].
		
	assert: outerBefore.
	assert: innerBefore.
	deny: innerAfter.
	deny: outerAfter.
	assert: outerExceptionCaught equals: handlerExceptionSignaled.
)
public testExceptionTypeMatch1 = (
	|
	beforeSignal ::= false.
	afterSignal ::= false.
	afterInnerTry ::= false.
	outerHandler ::= false.
	innerHandler ::= false.
	|
	

	[
		[
			beforeSignal:: true.
			Exception new signal.
			afterSignal:: true.
		] on: TestException do: [:ex | innerHandler:: true].
		afterInnerTry:: true.
	] on: Exception do: [:ex | outerHandler:: true].
	
	assert: beforeSignal.
	deny: afterSignal.
	deny: innerHandler.
	deny: afterInnerTry.
	assert: outerHandler.
)
public testExceptionTypeMatch2 = (
	|
	beforeSignal ::= false.
	afterSignal ::= false.
	afterInnerTry ::= false.
	outerHandler ::= false.
	innerHandler ::= false.
	|
	

	[
		[
			beforeSignal:: true.
			TestException new signal.
			afterSignal:: true.
		] on: TestException do: [:ex | innerHandler:: true].
		afterInnerTry:: true.
	] on: Exception do: [:ex | outerHandler:: true].
	
	assert: beforeSignal.
	deny: afterSignal.
	assert: innerHandler.
	assert: afterInnerTry.
	deny: outerHandler.
)
public testExceptionTypeMatch3 = (
	|
	beforeSignal ::= false.
	afterSignal ::= false.
	afterInnerTry ::= false.
	outerHandler ::= false.
	innerHandler ::= false.
	|
	

	[
		[
			beforeSignal:: true.
			TestException new signal.
			afterSignal:: true.
		] on: Exception do: [:ex | innerHandler:: true].
		afterInnerTry:: true.
	] on: TestException do: [:ex | outerHandler:: true].
	
	assert: beforeSignal.
	deny: afterSignal.
	assert: innerHandler.
	assert: afterInnerTry.
	deny: outerHandler.
)
) : (
'as yet unclassified'
TEST_CONTEXT = ()
)
public class FloatTests = TestContext () (
'as yet unclassified'
public testFloatAdd = (
	assert: 3 + 4 asFloat equals: 7.
	assert: 3 asFloat + 4 equals: 7.
	assert: 3 asFloat + 4 asFloat equals: 7.
	
	assert: 3.5 asFloat + 4.5 asFloat equals: 8.
)
public testFloatAsInteger = (
	(* truncation *)
	assert: 3.0 asFloat asInteger equals: 3.
	assert: -3.0 asFloat asInteger equals: -3.
	assert: 3.4 asFloat asInteger equals: 3.
	assert: 3.5 asFloat asInteger equals: 3.
	assert: -3.4 asFloat asInteger equals: -3.
	assert: -3.5 asFloat asInteger equals: -3.
	
	assert: minDoubleInt asFloat asInteger equals: minDoubleInt.
	deny: (minDoubleInt - 1) asFloat asInteger equals: minDoubleInt + 1.
	assert: maxDoubleInt asFloat asInteger equals: maxDoubleInt.
	deny: (maxDoubleInt + 1) asFloat asInteger equals: maxDoubleInt + 1.
	
	minInt64 asFloat asInteger.
	maxInt64 asFloat asInteger.
)
public testFloatAsString = (
	assert: 3 asFloat asString equals: '3.0'.
	assert: (3 asFloat / 2 asFloat) asString equals: '1.5'.
	assert: (1 asFloat / 3 asFloat) asString equals: '0.3333333333333333'.
	assert: (-22 asFloat / 7 asFloat) asString equals: '-3.142857142857143'.
	
	(* :todo: Float nan, etc *)
	assert: (-1 sqrt) asString equals: 'NaN'.
	
	(* :todo: max and min *)
)
public testFloatCeiling = (
	assert: 3.0 asFloat ceiling equals: 3.
	assert: 3.4 asFloat ceiling equals: 4.
	assert: 3.5 asFloat ceiling equals: 4.
	assert: -3.4 asFloat ceiling equals: -3.
	assert: -3.5 asFloat ceiling equals: -3.

	assert: minDoubleInt asFloat ceiling equals: minDoubleInt.
	(* :todo: Should float-integer comparison be precise?
	deny: (minDoubleInt - 1) asFloat ceiling equals: minDoubleInt + 1. *)
	assert: maxDoubleInt asFloat ceiling equals: maxDoubleInt.
	(* :todo: Should float-integer comparison be precise?
	deny: (maxDoubleInt + 1) asFloat ceiling equals: maxDoubleInt + 1. *)
	
	minInt64 asFloat ceiling.
	maxInt64 asFloat ceiling.
)
public testFloatComparisons = (
	assert: 1.618 asFloat = 1.618 asFloat.
	deny: 1.618 asFloat < 1.618 asFloat.
	deny: 1.618 asFloat > 1.618 asFloat.
	assert: 1.618 asFloat <= 1.618 asFloat.
	assert: 1.618 asFloat >= 1.618 asFloat.

	deny: 1.2 asFloat = 1.3 asFloat.
	assert: 1.2 asFloat < 1.3 asFloat.
	deny: 1.2 asFloat > 1.3 asFloat.
	assert: 1.2 asFloat <= 1.3 asFloat.
	deny: 1.2 asFloat >= 1.3 asFloat.
	
	deny: -1.2 asFloat = 1.3 asFloat.
	assert: -1.2 asFloat < 1.3 asFloat.
	deny: -1.2 asFloat > 1.3 asFloat.
	assert: -1.2 asFloat <= 1.3 asFloat.
	deny: -1.2 asFloat >= 1.3 asFloat.

	deny: 1.2 asFloat = -1.3 asFloat.
	deny: 1.2 asFloat < -1.3 asFloat.
	assert: 1.2 asFloat > -1.3 asFloat.
	deny: 1.2 asFloat <= -1.3 asFloat.
	assert: 1.2 asFloat >= -1.3 asFloat.
	
	deny: -1.2 asFloat = -1.3 asFloat.
	deny: -1.2 asFloat < -1.3 asFloat.
	assert: -1.2 asFloat > -1.3 asFloat.
	deny: -1.2 asFloat <= -1.3 asFloat.
	assert: -1.2 asFloat >= -1.3 asFloat.
	
	deny: 4.25 asFloat = '4.25'.
	should: [4.25 asFloat < '4.25'] signal: Error.
	should: [4.25 asFloat > '4.25'] signal: Error.
	should: [4.25 asFloat <= '4.25'] signal: Error.
	should: [4.25 asFloat >= '4.25'] signal: Error.
)
public testFloatFloor = (
	assert: 3.0 asFloat floor equals: 3.
	assert: 3.4 asFloat floor equals: 3.
	assert: 3.5 asFloat floor equals: 3.
	assert: -3.4 asFloat floor equals: -4.
	assert: -3.5 asFloat floor equals: -4.

	assert: minDoubleInt asFloat floor equals: minDoubleInt.
	(* :todo: Should float-integer comparison be precise?
	deny: (minDoubleInt - 1) asFloat floor equals: minDoubleInt + 1. *)
	assert: maxDoubleInt asFloat floor equals: maxDoubleInt.
	(* :todo: Should float-integer comparison be precise?
	deny: (maxDoubleInt + 1) asFloat floor equals: maxDoubleInt + 1. *)
	
	minInt64 asFloat floor.
	maxInt64 asFloat floor.
)
public testFloatFunctions = (
	(* :todo: Tests results with some tolerance. *)
	
	assert: 3 asFloat sin isFloat.
	assert: 3 asFloat cos isFloat.
	assert: 3 asFloat tan isFloat.
	assert: 3 asFloat sqrt isFloat.
	assert: 3 asFloat log isFloat.
	assert: 3 asFloat ln isFloat.
	assert: 3 asFloat exp isFloat.

	assert: 3 sin isFloat.
	assert: 3 cos isFloat.
	assert: 3 tan isFloat.
	assert: 3 sqrt isFloat.
	assert: 3 log isFloat.
	assert: 3 ln isFloat.
	assert: 3 exp isFloat.
)
public testFloatHash = (
	assert: -3 asFloat hash equals: -3 hash.
	assert: 0 asFloat hash equals: 0 hash.
	assert: 3 asFloat hash equals: 3 hash.
	
	assert: minDoubleInt asFloat hash equals: minDoubleInt hash.
	assert: maxDoubleInt asFloat hash equals: maxDoubleInt hash.
)
public testFloatOperatorsInvalidArgument = (
	should: [0 asFloat + nil] signal: Error.
	should: [0 asFloat - nil] signal: Error.
	should: [0 asFloat / nil] signal: Error.
	should: [0 asFloat * nil] signal: Error.
	should: [0 asFloat // nil] signal: Error.
	should: [0 asFloat \\ nil] signal: Error.
	should: [0 asFloat quo: nil] signal: Error.
	should: [0 asFloat rem: nil] signal: Error.
	should: [0 asFloat << nil] signal: Error.
	should: [0 asFloat >> nil] signal: Error.
	should: [0 asFloat bitAnd: nil] signal: Error.
	should: [0 asFloat bitOr: nil] signal: Error.
	should: [0 asFloat bitXor: nil] signal: Error.
)
public testFloatParse = (
	assert: (Float parse: '3') isFloat.
	assert: (Float parse: '3') equals: 3 asFloat.

	assert: (Float parse: '3.') isFloat.
	assert: (Float parse: '3.') equals: 3 asFloat.

	assert: (Float parse: '3.0') isFloat.
	assert: (Float parse: '3.0') equals: 3 asFloat.

	assert: (Float parse: '0003.0000') isFloat.
	assert: (Float parse: '0003.0000') equals: 3 asFloat.

	assert: (Float parse: '-3') isFloat.
	assert: (Float parse: '-3') equals: -3 asFloat.

	assert: (Float parse: '1.5') isFloat.
	assert: (Float parse: '1.5') equals: 1.5 asFloat.

	assert: (Float parse: 'NaN') isFloat.
	deny: (Float parse: 'NaN') equals: (Float parse: 'NaN').
	assert: (Float parse: 'NaN') asString equals: 'NaN'.

	assert: (Float parse: 'Infinity') isFloat.
	assert: (Float parse: 'Infinity') > 0.
	assert: (Float parse: 'Infinity') asString equals: 'Infinity'.
	assert: (Float parse: '-Infinity') isFloat.
	assert: (Float parse: '-Infinity') < 0.
	assert: (Float parse: '-Infinity') asString equals: '-Infinity'.

	should: [Float parse: 'xyz'] signal: Error.
	should: [Float parse: ''] signal: Error.
	should: [Float parse: '--9'] signal: Error.
	should: [Float parse: 'nan'] signal: Error.
	should: [Float parse: 'NAN'] signal: Error.
	should: [Float parse: 'infinity'] signal: Error.
	should: [Float parse: '-infinity'] signal: Error.
	should: [Float parse: 'inf'] signal: Error.
	should: [Float parse: '-inf'] signal: Error.
)
public testFloatRounded = (
	assert: 3.0 asFloat rounded equals: 3.
	assert: 3.4 asFloat rounded equals: 3.
	assert: 3.5 asFloat rounded equals: 4.
	assert: -3.4 asFloat rounded equals: -3.
	assert: -3.5 asFloat rounded equals: -4.
	
	minInt64 asFloat rounded.
	maxInt64 asFloat rounded.
)
public testIsFloat = (
	deny: 'foo' isFloat.
	deny: #foo isFloat.
	deny: ('foo', 'bar') isFloat.
	deny: 1 isFloat.
	deny: 1.5 isFloat.
	assert: 1.5 asFloat isFloat.
	deny: true isFloat.
	deny: nil isFloat.
	deny: {} isFloat.
	deny: [] isFloat.
)
) : (
'as yet unclassified'
TEST_CONTEXT = ()
)
public class IntegerTests = TestContext () (
'as yet unclassified'
public testIntegerAdd = (
	(* smi + smi, mint + mint, smi + mint, mint + smi *)
	assert: minInt31 + maxInt31 equals: -1.
	assert: minInt32 + maxInt32 equals: -1.
	assert: minInt63 + maxInt63 equals: -1.
	assert: minInt64 + maxInt64 equals: -1.
	
	assert: maxInt31 + maxInt31 equals: 2147483646.
	assert: maxInt32 + maxInt32 equals: 4294967294.
	assert: maxInt63 + maxInt63 equals: 9223372036854775806.
	
	assert: minInt31 + minInt32 equals: -3221225472.
	assert: minInt32 + minInt31 equals: -3221225472.
	assert: minInt31 + minInt63 equals: -4611686019501129728.
	assert: minInt63 + minInt31 equals: -4611686019501129728.
	assert: minInt32 + minInt63 equals: -4611686020574871552.
	assert: minInt63 + minInt32 equals: -4611686020574871552.
	
	assert: maxInt31 + maxInt32 equals: 3221225470.
	assert: maxInt32 + maxInt31 equals: 3221225470.
	assert: maxInt31 + maxInt63 equals: 4611686019501129726.
	assert: maxInt63 + maxInt31 equals: 4611686019501129726.
	assert: maxInt32 + maxInt63 equals: 4611686020574871550.
	assert: maxInt63 + maxInt32 equals: 4611686020574871550.
	
	assert: minInt31 + maxInt32 equals: 1073741823.
	assert: maxInt32 + minInt31  equals: 1073741823.
	assert: minInt31 + maxInt63 equals: 4611686017353646079.
	assert: maxInt63 + minInt31 equals: 4611686017353646079.
	assert: minInt32 + maxInt63 equals: 4611686016279904255.
	assert: maxInt63 + minInt32 equals: 4611686016279904255.
	
	assert: maxInt31 + minInt32 equals: -1073741825.
	assert: minInt32 + maxInt31 equals: -1073741825.
	assert: maxInt31 + minInt63 equals: -4611686017353646081.
	assert: minInt63 + maxInt31 equals: -4611686017353646081.
	assert: maxInt32 + minInt63 equals: -4611686016279904257.
	assert: minInt63 + maxInt32 equals: -4611686016279904257.
)
public testIntegerAsInteger = (
	assert: -1 asInteger equals: -1.
	assert: 0 asInteger equals: 0.
	assert: 1 asInteger equals: 1.
	
	assert: minInt31 asInteger equals: minInt31.
	assert: minInt32 asInteger equals: minInt32.
	assert: minInt63 asInteger equals: minInt63.
	assert: minInt64 asInteger equals: minInt64.
	assert: maxInt31 asInteger equals: maxInt31.
	assert: maxInt32 asInteger equals: maxInt32.
	assert: maxInt63 asInteger equals: maxInt63.
	assert: maxInt64 asInteger equals: maxInt64.
)
public testIntegerCeiling = (
	assert: -1 ceiling equals: -1.
	assert: 0 ceiling equals: 0.
	assert: 1 ceiling equals: 1.
	
	assert: minInt31 ceiling equals: minInt31.
	assert: minInt32 ceiling equals: minInt32.
	assert: minInt63 ceiling equals: minInt63.
	assert: minInt64 ceiling equals: minInt64.
	assert: maxInt31 ceiling equals: maxInt31.
	assert: maxInt32 ceiling equals: maxInt32.
	assert: maxInt63 ceiling equals: maxInt63.
	assert: maxInt64 ceiling equals: maxInt64.
)
public testIntegerFloor = (
	assert: -1 floor equals: -1.
	assert: 0 floor equals: 0.
	assert: 1 floor equals: 1.
	
	assert: minInt31 floor equals: minInt31.
	assert: minInt32 floor equals: minInt32.
	assert: minInt63 floor equals: minInt63.
	assert: minInt64 floor equals: minInt64.
	assert: maxInt31 floor equals: maxInt31.
	assert: maxInt32 floor equals: maxInt32.
	assert: maxInt63 floor equals: maxInt63.
	assert: maxInt64 floor equals: maxInt64.
)
public testIntegerMultiply = (
	(* smi + smi, mint + mint, smi + mint, mint + smi *)
	assert: minInt31 * 1 equals: minInt31.
	assert: minInt32 * 1 equals: minInt32.
	assert: minInt63 * 1 equals: minInt63.
	assert: minInt64 * 1 equals: minInt64.
	assert: maxInt31 * 1 equals: maxInt31.
	assert: maxInt32 * 1 equals: maxInt32.
	assert: maxInt63 * 1 equals: maxInt63.
	assert: maxInt64 * 1 equals: maxInt64.
	
	assert: minInt31 * -1 equals: 1073741824.
	assert: minInt32 * -1 equals: 2147483648.
	assert: minInt63 * -1 equals: 4611686018427387904.
	(* big int: assert: minInt64 * -1 equals: 9223372036854775808. *)
	
	assert: minInt31 * maxInt31 equals: -1152921503533105152.
	assert: minInt31 * minInt31 equals: 1152921504606846976.
	assert: maxInt31 * maxInt31 equals: 1152921502459363329.
	
	assert: minInt32 * maxInt32 equals: -4611686016279904256.
	assert: minInt32 * minInt32 equals: 4611686018427387904.
	assert: maxInt32 * maxInt32 equals: 4611686014132420609.
)
public testIntegerRounded = (
	assert: -1 rounded equals: -1.
	assert: 0 rounded equals: 0.
	assert: 1 rounded equals: 1.
	
	assert: minInt31 rounded equals: minInt31.
	assert: minInt32 rounded equals: minInt32.
	assert: minInt63 rounded equals: minInt63.
	assert: minInt64 rounded equals: minInt64.
	assert: maxInt31 rounded equals: maxInt31.
	assert: maxInt32 rounded equals: maxInt32.
	assert: maxInt63 rounded equals: maxInt63.
	assert: maxInt64 rounded equals: maxInt64.
)
public testIntegerSubtract = (
	(* smi + smi, mint + mint, smi + mint, mint + smi *)
	assert: maxInt31 - minInt31 equals: 2147483647.
	assert: maxInt32 - minInt32 equals: 4294967295.
	assert: maxInt63 - minInt63 equals: 9223372036854775807.
	(* big int assert: maxInt64 - minInt64 equals: 18446744073709551615. *)

	assert: maxInt31 - maxInt31 equals: 0.
	assert: maxInt32 - maxInt32 equals: 0.
	assert: maxInt63 - maxInt63 equals: 0.
	
	assert: minInt31 - minInt32 equals: 1073741824.
	assert: minInt32 - minInt31 equals: -1073741824.
	assert: minInt31 - minInt63 equals: 4611686017353646080.
	assert: minInt63 - minInt31 equals: -4611686017353646080.
	assert: minInt32 - minInt63 equals: 4611686016279904256.
	assert: minInt63 - minInt32 equals: -4611686016279904256.
	
	assert: maxInt31 - maxInt32 equals: -1073741824.
	assert: maxInt32 - maxInt31 equals: 1073741824.
	assert: maxInt31 - maxInt63 equals: -4611686017353646080.
	assert: maxInt63 - maxInt31 equals: 4611686017353646080.
	assert: maxInt32 - maxInt63 equals: -4611686016279904256.
	assert: maxInt63 - maxInt32 equals: 4611686016279904256.
	
	assert: minInt31 - maxInt32 equals: -3221225471.
	assert: maxInt32 - minInt31 equals: 3221225471.
	assert: minInt31 - maxInt63 equals: -4611686019501129727.
	assert: maxInt63 - minInt31 equals: 4611686019501129727.
	assert: minInt32 - maxInt63 equals: -4611686020574871551.
	assert: maxInt63 - minInt32 equals: 4611686020574871551.
	
	assert: maxInt31 - minInt32 equals: 3221225471.
	assert: minInt32 - maxInt31 equals: -3221225471.
	assert: maxInt31 - minInt63 equals: 4611686019501129727.
	assert: minInt63 - maxInt31 equals: -4611686019501129727.
	assert: maxInt32 - minInt63 equals: 4611686020574871551.
	assert: minInt63 - maxInt32 equals: -4611686020574871551.
)
public testIsInteger = (
	deny: 'foo' isInteger.
	deny: #foo isInteger.
	deny: ('foo', 'bar') isInteger.
	assert: 1 isInteger.
	deny: 1.5 isInteger.
	deny: 1.5 asFloat isInteger.
	deny: true isInteger.
	deny: nil isInteger.
	deny: {} isInteger.
	deny: [] isInteger.
)
public testMediumIntegerAnd = (
	assert: (minInt31 bitAnd: 0) equals: 0.
	assert: (minInt32 bitAnd: 0) equals: 0.
	assert: (minInt63 bitAnd: 0) equals: 0.
	assert: (minInt64 bitAnd: 0) equals: 0.
	assert: (maxInt31 bitAnd: 0) equals: 0.
	assert: (maxInt32 bitAnd: 0) equals: 0.
	assert: (maxInt63 bitAnd: 0) equals: 0.
	assert: (maxInt64 bitAnd: 0) equals: 0.
	
	assert: (minInt31 bitAnd: minInt31) equals: minInt31.
	assert: (minInt32 bitAnd: minInt32) equals: minInt32.
	assert: (minInt63 bitAnd: minInt63) equals: minInt63.
	assert: (minInt64 bitAnd: minInt64) equals: minInt64.
	assert: (maxInt31 bitAnd: maxInt31) equals: maxInt31.
	assert: (maxInt32 bitAnd: maxInt32) equals: maxInt32.
	assert: (maxInt63 bitAnd: maxInt63) equals: maxInt63.
	assert: (maxInt64 bitAnd: maxInt64) equals: maxInt64.
	
	assert: (minInt31 bitAnd: maxInt31) equals: 0.
	assert: (minInt32 bitAnd: maxInt32) equals: 0.
	assert: (minInt63 bitAnd: maxInt63) equals: 0.
	assert: (minInt64 bitAnd: maxInt64) equals: 0.
	
	assert: (maxInt32 bitAnd: maxInt31) equals: maxInt31.
	assert: (maxInt63 bitAnd: maxInt31) equals: maxInt31.
	assert: (maxInt64 bitAnd: maxInt31) equals: maxInt31.
	
	assert: (maxInt63 bitAnd: maxInt32) equals: maxInt32.
	assert: (maxInt64 bitAnd: maxInt32) equals: maxInt32.
	
	assert: (maxInt64 bitAnd: maxInt63) equals: maxInt63.
)
public testMediumIntegerAsString = (
	assert: maxInt64 asString equals: '9223372036854775807'.
	assert: minInt64 asString equals: '-9223372036854775808'.
)
public testMediumIntegerComparisons = (
	assert: minInt64 = minInt64.
	deny: minInt64 < minInt64.
	deny: minInt64 > minInt64.
	assert: minInt64 <= minInt64.
	assert: minInt64 >= minInt64.

	assert: maxInt64 = maxInt64.
	deny: maxInt64 < maxInt64.
	deny: maxInt64 > maxInt64.
	assert: maxInt64 <= maxInt64.
	assert: maxInt64 >= maxInt64.

	deny: maxInt64 = minInt64.
	deny: maxInt64 < minInt64.
	assert: maxInt64 > minInt64.
	deny: maxInt64 <= minInt64.
	assert: maxInt64 >= minInt64.

	deny: minInt64 = maxInt64.
	assert: minInt64 < maxInt64.
	deny: minInt64 > maxInt64.
	assert: minInt64 <= maxInt64.
	deny: minInt64 >= maxInt64.
)
public testMediumIntegerDiv = (
	assert: minInt31 // 1 equals: minInt31.
	assert: minInt32 // 1 equals: minInt32.
	assert: minInt63 // 1 equals: minInt63.
	assert: minInt64 // 1 equals: minInt64.
	assert: maxInt31 // 1 equals: maxInt31.
	assert: maxInt32 // 1 equals: maxInt32.
	assert: maxInt63 // 1 equals: maxInt63.
	assert: maxInt64 // 1 equals: maxInt64.
	
	assert: minInt31 // -1 equals: 1073741824.
	assert: minInt32 // -1 equals: 2147483648.
	assert: minInt63 // -1 equals: 4611686018427387904.
	(* big int: assert: minInt64 // -1 equals: 9223372036854775808. *)
	assert: maxInt31 // -1 equals: -1073741823.
	assert: maxInt32 // -1 equals: -2147483647.
	assert: maxInt63 // -1 equals: -4611686018427387903.
	assert: maxInt64 // -1 equals: -9223372036854775807.
	
	assert: minInt31 // 7 equals: -153391690.
	assert: minInt32 // 7 equals: -306783379.
	assert: minInt63 // 7 equals: -658812288346769701.
	(* assert: minInt64 // 7 equals: -1317624576693539402. *)
	assert: maxInt31 // 7 equals: 153391689.
	assert: maxInt32 // 7 equals: 306783378.
	assert: maxInt63 // 7 equals: 658812288346769700.
	(* assert: maxInt64 // 7 equals: 1317624576693539401. *)
	
	assert: minInt31 // -7 equals: 153391689.
	assert: minInt32 // -7 equals: 306783378.
	assert: minInt63 // -7 equals: 658812288346769700.
	(* big int intermediate: assert: minInt64 // -7 equals: 1317624576693539401. *)
	assert: maxInt31 // -7 equals: -153391689.
	assert: maxInt32 // -7 equals: -306783379.
	assert: maxInt63 // -7 equals: -658812288346769701.
	(* assert: maxInt64 // -7 equals: -1317624576693539401. *)
	
	(* big int intermediates 
	assert: minInt31 // minInt64 equals: 0.
	assert: minInt32 // minInt64 equals: 0.
	assert: minInt63 // minInt64 equals: 0.
	assert: minInt64 // minInt64 equals: 1.
	assert: maxInt31 // minInt64 equals: -1.
	assert: maxInt32 // minInt64 equals: -1.
	assert: maxInt63 // minInt64 equals: -1.
	assert: maxInt64 // minInt64 equals: -1. *)
	
	should: [maxInt64 // 0] signal: Error.
)
public testMediumIntegerDivide = (
	assert: minInt31 / 1 equals: minInt31.
	assert: minInt32 / 1 equals: minInt32.
	assert: minInt63 / 1 equals: minInt63.
	assert: minInt64 / 1 equals: minInt64.
	assert: maxInt31 / 1 equals: maxInt31.
	assert: maxInt32 / 1 equals: maxInt32.
	assert: maxInt63 / 1 equals: maxInt63.
	assert: maxInt64 / 1 equals: maxInt64.
	
	assert: minInt31 / -1 equals: 1073741824.
	assert: minInt32 / -1 equals: 2147483648.
	assert: minInt63 / -1 equals: 4611686018427387904.
	(* big int: assert: minInt64 / -1 equals: 9223372036854775808. *)
	assert: maxInt31 / -1 equals: -1073741823.
	assert: maxInt32 / -1 equals: -2147483647.
	assert: maxInt63 / -1 equals: -4611686018427387903.
	assert: maxInt64 / -1 equals: -9223372036854775807.
	
	should: [maxInt64 / 0] signal: Error.
)
public testMediumIntegerInvert = (
	assert: minInt31 bitInvert equals: maxInt31.
	assert: minInt32 bitInvert equals: maxInt32.
	assert: minInt63 bitInvert equals: maxInt63.
	assert: minInt64 bitInvert equals: maxInt64.
	assert: maxInt31 bitInvert equals: minInt31.
	assert: maxInt32 bitInvert equals: minInt32.
	assert: maxInt63 bitInvert equals: minInt63.
	assert: maxInt64 bitInvert equals: minInt64.
)
public testMediumIntegerMod = (
	assert: minInt31 \\ 1 equals: 0.
	assert: minInt32 \\ 1 equals: 0.
	assert: minInt63 \\ 1 equals: 0.
	assert: minInt64 \\ 1 equals: 0.
	assert: maxInt31 \\ 1 equals: 0.
	assert: maxInt32 \\ 1 equals: 0.
	assert: maxInt63 \\ 1 equals: 0.
	assert: maxInt64 \\ 1 equals: 0.
	
	assert: minInt31 \\ -1 equals: 0.
	assert: minInt32 \\ -1 equals: 0.
	assert: minInt63 \\ -1 equals: 0.
	assert: minInt64 \\ -1 equals: 0.
	assert: maxInt31 \\ -1 equals: 0.
	assert: maxInt32 \\ -1 equals: 0.
	assert: maxInt63 \\ -1 equals: 0.
	assert: maxInt64 \\ -1 equals: 0.
	
	assert: minInt31 \\ 7 equals: 6.
	assert: minInt32 \\ 7 equals: 5.
	assert: minInt63 \\ 7 equals: 3.
	assert: minInt64 \\ 7 equals: 6.
	assert: maxInt31 \\ 7 equals: 0.
	assert: maxInt32 \\ 7 equals: 1.
	assert: maxInt63 \\ 7 equals: 3.
	assert: maxInt64 \\ 7 equals: 0.
	
	assert: minInt31 \\ -7 equals: -1.
	assert: minInt32 \\ -7 equals: -2.
	assert: minInt63 \\ -7 equals: -4.
	assert: minInt64 \\ -7 equals: -1.
	assert: maxInt31 \\ -7 equals: 0.
	assert: maxInt32 \\ -7 equals: -6.
	assert: maxInt63 \\ -7 equals: -4.
	assert: maxInt64 \\ -7 equals: 0.
	
	assert: minInt31 \\ minInt64 equals: -1073741824.
	assert: minInt32 \\ minInt64 equals: -2147483648.
	assert: minInt63 \\ minInt64 equals: -4611686018427387904.
	assert: minInt64 \\ minInt64 equals: 0.
	assert: maxInt31 \\ minInt64 equals: -9223372035781033985.
	assert: maxInt32 \\ minInt64 equals: -9223372034707292161.
	assert: maxInt63 \\ minInt64 equals: -4611686018427387905.
	assert: maxInt64 \\ minInt64 equals: -1.
	
	should: [maxInt64 \\ 0] signal: Error.
)
public testMediumIntegerOperatorsInvalidArgument = (
	should: [maxInt64 + nil] signal: Error.
	should: [maxInt64 - nil] signal: Error.
	should: [maxInt64 / nil] signal: Error.
	should: [maxInt64 * nil] signal: Error.
	should: [maxInt64 // nil] signal: Error.
	should: [maxInt64 \\ nil] signal: Error.
	should: [maxInt64 quo: nil] signal: Error.
	should: [maxInt64 rem: nil] signal: Error.
	should: [maxInt64 << nil] signal: Error.
	should: [maxInt64 >> nil] signal: Error.
	should: [maxInt64 bitAnd: nil] signal: Error.
	should: [maxInt64 bitOr: nil] signal: Error.
	should: [0 bitXor: nil] signal: Error.
)
public testMediumIntegerOr = (
	assert: (minInt31 bitOr: 0) equals: minInt31.
	assert: (minInt32 bitOr: 0) equals: minInt32.
	assert: (minInt63 bitOr: 0) equals: minInt63.
	assert: (minInt64 bitOr: 0) equals: minInt64.
	assert: (maxInt31 bitOr: 0) equals: maxInt31.
	assert: (maxInt32 bitOr: 0) equals: maxInt32.
	assert: (maxInt63 bitOr: 0) equals: maxInt63.
	assert: (maxInt64 bitOr: 0) equals: maxInt64.
	
	assert: (minInt31 bitOr: minInt31) equals: minInt31.
	assert: (minInt32 bitOr: minInt32) equals: minInt32.
	assert: (minInt63 bitOr: minInt63) equals: minInt63.
	assert: (minInt64 bitOr: minInt64) equals: minInt64.
	assert: (maxInt31 bitOr: maxInt31) equals: maxInt31.
	assert: (maxInt32 bitOr: maxInt32) equals: maxInt32.
	assert: (maxInt63 bitOr: maxInt63) equals: maxInt63.
	assert: (maxInt64 bitOr: maxInt64) equals: maxInt64.
	
	assert: (minInt31 bitOr: maxInt31) equals: -1.
	assert: (minInt32 bitOr: maxInt32) equals: -1.
	assert: (minInt63 bitOr: maxInt63) equals: -1.
	assert: (minInt64 bitOr: maxInt64) equals: -1.
	
	assert: (maxInt32 bitOr: maxInt31) equals: maxInt32.
	assert: (maxInt63 bitOr: maxInt31) equals: maxInt63.
	assert: (maxInt64 bitOr: maxInt31) equals: maxInt64.
	
	assert: (maxInt63 bitOr: maxInt32) equals: maxInt63.
	assert: (maxInt64 bitOr: maxInt32) equals: maxInt64.
	
	assert: (maxInt64 bitOr: maxInt63) equals: maxInt64.
)
public testMediumIntegerQuo = (
	assert: (minInt31 quo: 1) equals: minInt31.
	assert: (minInt32 quo: 1) equals: minInt32.
	assert: (minInt63 quo: 1) equals: minInt63.
	assert: (minInt64 quo: 1) equals: minInt64.
	assert: (maxInt31 quo: 1) equals: maxInt31.
	assert: (maxInt32 quo: 1) equals: maxInt32.
	assert: (maxInt63 quo: 1) equals: maxInt63.
	assert: (maxInt64 quo: 1) equals: maxInt64.
	
	assert: (minInt31 quo: -1) equals: 1073741824.
	assert: (minInt32 quo: -1) equals: 2147483648.
	assert: (minInt63 quo: -1) equals: 4611686018427387904.
	(* big int: assert: (minInt64 quo: -1) equals: 9223372036854775808. *)
	assert: (maxInt31 quo: -1) equals: -1073741823.
	assert: (maxInt32 quo: -1) equals: -2147483647.
	assert: (maxInt63 quo: -1) equals: -4611686018427387903.
	assert: (maxInt64 quo: -1) equals: -9223372036854775807.
	
	assert: (minInt31 quo: 7) equals: -153391689.
	assert: (minInt32 quo: 7) equals: -306783378.
	assert: (minInt63 quo: 7) equals: -658812288346769700.
	assert: (minInt64 quo: 7) equals: -1317624576693539401.
	assert: (maxInt31 quo: 7) equals: 153391689.
	assert: (maxInt32 quo: 7) equals: 306783378.
	assert: (maxInt63 quo: 7) equals: 658812288346769700.
	assert: (maxInt64 quo: 7) equals: 1317624576693539401.
	
	assert: (minInt31 quo: -7) equals: 153391689.
	assert: (minInt32 quo: -7) equals: 306783378.
	assert: (minInt63 quo: -7) equals: 658812288346769700.
	assert: (minInt64 quo: -7) equals: 1317624576693539401.
	assert: (maxInt31 quo: -7) equals: -153391689.
	assert: (maxInt32 quo: -7) equals: -306783378.
	assert: (maxInt63 quo: -7) equals: -658812288346769700.
	assert: (maxInt64 quo: -7) equals: -1317624576693539401.
	
	assert: (minInt31 quo: minInt64) equals: 0.
	assert: (minInt32 quo: minInt64) equals: 0.
	assert: (minInt63 quo: minInt64) equals: 0.
	assert: (minInt64 quo: minInt64) equals: 1.
	assert: (maxInt31 quo: minInt64) equals: 0.
	assert: (maxInt32 quo: minInt64) equals: 0.
	assert: (maxInt63 quo: minInt64) equals: 0.
	assert: (maxInt64 quo: minInt64) equals: 0.
	
	should: [maxInt64 quo: 0] signal: Error.
)
public testMediumIntegerRem = (
	assert: (minInt31 rem: 1) equals: 0.
	assert: (minInt32 rem: 1) equals: 0.
	assert: (minInt63 rem: 1) equals: 0.
	assert: (minInt64 rem: 1) equals: 0.
	assert: (maxInt31 rem: 1) equals: 0.
	assert: (maxInt32 rem: 1) equals: 0.
	assert: (maxInt63 rem: 1) equals: 0.
	assert: (maxInt64 rem: 1) equals: 0.
	
	assert: (minInt31 rem: -1) equals: 0.
	assert: (minInt32 rem: -1) equals: 0.
	assert: (minInt63 rem: -1) equals: 0.
	assert: (minInt64 rem: -1) equals: 0.
	assert: (maxInt31 rem: -1) equals: 0.
	assert: (maxInt32 rem: -1) equals: 0.
	assert: (maxInt63 rem: -1) equals: 0.
	assert: (maxInt64 rem: -1) equals: 0.
	
	assert: (minInt31 rem: 7) equals: -1.
	assert: (minInt32 rem: 7) equals: -2.
	assert: (minInt63 rem: 7) equals: -4.
	assert: (minInt64 rem: 7) equals: -1.
	assert: (maxInt31 rem: 7) equals: 0.
	assert: (maxInt32 rem: 7) equals: 1.
	assert: (maxInt63 rem: 7) equals: 3.
	assert: (maxInt64 rem: 7) equals: 0.
	
	assert: (minInt31 rem: -7) equals: -1.
	assert: (minInt32 rem: -7) equals: -2.
	assert: (minInt63 rem: -7) equals: -4.
	assert: (minInt64 rem: -7) equals: -1.
	assert: (maxInt31 rem: -7) equals: 0.
	assert: (maxInt32 rem: -7) equals: 1.
	assert: (maxInt63 rem: -7) equals: 3.
	assert: (maxInt64 rem: -7) equals: 0.
	
	assert: (minInt31 rem: minInt64) equals: -1073741824.
	assert: (minInt32 rem: minInt64) equals: -2147483648.
	assert: (minInt63 rem: minInt64) equals: -4611686018427387904.
	assert: (minInt64 rem: minInt64) equals: 0.
	assert: (maxInt31 rem: minInt64) equals: 1073741823.
	assert: (maxInt32 rem: minInt64) equals: 2147483647.
	assert: (maxInt63 rem: minInt64) equals: 4611686018427387903.
	assert: (maxInt64 rem: minInt64) equals: 9223372036854775807.
	
	should: [maxInt64 rem: 0] signal: Error.
)
public testMediumIntegerShiftLeft = (
	assert: minInt31 << 0 equals: minInt31.
	assert: minInt32 << 0 equals: minInt32.
	assert: minInt63 << 0 equals: minInt63.
	assert: minInt64 << 0 equals: minInt64.
	assert: maxInt31 << 0 equals: maxInt31.
	assert: maxInt32 << 0 equals: maxInt32.
	assert: maxInt63 << 0 equals: maxInt63.
	assert: maxInt64 << 0 equals: maxInt64.
	
	assert: minInt31 << 1 equals: -2147483648.
	assert: minInt32 << 1 equals: -4294967296.
	assert: minInt63 << 1 equals: -9223372036854775808.
	(* big int: assert: minInt64 << 1 equals: -18446744073709551616. *)
	assert: maxInt31 << 1 equals: 2147483646.
	assert: maxInt32 << 1 equals: 4294967294.
	assert: maxInt63 << 1 equals: 9223372036854775806.
	(* big int: assert: maxInt64 << 1 equals: 18446744073709551614. *)
	
	assert: minInt31 << 2 equals: -4294967296.
	assert: minInt32 << 2 equals: -8589934592.
	(* big int assert: minInt63 << 2 equals: -18446744073709551616. *)
	(* big int assert: minInt64 << 2 equals: -36893488147419103232. *)
	assert: maxInt31 << 2 equals: 4294967292.
	assert: maxInt32 << 2 equals: 8589934588.
	(* big int assert: maxInt63 << 2 equals: 18446744073709551612. *)
	(* big int assert: maxInt64 << 2 equals: 36893488147419103228. *)
	
	assert: maxInt31 << 33 equals: 9223372028264841216.
	assert: maxInt32 << 32 equals: 9223372032559808512.
	
	should: [minInt31 << -1] signal: Error.
	should: [minInt32 << -1] signal: Error.
	should: [minInt63 << -1] signal: Error.
	should: [minInt64 << -1] signal: Error.
	should: [maxInt31 << -1] signal: Error.
	should: [maxInt32 << -1] signal: Error.
	should: [maxInt63 << -1] signal: Error.
	should: [maxInt64 << -1] signal: Error.
)
public testMediumIntegerShiftRight = (
	assert: minInt31 >> 0 equals: minInt31.
	assert: minInt32 >> 0 equals: minInt32.
	assert: minInt63 >> 0 equals: minInt63.
	assert: minInt64 >> 0 equals: minInt64.
	assert: maxInt31 >> 0 equals: maxInt31.
	assert: maxInt32 >> 0 equals: maxInt32.
	assert: maxInt63 >> 0 equals: maxInt63.
	assert: maxInt64 >> 0 equals: maxInt64.
	
	assert: minInt31 >> 1 equals: -536870912.
	assert: minInt32 >> 1 equals: -1073741824.
	assert: minInt63 >> 1 equals: -2305843009213693952.
	assert: minInt64 >> 1 equals: -4611686018427387904.
	assert: maxInt31 >> 1 equals: 536870911.
	assert: maxInt32 >> 1 equals: 1073741823.
	assert: maxInt63 >> 1 equals: 2305843009213693951.
	assert: maxInt64 >> 1 equals: 4611686018427387903.
	
	assert: minInt31 >> 2 equals: -268435456.
	assert: minInt32 >> 2 equals: -536870912.
	assert: minInt63 >> 2 equals: -1152921504606846976.
	assert: minInt64 >> 2 equals: -2305843009213693952.
	assert: maxInt31 >> 2 equals: 268435455.
	assert: maxInt32 >> 2 equals: 536870911.
	assert: maxInt63 >> 2 equals: 1152921504606846975.
	assert: maxInt64 >> 2 equals: 2305843009213693951.
	
	assert: minInt31 >> 29 equals: -2.
	assert: minInt32 >> 30 equals: -2.
	assert: minInt63 >> 61 equals: -2.
	assert: minInt64 >> 62 equals: -2.
	assert: maxInt31 >> 29 equals: 1.
	assert: maxInt32 >> 30 equals: 1.
	assert: maxInt63 >> 61 equals: 1.
	assert: maxInt64 >> 62 equals: 1.
	
	assert: minInt31 >> 30 equals: -1.
	assert: minInt32 >> 31 equals: -1.
	assert: minInt63 >> 62 equals: -1.
	assert: minInt64 >> 63 equals: -1.
	assert: maxInt31 >> 30 equals: 0.
	assert: maxInt32 >> 31 equals: 0.
	assert: maxInt63 >> 62 equals: 0.
	assert: maxInt64 >> 63 equals: 0.
	
	assert: minInt31 >> 31 equals: -1.
	assert: minInt32 >> 32 equals: -1.
	assert: minInt63 >> 63 equals: -1.
	assert: minInt64 >> 64 equals: -1.
	assert: maxInt31 >> 31 equals: 0.
	assert: maxInt32 >> 32 equals: 0.
	assert: maxInt63 >> 63 equals: 0.
	assert: maxInt64 >> 64 equals: 0.
	
	assert: minInt31 >> maxInt64 equals: -1.
	assert: minInt32 >> maxInt64 equals: -1.
	assert: minInt63 >> maxInt64 equals: -1.
	assert: minInt64 >> maxInt64 equals: -1.
	assert: maxInt31 >> maxInt64 equals: 0.
	assert: maxInt32 >> maxInt64 equals: 0.
	assert: maxInt63 >> maxInt64 equals: 0.
	assert: maxInt64 >> maxInt64 equals: 0.
	
	should: [minInt31 >> -1] signal: Error.
	should: [minInt32 >> -1] signal: Error.
	should: [minInt63 >> -1] signal: Error.
	should: [minInt64 >> -1] signal: Error.
	should: [maxInt31 >> -1] signal: Error.
	should: [maxInt32 >> -1] signal: Error.
	should: [maxInt63 >> -1] signal: Error.
	should: [maxInt64 >> -1] signal: Error.
)
public testMediumIntegerXor = (
	assert: (minInt31 bitXor: 0) equals: minInt31.
	assert: (minInt32 bitXor: 0) equals: minInt32.
	assert: (minInt63 bitXor: 0) equals: minInt63.
	assert: (minInt64 bitXor: 0) equals: minInt64.
	assert: (maxInt31 bitXor: 0) equals: maxInt31.
	assert: (maxInt32 bitXor: 0) equals: maxInt32.
	assert: (maxInt63 bitXor: 0) equals: maxInt63.
	assert: (maxInt64 bitXor: 0) equals: maxInt64.
	
	assert: (minInt31 bitXor: minInt31) equals: 0.
	assert: (minInt32 bitXor: minInt32) equals: 0.
	assert: (minInt63 bitXor: minInt63) equals: 0.
	assert: (minInt64 bitXor: minInt64) equals: 0.
	assert: (maxInt31 bitXor: maxInt31) equals: 0.
	assert: (maxInt32 bitXor: maxInt32) equals: 0.
	assert: (maxInt63 bitXor: maxInt63) equals: 0.
	assert: (maxInt64 bitXor: maxInt64) equals: 0.
	
	assert: (minInt31 bitXor: maxInt31) equals: -1.
	assert: (minInt32 bitXor: maxInt32) equals: -1.
	assert: (minInt63 bitXor: maxInt63) equals: -1.
	assert: (minInt64 bitXor: maxInt64) equals: -1.
	
	assert: (maxInt32 bitXor: maxInt31) equals: 1073741824.
	assert: (maxInt63 bitXor: maxInt31) equals: 4611686017353646080.
	assert: (maxInt64 bitXor: maxInt31) equals: 9223372035781033984.
	
	assert: (maxInt63 bitXor: maxInt32) equals: 4611686016279904256.
	assert: (maxInt64 bitXor: maxInt32) equals: 9223372034707292160.
	
	assert: (maxInt64 bitXor: maxInt63) equals: 4611686018427387904.
)
public testSmallIntegerAnd = (
	assert: (1 bitAnd: 0) equals: 0.
	assert: (-1 bitAnd: 0) equals: 0.

	assert: (3 bitAnd: 1) equals: 1.
	assert: (-3 bitAnd: 1) equals: 1.

	assert: (3 bitAnd: 2) equals: 2.
	assert: (-3 bitAnd: 2) equals: 0.
	
	assert: (3 bitAnd: -1) equals: 3.
	assert: (-3 bitAnd: -1) equals: -3.
)
public testSmallIntegerAsString = (
	assert: 3 asString equals: '3'.
	assert: -4 asString equals: '-4'.
	assert: 16rF asString equals: '15'.
	assert: maxInt31 asString equals: '1073741823'.
	assert: minInt31 asString equals: '-1073741824'.
)
public testSmallIntegerComparisons = (
	assert: 42 = 42.
	deny: 42 < 42.
	deny: 42 > 42.
	assert: 42 <= 42.
	assert: 42 >= 42.

	deny: 3 = 4.
	assert: 3 < 4.
	deny: 3 > 4.
	assert: 3 <= 4.
	deny: 3 >= 4.

	deny: 5 = 7.
	assert: 5 < 7.
	deny: 5 > 7.
	assert: 5 <= 7.
	deny: 5 >= 7.
	
	deny: -5 = 7.
	assert: -5 < 7.
	deny: -5 > 7.
	assert: -5 <= 7.
	deny: -5 >= 7.
	
	deny: 5 = -7.
	deny: 5 < -7.
	assert: 5 > -7.
	deny: 5 <= -7.
	assert: 5 >= -7.
	
	deny: -5 = -7.
	deny: -5 < -7.
	assert: -5 > -7.
	deny: -5 <= -7.
	assert: -5 >= -7.
	
	deny: 42 = '42'.
	should: [42 < '42'] signal: Error.
	should: [42 > '42'] signal: Error.
	should: [42 <= '42'] signal: Error.
	should: [42 >= '42'] signal: Error.
)
public testSmallIntegerDiv = (
	assert: -3 // 7 equals: -1.
	assert: 3 // -7 equals: -1.
	assert: -3 // -7 equals: 0.
	assert: 3 // 7 equals: 0.
	assert: -7 // 3 equals: -3.
	assert: 7 // -3 equals: -3.
	assert: -7 // -3 equals: 2.
	assert: 7 // 3  equals: 2.
	
	should: [42 // 0] signal: Error.
)
public testSmallIntegerDivide = (
	assert: 8 / 4 equals: 2.
	assert: 8 / 1 equals: 8.
	should: [8 / 0] signal: Error.
	
	assert: 3 / 3 equals: 1.
	assert: -3 / 3 equals: -1.
	assert: 3 / -3 equals: -1.
	assert: -3 / -3 equals: 1.
)
public testSmallIntegerDivideFraction = (
	assert: 4 / 6 equals: 2 / 3.
)
public testSmallIntegerInvert = (
	assert: 42 bitInvert equals: -43.
	assert: 1 bitInvert equals: -2.
	assert: 0 bitInvert equals: -1.
	assert: -1 bitInvert equals: 0.
	assert: -42 bitInvert equals: 41.
)
public testSmallIntegerMod = (
	assert: -3 \\ 7 equals: 4.
	assert: 3 \\ -7 equals: -4.
	assert: -3 \\ -7 equals: -3.
	assert: 3 \\ 7 equals: 3.
	assert: -7 \\ 3 equals: 2.
	assert: 7 \\ -3 equals: -2.
	assert: -7 \\ -3 equals: -1.
	assert: 7 \\ 3 equals: 1.
	
	should: [42 \\ 0] signal: Error.
)
public testSmallIntegerOperatorsInvalidArgument = (
	should: [0 + nil] signal: Error.
	should: [0 - nil] signal: Error.
	should: [0 / nil] signal: Error.
	should: [0 * nil] signal: Error.
	should: [0 // nil] signal: Error.
	should: [0 \\ nil] signal: Error.
	should: [0 quo: nil] signal: Error.
	should: [0 rem: nil] signal: Error.
	should: [0 << nil] signal: Error.
	should: [0 >> nil] signal: Error.
	should: [0 bitAnd: nil] signal: Error.
	should: [0 bitOr: nil] signal: Error.
	should: [0 bitXor: nil] signal: Error.
)
public testSmallIntegerOr = (
	assert: (1 bitOr: 0) equals: 1.
	assert: (-1 bitOr: 0) equals: -1.

	assert: (3 bitOr: 1) equals: 3.
	assert: (-3 bitOr: 1) equals: -3.

	assert: (3 bitOr: 2) equals: 3.
	assert: (-3 bitOr: 2) equals: -1.
	
	assert: (3 bitOr: -1) equals: -1.
	assert: (-3 bitOr: -1) equals: -1.
)
public testSmallIntegerQuo = (
	assert: (-3 quo: 7) equals: 0.
	assert: (3 quo: -7) equals: 0.
	assert: (-3 quo: -7) equals: 0.
	assert: (3 quo: 7) equals: 0.
	assert: (-7 quo: 3) equals: -2.
	assert: (7 quo: -3) equals: -2.
	assert: (-7 quo: -3) equals: 2.
	assert: (7 quo: 3) equals: 2.
	
	should: [42 quo: 0] signal: Error.
)
public testSmallIntegerRem = (
	assert: (-3 rem: 7) equals: -3.
	assert: (3 rem: -7) equals: 3.
	assert: (-3 rem: -7) equals: -3.
	assert: (3 rem: 7) equals: 3.
	assert: (-7 rem: 3) equals: -1.
	assert: (7 rem: -3) equals: 1.
	assert: (-7 rem: -3) equals: -1.
	assert: (7 rem: 3) equals: 1.
	
	should: [42 rem: 0] signal: Error.
)
public testSmallIntegerShiftLeft = (
	assert: 1 << 2 equals: 4.
	assert: -1 << 2 equals: -4.

	assert: 0 << 2 equals: 0.

	assert: 1 << 0 equals: 1.
	assert: -1 << 0 equals: -1.
)
public testSmallIntegerShiftRight = (
	assert: 4 >> 2 equals: 1.
	assert: 4 >> 3 equals: 0. (* A bad implementation will put value bits into the tag bit. *)
	assert: 4 >> 32 equals: 0.
	assert: 4 >> 33 equals: 0.
	assert: 4 >> 64 equals: 0.
	assert: 4 >> 65 equals: 0.
	
	assert: -4 >> 2 equals: -1.
	assert: -4 >> 3 equals: -1.
	assert: -4 >> 32 equals: -1.
	assert: -4 >> 33 equals: -1.
	assert: -4 >> 64 equals: -1.
	assert: -4 >> 65 equals: -1.
	
	assert: 0 >> 2 equals: 0.
	
	assert: 4 >> 0 equals: 4.
	assert: -4 >> 0 equals: -4.
)
public testSmallIntegerXor = (
	assert: (42 bitXor: 42) equals: 0.
	
	assert: (1 bitXor: 0) equals: 1.
	assert: (-1 bitXor: 0) equals: -1.

	assert: (3 bitXor: 1) equals: 2.
	assert: (-3 bitXor: 1) equals: -4.

	assert: (3 bitXor: 2) equals: 1.
	assert: (-3 bitXor: 2) equals: -1.
	
	assert: (3 bitXor: -1) equals: -4.
	assert: (-3 bitXor: -1) equals: 2.
)
public testSmiMintComparisons = (
	deny: maxInt31 = maxInt64.
	assert: maxInt31 < maxInt64.
	deny: maxInt31 > maxInt64.
	assert: maxInt31 <= maxInt64.
	deny: maxInt31 >= maxInt64.

	deny: maxInt64 = maxInt31.
	deny: maxInt64 < maxInt31.
	assert: maxInt64 > maxInt31.
	deny: maxInt64 <= maxInt31.
	assert: maxInt64 >= maxInt31.
	
	deny: minInt31 = minInt64.
	deny: minInt31 < minInt64.
	assert: minInt31 > minInt64.
	deny: minInt31 <= minInt64.
	assert: minInt31 >= minInt64.

	deny: minInt64 = minInt31.
	assert: minInt64 < minInt31.
	deny: minInt64 > minInt31.
	assert: minInt64 <= minInt31.
	deny: minInt64 >= minInt31.
)
) : (
'as yet unclassified'
TEST_CONTEXT = ()
)
public class ObjectTests = TestContext () (
'as yet unclassified'
public testClassProtected = (
	| o = Object new. |
	should: [o class] signal: MessageNotUnderstood.
	shouldnt: [self class] signal: MessageNotUnderstood.
)
public testDoesNotUnderstand = (
	| o = Object new. p = DnuAnswerMessage new. |
	should: [o foobar] signal: MessageNotUnderstood.
	
	assert: p foobar selector equals: #foobar.
	assert: p foobar arguments isArray.
	assert: p foobar arguments size equals: 0.

	assert: (p + 42) selector equals: #+.
	assert: (p + 42) arguments isArray.
	assert: (p + 42) arguments size equals: 1.
	assert: ((p + 42) arguments at: 1) equals: 42.

	assert: (p with: 3 with: 4) selector equals: #with:with:.
	assert: (p with: 3 with: 4) arguments isArray.
	assert: (p with: 3 with: 4) arguments size equals: 2.
	assert: ((p with: 3 with: 4) arguments at: 1) equals: 3.
	assert: ((p with: 3 with: 4) arguments at: 2) equals: 4.
)
public testEquals = (
	| a b |
	a:: Object new.
	b:: Object new.

	assert: a = a.
	assert: b = b.
	deny: a = b.
	deny: b = a.
)
public testGlobalsProtected = (
	| o = Object new. |
	should: [o Array] signal: MessageNotUnderstood.
	should: [o ByteArray] signal: MessageNotUnderstood.
	should: [o Error] signal: MessageNotUnderstood.
	should: [o Exception] signal: MessageNotUnderstood.
	should: [o Float] signal: MessageNotUnderstood.
	should: [o Integer] signal: MessageNotUnderstood.
	should: [o Object] signal: MessageNotUnderstood.
	should: [o String] signal: MessageNotUnderstood.
	should: [o Symbol] signal: MessageNotUnderstood.
	should: [o Future] signal: MessageNotUnderstood.
	should: [o Delay] signal: MessageNotUnderstood.
	should: [o WeakArray] signal: MessageNotUnderstood.
)
public testHash = (
	| o = Object new. |
	assert: o hash isInteger.
	assert: o hash > 0.
)
public testNotPolymorphicWithClosure = (
	| o = Object new. |
	should: [o value] signal: MessageNotUnderstood.
)
public testPrintString = (
	| o = Object new. |
	assert: o printString isString.
	assert: o printString size > 0.
)
public testYourself = (
	| o = Object new. |
	assert: o yourself equals: o.
)
) : (
'as yet unclassified'
TEST_CONTEXT = ()
)
public class StopwatchTests = TestContext () (
'as yet unclassified'
busyMilliseconds: millis = (
	| stopwatch = Stopwatch new. |
	stopwatch start.
	[stopwatch elapsedMilliseconds < millis] whileTrue.
)
public testStopwatchAccumulate = (
	| stopwatch = Stopwatch new. |
	stopwatch start.
	busyMilliseconds: 5.
	stopwatch stop.
	assert: [stopwatch elapsedMilliseconds >= 5].
	assert: [stopwatch elapsedMicroseconds >= 5000].
	
	busyMilliseconds: 5.
	
	stopwatch start.
	busyMilliseconds: 5.
	stopwatch stop.
	assert: [stopwatch elapsedMilliseconds >= 10].
	assert: [stopwatch elapsedMicroseconds >= 10000].
	
	busyMilliseconds: 5.
	
	stopwatch start.
	busyMilliseconds: 5.
	stopwatch stop.
	assert: [stopwatch elapsedMilliseconds >= 15].
	assert: [stopwatch elapsedMicroseconds >= 15000].
)
public testStopwatchDoubleStart = (
	| stopwatch = Stopwatch new. |
	stopwatch start.

	busyMilliseconds: 5.

	stopwatch start. (* Should not reset the elapsed time. *)

	busyMilliseconds: 5.
	
	assert: [stopwatch elapsedMilliseconds >= 10].
	assert: [stopwatch elapsedMicroseconds >= 10000].
	stopwatch stop.
	assert: [stopwatch elapsedMilliseconds >= 10].
	assert: [stopwatch elapsedMicroseconds >= 10000].
)
public testStopwatchEqualityIsIdentity = (
	|
	stopwatch1 = Stopwatch new.
	stopwatch2 = Stopwatch new.
	|
	assert: stopwatch1 elapsedMilliseconds equals: stopwatch2 elapsedMilliseconds.
	assert: stopwatch1 elapsedMicroseconds equals: stopwatch2 elapsedMicroseconds.
	deny: stopwatch1 equals: stopwatch2.
)
public testStopwatchInitialState = (
	| stopwatch = Stopwatch new. |
	assert: stopwatch elapsedMilliseconds equals: 0.
	assert: stopwatch elapsedMicroseconds equals: 0.
)
public testStopwatchInitiallyStopped = (
	| stopwatch = Stopwatch new. |
	busyMilliseconds: 5.
	
	assert: stopwatch elapsedMilliseconds equals: 0.
	assert: stopwatch elapsedMicroseconds equals: 0.
)
public testStopwatchMovesAfterStarted = (
	| stopwatch |
	stopwatch:: Stopwatch new.
	stopwatch start.
	[stopwatch elapsedMilliseconds < 5] whileTrue.

	stopwatch:: Stopwatch new.
	stopwatch start.
	[stopwatch elapsedMicroseconds < 5] whileTrue.
)
public testStopwatchStartStopValues = (
	| stopwatch = Stopwatch new. |
	assert: stopwatch start equals: stopwatch.
	assert: stopwatch stop equals: stopwatch.
)
) : (
'as yet unclassified'
TEST_CONTEXT = ()
)
public class StringTests = TestContext () (
'as yet unclassified'
public testIsString = (
	assert: 'foo' isString.
	assert: #foo isString.
	assert: ('foo', 'bar') isString.
	assert: 'Îñţérñåţîöñåļîžåţîờñ' isString.
	deny: 1 isString.
	deny: 1.5 isString.
	deny: 1.5 asFloat isString.
	deny: true isString.
	deny: nil isString.
	deny: {} isString.
	deny: [] isString.
)
public testStringAdd = (
	should: ['foo' + 'bar'] signal: MessageNotUnderstood.
)
public testStringAsString = (
	assert: 'foo' asString equals: 'foo'.
	assert: #foo asString equals: 'foo'.
)
public testStringAt = (
	(* This is written so it works without and without string/character unification. *)
	assert: ('foo' at: 1) equals: $f.
	assert: ('foo' at: 2) equals: $o.
	assert: ('foo' at: 3) equals: $o.

	should: ['foo' at: 0] signal: Error.
	should: ['foo' at: 4] signal: Error.

	should: ['' at: 0] signal: Error.
	
	should: ['foo' at: -1] signal: Error.
	should: ['foo' at: nil] signal: Error.
	should: ['foo' at: 1 asFloat] signal: Error.
)
public testStringConcatenation = (
	assert: 'foo' , 'bar' equals: 'foobar'.
	assert: 'foo' , 'bar', '' equals: 'foobar'.
	assert: ('foo' , 'bar') size equals: 6.

	should: ['foo', 3] signal: Error.
	should: ['foo', true] signal: Error.
	should: ['foo', nil] signal: Error.
	should: [3, 'foo'] signal: MessageNotUnderstood.
	should: [true, 'foo'] signal: MessageNotUnderstood.
	should: [nil, 'foo'] signal: MessageNotUnderstood.
)
public testStringEndsWith = (
	assert: ('foo' endsWith: 'o').
	assert: ('foo' endsWith: 'foo').
	assert: ('foo' endsWith: '').
	assert: ('' endsWith: '').
	deny: ('foo' endsWith: 'toolongfoo').
	deny: ('foo' endsWith: 'boo').
	deny: ('foo' endsWith: 'bar').
	deny: ('' endsWith: 'foo').
	
	should: ['0' endsWith: 0] signal: Error.
	should: ['foo' endsWith: true] signal: Error.
	should: ['foo' endsWith: nil] signal: Error.
)
public testStringEquals = (
	assert: 'foo' equals: 'foo'.
	assert: #foo equals: 'foo'.
	assert: 'foo' equals: #foo.

	deny: 'foo' = 'bar'.
	deny: '3' = 3.
	deny: 3 = '3'.
)
public testStringFirstLast = (
	(* This is written so it works without and without string/character unification. *)
	assert: ('bar' first) equals: $b.
	assert: ('bar' last) equals: $r.

	should: ['' first] signal: Error.
	should: ['' last] signal: Error.
)
public testStringFloatIndex = (
	should: ['foo' at: 1 asFloat] signal: Error.
	should: ['foo' runeAt: 1 asFloat] signal: Error.
)
public testStringFromRune = (
	assert: (String fromRune: 122) equals: 'z'.
	assert: ((String fromRune: 0) runeAt: 1) equals: 0.

	should: [String fromRune: -1] signal: Error.
	should: [String fromRune: 16r110000] signal: Error.
	should: [String fromRune: nil] signal: Error.
	should: [String fromRune: 122 asFloat] signal: Error.
	should: [String fromRune: 'z'] signal: Error.
)
public testStringFromRunes = (
	| z zebra |
	z:: String fromRunes: {122}.
	assert: z size equals: 1.
	assert: z equals: 'z'.

	zebra:: String fromRunes: {122. 101. 98. 114. 97}.
	assert: zebra size equals: 5.
	assert: zebra equals: 'zebra'.
	assert: (zebra runeAt: 1) equals: 122.
	assert: (zebra runeAt: 2) equals: 101.
	assert: (zebra runeAt: 3) equals: 98.
	assert: (zebra runeAt: 4) equals: 114.
	assert: (zebra runeAt: 5) equals: 97.
	
	should: [String fromRunes: -1] signal: Error.
	should: [String fromRunes: 16r110000] signal: Error.
	should: [String fromRunes: nil] signal: Error.
	should: [String fromRunes: 122 asFloat] signal: Error.
	should: [String fromRunes: 'z'] signal: Error.

	should: [String fromRunes: {-1}] signal: Error.
	should: [String fromRunes: {16r110000}] signal: Error.
	should: [String fromRunes: {nil}] signal: Error.
	should: [String fromRunes: {122 asFloat}] signal: Error.
	should: [String fromRunes: {'z'}] signal: Error.
)
public testStringHash = (
	assert: 'foo' hash isInteger.
	assert: 'foo' hash > 0.
	
	assert: 'foobar' hash equals: ('foo', 'bar') hash.
	
	assert: '' hash isInteger.
	assert: '' hash > 0.
)
public testStringImmutable = (
	| nonSymbol |
	nonSymbol:: 'foo' , 'bar'.
	
	should: [nonSymbol at: 1 put: $w] signal: MessageNotUnderstood.
	assert: nonSymbol equals: 'foobar'.

	should: [nonSymbol runeAt: 1 put: 65] signal: MessageNotUnderstood.
	assert: nonSymbol equals: 'foobar'.	
)
public testStringIndexOf = (
	assert: ('fofofobar' indexOf: 'fofo') equals: 1.
	assert: ('fofofobar' indexOf: 'bar') equals: 7.
	assert: ('fofofobar' indexOf: 'barr') equals: 0.
	assert: ('fofofobar' indexOf: 'fob') equals: 5.
	assert: ('fofofobar' indexOf: 'baz') equals: 0.
	assert: ('fofofobar' indexOf: 'f') equals: 1.
	assert: ('fofofobar' indexOf: 'r') equals: 9.
	assert: ('fofofobar' indexOf: '') equals: 1.

	assert: ('tiny' indexOf: 'toolong') equals: 0.
	
	assert: ('' indexOf: '') equals: 1.
	assert: ('' indexOf: 'baz') equals: 0.
	
	should: ['fofofobar' indexOf: 0] signal: Error.
	should: ['' indexOf: Object new] signal: Error.
)
public testStringIndexOfStartingAt = (
	assert: ('fofofobar' indexOf: 'fofo' startingAt: 1) equals: 1.
	assert: ('fofofobar' indexOf: 'fofo' startingAt: 2) equals: 3.
	assert: ('fofofobar' indexOf: 'fofo' startingAt: 3) equals: 3.
	assert: ('fofofobar' indexOf: 'fofo' startingAt: 4) equals: 0.
	assert: ('fofofobar' indexOf: 'bar' startingAt: 1) equals: 7.
	assert: ('fofofobar' indexOf: 'bar' startingAt: 7) equals: 7.
	assert: ('fofofobar' indexOf: 'bar' startingAt: 8) equals: 0.
	assert: ('fofofobar' indexOf: 'barr' startingAt: 6) equals: 0.
	assert: ('fofofobar' indexOf: 'fob' startingAt: 5) equals: 5.
	assert: ('fofofobar' indexOf: 'fob' startingAt: 6) equals: 0.
	assert: ('fofofobar' indexOf: 'baz' startingAt: 1) equals: 0.
	assert: ('fofofobar' indexOf: 'f' startingAt: 1) equals: 1.
	assert: ('fofofobar' indexOf: 'f' startingAt: 2) equals: 3.
	assert: ('fofofobar' indexOf: 'r' startingAt: 1) equals: 9.
	assert: ('fofofobar' indexOf: 'r' startingAt: 9) equals: 9.
	assert: ('fofofobar' indexOf: '' startingAt: 1) equals: 1.
	assert: ('fofofobar' indexOf: '' startingAt: 5) equals: 5.
	assert: ('fofofobar' indexOf: '' startingAt: 9) equals: 9.

	assert: ('tiny' indexOf: 'toolong' startingAt: 1) equals: 0.
	assert: ('tiny' indexOf: 'toolong' startingAt: 3) equals: 0.
	
	assert: ('' indexOf: '' startingAt: 1) equals: 1.
	assert: ('' indexOf: 'baz' startingAt: 1) equals: 0.
	
	should: ['fofofobar' indexOf: 0 startingAt: 1] signal: Error.
	should: ['fofobobar' indexOf: Object new startingAt: 1] signal: Error.
	
	should: ['fofofobar' indexOf: 'foo' startingAt: 0] signal: Error.
	should: ['fofofobar' indexOf: 'foo' startingAt: 11] signal: Error.
	should: ['' indexOf: '' startingAt: 0] signal: Error.
	should: ['' indexOf: '' startingAt: 2] signal: Error.
)
public testStringLastIndexOf = (
	assert: ('fofofobar' lastIndexOf: 'fofo') equals: 3.
	assert: ('fofofobar' lastIndexOf: 'bar') equals: 7.
	assert: ('fofofobar' lastIndexOf: 'barr') equals: 0.
	assert: ('fofofobar' lastIndexOf: 'fob') equals: 5.
	assert: ('fofofobar' lastIndexOf: 'baz') equals: 0.
	assert: ('fofofobar' lastIndexOf: 'f') equals: 5.
	assert: ('fofofobar' lastIndexOf: 'r') equals: 9.
	assert: ('fofofobar' lastIndexOf: '') equals: 10.

	assert: ('tiny' lastIndexOf: 'toolong') equals: 0.
	
	assert: ('' lastIndexOf: '') equals: 1.
	assert: ('' lastIndexOf: 'baz') equals: 0.

	should: ['fofofobar' lastIndexOf: 0] signal: Error.
	should: ['' lastIndexOf: Object new] signal: Error.
)
public testStringLastIndexOfStartingAt = (
	assert: ('fofofobar' lastIndexOf: 'fofo' startingAt: 10) equals: 3.
	assert: ('fofofobar' lastIndexOf: 'fofo' startingAt: 4) equals: 3.
	assert: ('fofofobar' lastIndexOf: 'fofo' startingAt: 3) equals: 3.
	assert: ('fofofobar' lastIndexOf: 'fofo' startingAt: 1) equals: 1.
	assert: ('fofofobar' lastIndexOf: 'bar' startingAt: 10) equals: 7.
	assert: ('fofofobar' lastIndexOf: 'bar' startingAt: 7) equals: 7.
	assert: ('fofofobar' lastIndexOf: 'bar' startingAt: 6) equals: 0.
	assert: ('fofofobar' lastIndexOf: 'barr' startingAt: 10) equals: 0.
	assert: ('fofofobar' lastIndexOf: 'fob' startingAt: 10) equals: 5.
	assert: ('fofofobar' lastIndexOf: 'fob' startingAt: 4) equals: 0.
	assert: ('fofofobar' lastIndexOf: 'baz' startingAt: 10) equals: 0.
	assert: ('fofofobar' lastIndexOf: 'f' startingAt: 10) equals: 5.
	assert: ('fofofobar' lastIndexOf: 'f' startingAt: 4) equals: 3.
	assert: ('fofofobar' lastIndexOf: 'f' startingAt: 2) equals: 1.
	assert: ('fofofobar' lastIndexOf: 'r' startingAt: 10) equals: 9.
	assert: ('fofofobar' lastIndexOf: 'r' startingAt: 9) equals: 9.
	assert: ('fofofobar' lastIndexOf: 'r' startingAt: 8) equals: 0.
	assert: ('fofofobar' lastIndexOf: '' startingAt: 10) equals: 10.
	assert: ('fofofobar' lastIndexOf: '' startingAt: 5) equals: 5.
	assert: ('fofofobar' lastIndexOf: '' startingAt: 1) equals: 1.

	assert: ('tiny' lastIndexOf: 'toolong' startingAt: 4) equals: 0.
	assert: ('tiny' lastIndexOf: 'toolong' startingAt: 2) equals: 0.
	
	assert: ('' lastIndexOf: '' startingAt: 1) equals: 1.
	assert: ('' lastIndexOf: 'baz' startingAt: 1) equals: 0.

	should: ['fofofobar' lastIndexOf: 0 startingAt: 1] signal: Error.
	should: ['' lastIndexOf: Object new startingAt: 1] signal: Error.
	
	should: ['fofofobar' lastIndexOf: 'foo' startingAt: 0] signal: Error.
	should: ['fofofobar' lastIndexOf: 'foo' startingAt: 11] signal: Error.
	should: ['' lastIndexOf: '' startingAt: 0] signal: Error.
	should: ['' lastIndexOf: '' startingAt: 2] signal: Error.
)
public testStringRuneAt = (
	assert: ('foo' runeAt: 1) equals: 102.
	assert: ('foo' runeAt: 2) equals: 111.
	assert: ('foo' runeAt: 3) equals: 111.

	should: ['foo' runeAt: 0] signal: Error.
	should: ['foo' runeAt: 4] signal: Error.

	should: ['' runeAt: 0] signal: Error.
	
	should: ['foo' runeAt: -1] signal: Error.
	should: ['foo' runeAt: nil] signal: Error.
	should: ['foo' runeAt: 1 asFloat] signal: Error.
)
public testStringSize = (
	assert: 'foo' size equals: 3.
	assert: #foo size equals: 3.
	assert: '' size equals: 0.
)
public testStringStartsWith = (
	assert: ('foo' startsWith: 'f').
	assert: ('foo' startsWith: 'foo').
	assert: ('foo' startsWith: '').
	assert: ('' startsWith: '').
	deny: ('foo' startsWith: 'toolong').
	deny: ('foo' startsWith: 'fob').
	deny: ('foo' startsWith: 'bar').
	deny: ('' startsWith: 'foo').
	
	should: ['0' startsWith: 0] signal: Error.
	should: ['foo' startsWith: true] signal: Error.
	should: ['foo' startsWith: nil] signal: Error.
)
public testStringSubstring = (
	(* :todo: The Squeak API doesn't allow for extracting the empty string.
	assert: ('Hello, world!' copyFrom: 8 to: 12) equals: 'world'.
	assert: ('Hello, world!' copyFrom: 8 to: 8) equals: ''. *)
	
	should: ['Hello, world!' copyFrom: 8 to: nil] signal: Error.
	should: ['Hello, world!' copyFrom: nil to: 9] signal: Error.
	should: ['Hello, world!' copyFrom: 80 to: 90] signal: Error.
)
public testWideStringAsString = (
	assert: 'Îñţérñåţîöñåļîžåţîờñ' asString equals: 'Îñţérñåţîöñåļîžåţîờñ'.
	assert: #'Îñţérñåţîöñåļîžåţîờñ' asString equals: 'Îñţérñåţîöñåļîžåţîờñ'.
)
public testWideStringAt = (
	(* :todo: It's not clear that being able to quickly iterate code points is actually that useful. *)
	assert: ('Îñţérñåţîöñåļîžåţîờñ' at: 1) equals: 'Î'.
	assert: ('Îñţérñåţîöñåļîžåţîờñ' at: 3) equals: 'ţ'.
	assert: ('Îñţérñåţîöñåļîžåţîờñ' at: 15) equals: 'ž'.
	assert: ('Îñţérñåţîöñåļîžåţîờñ' at: 20) equals: 'ñ'.

	should: ['Îñţérñåţîöñåļîžåţîờñ' at: 0] signal: Error.
	should: ['Îñţérñåţîöñåļîžåţîờñ' at: 21] signal: Error.
	
	should: ['Îñţérñåţîöñåļîžåţîờñ' at: -1] signal: Error.
	should: ['Îñţérñåţîöñåļîžåţîờñ' at: nil] signal: Error.
	should: ['Îñţérñåţîöñåļîžåţîờñ' at: 1 asFloat] signal: Error.
)
public testWideStringFromRune = (
	assert: ((String fromRune: 16r10FFFF) runeAt: 1) equals: 16r10FFFF.
)
public testWideStringFromRunes = (
	| mixed lastChar |
	mixed:: String fromRunes: {100. 200. 300}.
	assert: mixed size equals: 3.
	assert: (mixed runeAt: 1) equals: 100.
	assert: (mixed runeAt: 2) equals: 200.
	assert: (mixed runeAt: 3) equals: 300.

	lastChar:: String fromRunes: {16r10FFFF}.
	assert: lastChar size equals: 1.
	assert: (lastChar runeAt: 1) equals: 16r10FFFF.
)
public testWideStringRuneAt = (
	(* :todo: It's not clear that being able to quickly iterate code points is actually that useful. *)
	assert: ('Îñţérñåţîöñåļîžåţîờñ' runeAt: 1) equals: 206.
	assert: ('Îñţérñåţîöñåļîžåţîờñ' runeAt: 2) equals: 241.
	assert: ('Îñţérñåţîöñåļîžåţîờñ' runeAt: 3) equals: 355.
	assert: ('Îñţérñåţîöñåļîžåţîờñ' runeAt: 4) equals: 233.
	assert: ('Îñţérñåţîöñåļîžåţîờñ' runeAt: 5) equals: 114.
	assert: ('Îñţérñåţîöñåļîžåţîờñ' runeAt: 6) equals: 241.
	assert: ('Îñţérñåţîöñåļîžåţîờñ' runeAt: 7) equals: 229.
	assert: ('Îñţérñåţîöñåļîžåţîờñ' runeAt: 8) equals: 355.
	assert: ('Îñţérñåţîöñåļîžåţîờñ' runeAt: 9) equals: 238.
	assert: ('Îñţérñåţîöñåļîžåţîờñ' runeAt: 10) equals: 246.
	assert: ('Îñţérñåţîöñåļîžåţîờñ' runeAt: 11) equals: 241.
	assert: ('Îñţérñåţîöñåļîžåţîờñ' runeAt: 12) equals: 229.
	assert: ('Îñţérñåţîöñåļîžåţîờñ' runeAt: 13) equals: 316.
	assert: ('Îñţérñåţîöñåļîžåţîờñ' runeAt: 14) equals: 238.
	assert: ('Îñţérñåţîöñåļîžåţîờñ' runeAt: 15) equals: 382.
	assert: ('Îñţérñåţîöñåļîžåţîờñ' runeAt: 16) equals: 229.
	assert: ('Îñţérñåţîöñåļîžåţîờñ' runeAt: 17) equals: 355.
	assert: ('Îñţérñåţîöñåļîžåţîờñ' runeAt: 18) equals: 238.
	assert: ('Îñţérñåţîöñåļîžåţîờñ' runeAt: 19) equals: 7901.
	assert: ('Îñţérñåţîöñåļîžåţîờñ' runeAt: 20) equals: 241.

	should: ['Îñţérñåţîöñåļîžåţîờñ' runeAt: 0] signal: Error.
	should: ['Îñţérñåţîöñåļîžåţîờñ' runeAt: 21] signal: Error.
	
	should: ['Îñţérñåţîöñåļîžåţîờñ' runeAt: -1] signal: Error.
	should: ['Îñţérñåţîöñåļîžåţîờñ' runeAt: nil] signal: Error.
	should: ['Îñţérñåţîöñåļîžåţîờñ' runeAt: 1 asFloat] signal: Error.
)
public testWideStringSize = (
	(* :todo: It's not clear that being able to quickly iterate code points is actually that useful. *)
	assert: 'Îñţérñåţîöñåļîžåţîờñ' size equals: 20.
	assert: #'Îñţérñåţîöñåļîžåţîờñ' size equals: 20.
)
) : (
'as yet unclassified'
TEST_CONTEXT = ()
)
class TestException = Exception () (
) : (
)
'as yet unclassified'
maxDoubleInt = (
	(* 1 << 53 *)
	^9007199254740992
)
maxInt31 = (
	(* 1 << 30 - 1 *)
	^1073741823
)
maxInt32 = (
	(* 1 << 31 - 1 *)
	^2147483647
)
maxInt63 = (
	(* 1 << 62 - 1 *)
	^4611686018427387903
)
maxInt64 = (
	(* 1 << 63 - 1 *)
	^9223372036854775807
)
minDoubleInt = (
	(* -1 << 53 *)
	^-9007199254740992
)
minInt31 = (
	(* -1 << 30 *)
	^-1073741824
)
minInt32 = (
	(* -1 << 31 *)
	^ -2147483648
)
minInt63 = (
	(* -1 << 62 *)
	^ -4611686018427387904
)
minInt64 = (
	(* -1 << 63 *)
	^ -9223372036854775808
)
) : (
)

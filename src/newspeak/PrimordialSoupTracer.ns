Newspeak3
'NS2PrimordialSoup'
class PrimordialSoupTracer packageUsing: manifest = (|
runtime = manifest RuntimeForPrimordialSoup packageRuntimeUsing: manifest.
runtimeWithBuilders = manifest RuntimeWithBuildersForPrimordialSoup packageRuntimeUsing: manifest.
helloApp = manifest HelloApp packageUsing: manifest.
testApp = manifest TestRunner packageUsing: manifest.
benchmarkApp = manifest BenchmarkRunner packageUsing: manifest.
compilerApp = manifest CompilerApp packageUsing: manifest.
|) (
class Tracer usingPlatform: p with: runtime source: ks = (|
List = p collections List.
IdentityMap = p squeak IdentityDictionary.
SmallInteger = p squeak SmallInteger.
LargePositiveInteger = p squeak LargePositiveInteger.
LargeNegativeInteger = p squeak LargeNegativeInteger.
ByteString = p squeak ByteString.
ByteSymbol = p squeak ByteSymbol.
WideString = p squeak WideString.
WideSymbol = p squeak WideSymbol.
Class = p kernel Class.
BlockClosure = p squeak BlockClosure.
False = p squeak False.
ImplementationBase = p squeak ImplementationBase.
Message = p squeak Message.
Metaclass = p kernel Metaclass.
True = p squeak True.
UndefinedObject = p squeak UndefinedObject.
WeakArray = p squeak WeakArray.
WeakSet = p squeak WeakSet.
MethodContext = p squeak MethodContext.
CompiledMethod = p squeak CompiledMethod.
InstanceMixin = p kernel InstanceMixin.
ClassMixin = p kernel ClassMixin.
MethodDictionary = p squeak MethodDictionary.
Dictionary = p squeak Dictionary.
Fraction = p squeak Fraction.
FileStream = p squeak FileStream.
processorAssociation = p squeak Smalltalk associationAt: #Processor.
vmmirror = p squeak VMMirror new.
keepSource = ks.

private kSmiCid = 3.
private kMintCid = 4.
private kBigintCid = 5.
private kFloat64Cid = 6.
private kByteArrayCid = 7.
private kByteStringCid = 8.
private kWideStringCid = 9.
private kArrayCid = 10.
private kWeakArrayCid = 11.
private kEphemeronCid = 12.
private kActivationCid = 13.
private kClosureCid = 14.
private kFirstPlainObjectCid = 15.

psoup = runtime InternalKernel new.
platform = runtime Platform internalKernel: psoup.

replacements = IdentityMap new.
symbolsPlaceholder = Array new.

public stream = ByteArray new writeStream.
clusters = IdentityMap new.
orderedClusters = List new.
stack = List new: 32.
backRefs = IdentityMap new: 4096.
nextBackRef
|) (
class ActivationCluster for: cls = (|
klass = cls.
objects = List new.
|) (
public analyze: object = (
	objects add: object.
	
	enqueue: object sender.
	enqueue: (newBCI: object).
	enqueue: object method.
	enqueue: object closure.
	enqueue: object receiver.
	enqueue: object stackPtr.
	1 to: object stackPtr do: [:i | enqueue: (object tempAt: i)].
)
newBCI: ctxt = (
	ctxt pc isNil ifTrue: [^nil].
	^ctxt pc - ctxt method initialPC + 1.
)
public writeEdges = (
	objects do: [:object |
		writeBackRef: object sender.
		writeBackRef: (newBCI: object).
		writeBackRef: object method.
		writeBackRef: object closure.
		writeBackRef: object receiver.
		stream uint32: object stackPtr. (* can't write smi because smi cluster maybe later*)
		1 to: object stackPtr do: [:i | writeBackRef: (object tempAt: i)]]
)
public writeNodes = (
	| prim = vmmirror. |
	writeFormat: kActivationCid negated.
	stream uint16: objects size.
	{'Nodes activation'. stream position} out.
	objects do: [:object | 
		registerBackRef: object.
		(* stream uint16: object stackPtr *)].
)
) : (
)
class ArrayCluster for: cls = (|
klass = cls.
objects = List new.
|) (
public analyze: object = (
	objects add: object.
	1 to: object size do: [:i | enqueue: (object at: i)].
)
public replace: a with: b = (
	1 to: objects size do: [:index |
		a == (objects at: index) ifTrue: [objects at: index put: b. ^self]].
	halt.
)
public writeEdges = (
	objects do: [:object |
		(backRefs at: object) == 0 ifTrue: [halt].
		object do: [:each | writeBackRef: each]].
)
public writeNodes = (
	| prim = vmmirror. |
	writeFormat: kArrayCid negated.
	stream uint16: objects size.
	{'Nodes array'. stream position} out.
	objects do: [:object | 
		registerBackRef: object.
		stream uint16: (prim indexedSlotsOf: object)].
)
) : (
)
class ByteArrayCluster for: cls = (|
	klass = cls.
	objects = List new.
|) (
public analyze: object = (
	objects add: object.
)
public writeEdges = (
)
public writeNodes = (
	|
	prim = vmmirror.
	stop = [halt].
	|
	writeFormat: kByteArrayCid negated.
	stream uint16: objects size.
	{'Nodes btyearry'. stream position} out.
	objects do: [:object |
		registerBackRef: object.
		stream uint32: object size.
		1 to: object size do: [:i | stream nextPut: (prim ifFail: stop indexedSlotOf: object at: i)]].
)
) : (
)
class ByteStringCluster for: cls = (|
	klass = cls.
	objects = List new.
|halt) (
public analyze: object = (
	objects add: object.
)
public writeEdges = (
)
public writeNodes = (
	|
	prim = vmmirror.
	stop = [halt].
	|
	writeFormat: kByteStringCid negated.
	stream uint16: objects size. (* non-canonical *)
	{'Nodes bytestring'. stream position} out.
	objects do: [:object |
		registerBackRef: object.
		stream uint32: object size.
		1 to: object size do: [:i | stream nextPut: (prim ifFail: stop indexedSlotOf: object at: i)]].
	stream uint16: 0. (* canonical *)
)
) : (
)
class ByteSymbolCluster for: cls = (|
	klass = cls.
	public symbols = List new.
	strings = List new.
|) (
public analyze: object = (
	object isSymbol
		ifTrue: [symbols add: object]
		ifFalse: [strings add: object].
)
public writeEdges = (
)
public writeNodes = (
	|
	prim = vmmirror.
	stop = [halt].
	|
	writeFormat: kByteStringCid negated.
	stream uint16: strings size. (* non-canonical *)
	strings do: [:object |
		registerBackRef: object.
		stream uint32: object size.
		1 to: object size do: [:i | stream nextPut: (prim ifFail: stop indexedSlotOf: object at: i)]].
	
	stream uint16: symbols size. (* canonical *)
	symbols do: [:object |
		registerBackRef: object.
		stream uint32: object size.
		1 to: object size do: [:i | stream nextPut: (prim ifFail: stop indexedSlotOf: object at: i)]].
)
) : (
)
class ClassCluster for: cls = (|
klass = cls.
objects = List new.
rewrites = List new.
|) (
public analyze: object = (
	| rewrite |
	objects add: object.
	rewrite:: {
		object superclass.
		object methodDictionary.
		object enclosingObjectSlot.
		object mixinSlot.
		nil. (* class id slot *)
		newFormatFor: object.
		object name.
		object subclasses isEmpty ifTrue: [nil] ifFalse: [object subclasses].
	}.
	rewrites add: rewrite.
	rewrite do: [:each | enqueue: each].
)
newFormatFor: cls = (
	(* special objects in psoup *)
	psoup SmallInteger == cls ifTrue: [^nil].
	psoup Activation == cls ifTrue: [^nil].
	psoup WeakArray == cls ifTrue: [^nil].
	psoup _Array == cls ifTrue: [^nil].
	psoup ByteArray == cls ifTrue: [^nil].
	psoup ByteString == cls ifTrue: [^nil].
	psoup WideString == cls ifTrue: [^nil].
	psoup MediumInteger == cls ifTrue: [^nil].
	psoup Ephemeron == cls ifTrue: [^3].
	psoup Closure == cls ifTrue: [^nil].

	psoup Method == cls ifTrue: [^cls instSize]. (* A regular object is psoup *)
	
	psoup Metaclass == cls ifTrue: [^7].
	psoup UndefinedObject == cls ifTrue: [^cls instSize].
	psoup True == cls ifTrue: [^cls instSize].
	psoup False == cls ifTrue: [^cls instSize].
	psoup InstanceMixin == cls ifTrue: [^cls instSize].
	psoup ClassMixin == cls ifTrue: [^cls instSize].
	psoup Class == cls ifTrue: [^cls instSize].
	psoup Boolean == cls ifTrue: [^cls instSize].
	psoup Behavior == cls ifTrue: [^cls instSize].
	(classOf: psoup) == cls ifTrue: [^cls instSize].
	psoup _Object == cls ifTrue: [^cls instSize].
	psoup Message == cls ifTrue: [^cls instSize].
	^cls instSize
)
public writeEdges = (
	rewrites size = objects size ifFalse: [halt].
	
	{'edges class'. stream position} out.
	writeBackRef: klass.
	rewrites do: [:rewrite |
		rewrite do: [:ref | writeBackRef: ref].
		].
)
public writeNodes = (

	writeFormat: 8.
	stream uint16: objects size.
	{'Nodes class'. stream position} out.
	objects do: [:object | registerBackRef: object].
)
) : (
)
class ClassMixinCluster for: cls = (|
klass = cls.
objects = List new.
|) (
public analyze: object = (
	objects add: object.
	
	enqueue: object instanceMixin.
	enqueue: object methodDictionary.
	enqueue: object enclosingMixin.
	(* dropping organization, binding *)
)
public writeEdges = (
	{'edges classmixin'. stream position} out.
	writeBackRef: klass.
	objects do: [:object |
		writeBackRef: object instanceMixin.
		writeBackRef: object methodDictionary.
		writeBackRef: object enclosingMixin]
)
public writeNodes = (
	assert: [klass instSize = 3] message: ''.

	writeFormat: klass instSize.
	stream uint16: objects size.
	{'Nodes classmixin'. stream position} out.
	objects do: [:object | registerBackRef: object].
)
) : (
)
class ClosureCluster for: cls = (|
klass = cls.
objects = List new.
|) (
public analyze: object = (
	objects add: object.
	
	(* enqueue: object numCopiedValues. *)(* not written as ref *)
	enqueue: object outerContext.
	enqueue: (newInitialBCI: object).
	enqueue: object numArgs.
	1 to: object numCopiedValues do: [:i | enqueue: (object at: i)].
)
newInitialBCI: block = (
	^block startpc - block method initialPC + 1.
)
public writeEdges = (
	objects do: [:object |
		writeBackRef: object outerContext.
		writeBackRef: (newInitialBCI: object).
		writeBackRef: object numArgs.
		1 to: object numCopiedValues do: [:i | writeBackRef: (object at: i)]]
)
public writeNodes = (
	| prim = vmmirror. |
	writeFormat: kClosureCid negated.
	stream uint16: objects size.
	{'Nodes closure'. stream position} out.
	objects do: [:object | 
		registerBackRef: object.
		stream uint16: object numCopiedValues].
)
) : (
)
class InstanceMixinCluster for: cls = (|
klass = cls.
objects = List new.
|) (
public analyze: object = (
	objects add: object.
	
	enqueue: object name.
	enqueue: object methodDictionary.
	enqueue: object enclosingMixin.
	enqueue: object slots.
	enqueue: object nestedMixins.
	enqueue: object applications.
	enqueue: object classMixin.
	enqueue: object accessModifier.
	enqueue: object cachedConstructorName.
	keepSource ifTrue: [enqueue: object cachedHeaderSource].
	(* dropping category, organization, binding *)
)
public writeEdges = (
	writeBackRef: klass.
	objects do: [:object |
		writeBackRef: object simpleName.
		writeBackRef: object methodDictionary.
		writeBackRef: object enclosingMixin.
		writeBackRef: object slots.
		writeBackRef: object nestedMixins.
		writeBackRef: object applications.
		writeBackRef: object classMixin.
		writeBackRef: object accessModifier.
		writeBackRef: object cachedConstructorName.
		writeBackRef: (keepSource ifTrue: [object cachedHeaderSource]).]
)
public writeNodes = (
	assert: [klass instSize = 10] message: ''.

	writeFormat: klass instSize.
	stream uint16: objects size.
	{'Nodes instancemixin'. stream position} out.
	objects do: [:object | registerBackRef: object].
)
) : (
)
class MetaclassCluster for: cls = (|
klass = cls.
objects = List new.
rewrites = List new.
|) (
public analyze: object = (
	| rewrite |
	objects add: object.
	rewrite:: {
		object superclass.
		object methodDictionary.
		object enclosingObjectSlot.
		object mixinSlot.
		nil. (* class id slot *)
		newFormatFor: object.
		object theNonMetaClass
	}.
	rewrites add: rewrite.
	rewrite do: [:each | enqueue: each].
)
newFormatFor: cls = (
	assert: [cls instSize = 7 (* size in squeak *)] message: ''.
	^7 + 1 (* Adding the class id slot *)
)
public writeEdges = (
	rewrites size = objects size ifFalse: [halt].
	
	{'edges metaclass'. stream position} out.
	writeBackRef: klass.
	rewrites do: [:rewrite |
		rewrite do: [:ref | writeBackRef: ref].
		].
)
public writeNodes = (
	assert: [klass instSize = 7] message: ''.

	writeFormat: klass instSize.
	stream uint16: objects size.
	{'Nodes metaclass'. stream position} out.
	objects do: [:object | registerBackRef: object].
)
) : (
)
class MethodCluster for: cls = (|
klass = cls.
objects = List new.
rewrites = List new.
|) (
public analyze: object = (
	| rewrite |
	objects add: object.
	rewrite:: {
		newHeaderFor: object.
		newLiteralsFor: object.
		newBytecodeFor: object.
		object methodClass. (*mixin*)
		object selector.
		object isSynthetic ifTrue: [nil] ifFalse: [keepSource ifTrue: [object getSource asString] ifFalse: [0]].
	}.
	rewrites add: rewrite.
	rewrite do: [:each | enqueue: each].
)
newBytecodeFor: cm = (
	| a = cm initialPC. b = cm endPC. bytes |
	
	(cm at: a) = 226 ifTrue: [^nil].
	cm endPC > (cm initialPC) ifTrue: [
		((cm at: a + 1) between: 176 and: 183) ifTrue: [^nil].
		(cm at: a + 1) = 235 ifTrue: [^nil]].
	
	bytes:: ByteArray new: b - a + 1.
	1 to: bytes size do: [:i | bytes at: i put: (cm at: a + i - 1)].
	^bytes
)
newHeaderFor: cm = (
	| accessModifier numArgs numTemps primitive start |
	accessModifier:: cm accessModifier.
	accessModifier == #public ifTrue: [accessModifier:: 0].
	accessModifier == #protected ifTrue: [accessModifier:: 1].
	accessModifier == #private ifTrue: [accessModifier:: 2].
	assert: [accessModifier between: 0 and: 3] message: ''.
	
	numArgs:: cm numArgs.
	assert: [numArgs between: 0 and: 255] message: ''.
	
	numTemps:: cm numTemps.
	assert: [numTemps between: 0 and: 255] message: ''.
	
	primitive:: cm pragmaAt: #primitive:.
	primitive == nil
		ifTrue: [primitive:: cm primitive]
		ifFalse: [primitive:: primitive arguments first].
		
	(* quick return self *)
	primitive = 256 ifTrue: [primitive:: 200].
	assert: [primitive < 256] message: ''.
		
	start:: cm initialPC.
	(cm at: start) = 226
		ifTrue: [
			| slot = cm at: start + 1. |
			assert: [slot between: 0 and: 255] message: ''.
			assert: [cm readsField: slot + 1] message: ''.
			assert: [cm initialPC + 2 = cm endPC] message: ''.
			primitive:: 256 + slot. 
			assert: [numArgs = 0] message: ''].
	cm endPC > cm initialPC ifTrue: [
		((cm at: start + 1) between: 176 and: 183) ifTrue: [
			| slot = (cm at: start + 1) bitAnd: 7. |
			assert: [slot between: 0 and: 255] message: ''.
			primitive:: 512 + slot].
		(cm at: start + 1) = 235 ifTrue: [
			| slot = cm at: start + 2. |
			assert: [slot between: 0 and: 255] message: ''.
			primitive:: 512 + slot]].
		
	assert: [primitive between: 0 and: 1024] message: ''.
	
	(* 0:7 numArgs
		8:15 numTemps
		16:27 prim 
		28:29 access *)
	^(accessModifier << 28) | (primitive << 16) | (numTemps << 8) | (numArgs << 0)
)
newLiteralsFor: cm = (
	^cm literals allButLast: 2
)
public writeEdges = (
	rewrites size = objects size ifFalse: [halt].
	{'edges method'. stream position} out.
	writeBackRef: klass.
	rewrites do: [:rewrite |
		rewrite do: [:ref | writeBackRef: ref].
		].
)
public writeNodes = (
	assert: [klass instSize = 6] message: ''.

	writeFormat: klass instSize.
	stream uint16: objects size.
	{'Nodes method'. stream position} out.
	objects do: [:object | registerBackRef: object].
)
) : (
)
class PlainCluster for: cls = (|
klass = cls.
namedSlots = cls format bitAnd: 16rFFFF.
objects = List new.
|) (
public analyze: object = (
	|
	prim = vmmirror.
	stop = [halt].
	|
	objects add: object.
	1 to: namedSlots do: [:i | enqueue: (prim ifFail: stop namedSlotOf: object at: i)].
)
public writeEdges = (
	|
	prim = vmmirror.
	stop = [halt].
	n = namedSlots.
	|
	{'edges regular'. stream position} out.
	writeBackRef: klass.
	objects do: [:object |
		1 to: n do: [:i | writeBackRef: (prim ifFail: stop namedSlotOf: object at: i)]].
)
public writeNodes = (
	writeFormat: klass instSize.
	stream uint16: objects size.
	{'Nodes regular'. stream position} out.
	objects do: [:object | registerBackRef: object].
)
) : (
)
class SmallIntegerCluster for: cls = (|
	klass = cls.
	small = List new.
	large = List new.
|) (
public analyze: object = (

	(object between:  -9223372036854775808 and:  9223372036854775807)
		ifTrue: [small add: object]
		ifFalse: [large add: object].	
)
public writeEdges = (
)
public writeNodes = (
	writeFormat: kSmiCid negated.
	stream uint16: small size.	
	{'Nodes smi'. stream position} out.
	small do: [:object |
		registerBackRef: object.
		on: stream int64: object].

	stream uint16: large size.
	large do: [:object |
		registerBackRef: object.
		stream nextPut: ((object < 0) ifTrue: [1] ifFalse: [0]).
		stream uint16: object digitLength.
		1 to: object digitLength do: [:i | stream nextPut: (object digitAt: i)]].
)
) : (
)
class WeakArrayCluster for: cls = (|
klass = cls.
objects = List new.
|) (
public analyze: object = (
	objects add: object.
	(* 1 to: object size do: [:i | enqueue: (object at: i)]. *)
)
public writeEdges = (
	objects do: [:object |
		object do: [:each | writeWeakBackRef: each]].
)
public writeNodes = (
	| prim = vmmirror. |
	writeFormat: kWeakArrayCid negated.
	stream uint16: objects size.
	{'Nodes weakarray'. stream position} out.
	objects do: [:object | 
		registerBackRef: object.
		stream uint16: (prim indexedSlotsOf: object)].
)
) : (
)
class WideStringCluster for: cls = (|
	klass = cls.
	objects = List new.
|) (
public analyze: object = (
	objects add: object.
)
public writeEdges = (
)
public writeNodes = (
	|
	prim = vmmirror.
	stop = [halt].
	|
	writeFormat: kWideStringCid negated.
	stream uint16: objects size. (* non-canonical *)
	{'Nodes bytestring'. stream position} out.
	objects do: [:object |
		registerBackRef: object.
		stream uint32: object size.
		1 to: object size do: [:i | stream uint32: (prim ifFail: stop indexedSlotOf: object at: i)]].
	stream uint16: 0. (* canonical *)
)
) : (
)
analyze: object = (
	(clusterFor: object) analyze: object.
)
buildReplacements = (
	replaceClass: Array with: psoup _Array.
	replaceClass: ByteArray with: psoup ByteArray.
	replaceClass: ByteString with: psoup ByteString.
	replaceClass: ByteSymbol with: psoup ByteString.
	replaceClass: WideString with: psoup WideString.
	replaceClass: WideSymbol with: psoup WideString.
	replaceClass: Class with: psoup Class.
	replaceClass: BlockClosure with: psoup Closure.
	replaceClass: False with: psoup False.
	replaceClass: Message with: psoup Message.
	replaceClass: Metaclass with: psoup Metaclass.
	replaceClass: SmallInteger with: psoup SmallInteger.
	replaceClass: True with: psoup True.
	replaceClass: UndefinedObject with: psoup UndefinedObject.
	replaceClass: WeakArray with: psoup WeakArray.
	replaceClass: MethodContext with: psoup Activation.
	replaceClass: CompiledMethod with: psoup Method.
	replaceClass: InstanceMixin with: psoup InstanceMixin.
	replaceClass: ClassMixin with: psoup ClassMixin.
	replaceClass: Object with: psoup _Object.
	replaceClass: Fraction with: psoup Fraction.
	
	replacements at: processorAssociation put: nil.
)
classOf: object = (
	^vmmirror classOf: object
)
clusterFor: object = (
	^clusterForClass: (replace: (vmmirror classOf: object)).
)
clusterForClass: klass = (
	^clusters at: klass ifAbsentPut: [orderedClusters add: (newClusterForClass: klass)].
)
enqueue: preobject = (
	| object |
	object:: replace: preobject. 
	backRefs at: object ifAbsentPut: [stack add: object. 0].
)
newClusterForClass: klass = (
	LargePositiveInteger == klass ifTrue: [^SmallIntegerCluster for: klass].
	LargeNegativeInteger == klass ifTrue: [^SmallIntegerCluster for: klass].
	
	enqueue: klass.
	
	(* Schema change in psoup *)
	klass isMeta ifTrue: [^ClassCluster for: klass].
	psoup Metaclass == klass ifTrue: [^MetaclassCluster for: klass].
	psoup InstanceMixin == klass ifTrue: [^InstanceMixinCluster for: klass].
	psoup ClassMixin == klass ifTrue: [^ClassMixinCluster for: klass].
	psoup Method == klass ifTrue: [^MethodCluster for: klass].
	
	(* special objects in psoup *)
	psoup _Array == klass ifTrue: [^ArrayCluster for: klass].
	psoup ByteArray == klass ifTrue: [^ByteArrayCluster for: klass].
	psoup ByteString == klass ifTrue: [^ByteSymbolCluster for: klass].
	psoup WideString == klass ifTrue: [^WideStringCluster for: klass].
	psoup SmallInteger == klass ifTrue: [^SmallIntegerCluster for: klass].
	psoup WeakArray  == klass ifTrue: [^WeakArrayCluster for: klass].
	psoup Activation == klass ifTrue: [^ActivationCluster for: klass].
	psoup Closure == klass ifTrue: [^ClosureCluster for: klass].

	(* regular objects in psoup *)
	psoup UndefinedObject == klass ifTrue: [^PlainCluster for: klass].
	psoup True == klass ifTrue: [^PlainCluster for: klass].
	psoup False == klass ifTrue: [^PlainCluster for: klass].
	(vmmirror classOf: psoup) = klass ifTrue: [^PlainCluster for: klass].
	^PlainCluster for: klass
)
newReplace: preobject = (
	| preclass = vmmirror classOf: preobject. |
	
	(* MethodDictionary -> Array *)
	MethodDictionary == preclass ifTrue: [^preobject values].

	(* WeakSet (Class>>subclasses and InstanceMixin>>applications) -> WeakArray *)
	WeakSet == preclass ifTrue: [^WeakArray withAll: (preobject asArray reject: [:e | e isNil]) ].
	
	(* Dictionary (InstanceMixin>>nestedMixins -> Array *)
	Dictionary == preclass ifTrue: [^newReplaceDictionary: preobject].

	(* Character -> String *)
	Character == preclass ifTrue: [^preobject asString].
	^preobject
)
newReplaceDictionary: preobject = (
	(* Must be the nested mixins map *)
	| x = preobject values. |
	x do: [:ea | assert: [ea isMixin] message: ''].
	^Array withAll: x
)
on: stm int64: anInteger = (
	| n |
	(anInteger < 16r8000000000000000 negated) | (anInteger >= 16r8000000000000000)
		ifTrue: [self error: 'outside 32-bit integer range'].

	anInteger < 0
		ifTrue: [n:: 16r10000000000000000 + anInteger]
		ifFalse: [n:: anInteger].
	stm nextPut: (n digitAt: 8).
	stm nextPut: (n digitAt: 7).
	stm nextPut: (n digitAt: 6).
	stm nextPut: (n digitAt: 5).
	stm nextPut: (n digitAt: 4).
	stm nextPut: (n digitAt: 3).
	stm nextPut: (n digitAt: 2).
	stm nextPut: (n digitAt: 1).
)
patchImplementationBase = (
	psoup _Object superclass: nil.
	psoup _Object methodDictionary at: #'initializer`new' put: 
		(CompiledMethod toReturnSelf selector: #'initializer`new'; yourself).
)
putUnsigned: value = (
	| v ::= value. |
	[v > 127] whileTrue: 
		[stream nextPut: (v bitAnd: 127).
		 v:: v >> 7].
	stream nextPut: v + 128.
)
registerBackRef: object = (
	| r = replace: object. |
	r == object ifFalse: [halt].
	backRefs at: object put: nextBackRef.
	nextBackRef:: nextBackRef + 1.
)
replace: preobject = (
	^replacements at: preobject ifAbsentPut: [newReplace: preobject]
)
replaceClass: oldClass with: newClass = (
	replacements at: oldClass put: newClass.
	replacements at: (vmmirror classOf: oldClass) put: (vmmirror classOf: newClass).
)
serialize: root = (
	| rewind fastforward finalSymbols |
	nextBackRef:: 1.

	(* Side-effect these clusters first. *)
	clusterFor: SmallInteger.
	clusterFor: ByteString.	
	
	enqueue: root.
	[stack isEmpty] whileFalse: [analyze: stack removeLast].

	(* Now that we're done tracing, we know what symbols are included and 'become' the placeholder array we initialized the kernel with. TODO: Should be weak array *)
	finalSymbols:: (clusters at: psoup ByteString) symbols asArray.
	(clusters at: psoup _Array) replace: symbolsPlaceholder with: finalSymbols. (* swap node *)
	replacements at: symbolsPlaceholder put: finalSymbols. (* swap incoming edges *)
	
	stream uint16: 16r1984.
	stream uint16: 0.
	stream uint16: orderedClusters size.
	rewind:: stream position.
	stream uint32: 0.
	orderedClusters do: [:c | c writeNodes].
	orderedClusters do: [:c | c writeEdges].
	writeBackRef: root.

	fastforward:: stream position.
	stream position: rewind.
	stream uint32: nextBackRef - 1.
	stream position: fastforward.
)
public serialize: app to: filename = (
	| root |
	patchImplementationBase.
	buildReplacements.
	root:: psoup buildObjectStoreWithApplication: app platform: platform symbols: symbolsPlaceholder.
	serialize: root.
	
	FileStream forceNewFileNamed: filename do: [:stm |
		stm binary.
		stm nextPutAll: stream contents.
		stm close]. 
)
writeBackRef: object = (
	| r = backRefs at: (replacements at: object). |
	r == 0 ifTrue: [halt].
	putUnsigned: r.
)
writeFormat: format = (
	stream int32: format.
)
writeWeakBackRef: object = (
	| ref = backRefs at: (replace: object) ifAbsent: [backRefs at: nil]. |
	putUnsigned: ref.
)
) : (
)
public main: p args: a = (
	(Tracer usingPlatform: p with: runtime source: false) 
		serialize: helloApp to: 'primordialsoup/snapshots/hello.vfuel'.

	(Tracer usingPlatform: p with: runtimeWithBuilders source: false) 
		serialize: testApp to: 'primordialsoup/snapshots/tests.vfuel'.

	(Tracer usingPlatform: p with: runtime source: false) 
		serialize: benchmarkApp to: 'primordialsoup/snapshots/benchmarks.vfuel'.
		
	(Tracer usingPlatform: p with: runtimeWithBuilders source: false)
		serialize: compilerApp to: 'primordialsoup/snapshots/compiler.vfuel'.
)
) : (
)
